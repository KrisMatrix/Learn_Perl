.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Slices 3"
.TH Slices 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Slices \-\- Indexing, slicing, and dicing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use PDL;
\&  $x = ones(3,3);
\&  $y = $x\->slice(\*(Aq\-1:0,(1)\*(Aq);
\&  $c = $x\->dummy(2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package provides many of the powerful PerlDL core index
manipulation routines.  These routines mostly allow two-way data flow,
so you can modify your data in the most convenient representation.
For example, you can make a 1000x1000 unit matrix with
.PP
.Vb 2
\& $x = zeroes(1000,1000);
\& $x\->diagonal(0,1) ++;
.Ve
.PP
which is quite efficient. See PDL::Indexing and PDL::Tips for
more examples.
.PP
Slicing is so central to the \s-1PDL\s0 language that a special compile-time
syntax has been introduced to handle it compactly; see PDL::NiceSlice
for details.
.PP
\&\s-1PDL\s0 indexing and slicing functions usually include two-way data flow,
so that you can separate the actions of reshaping your data structures
and modifying the data themselves.  Two special methods, \*(L"copy\*(R" and
\&\*(L"sever\*(R", help you control the data flow connection between related
variables.
.PP
.Vb 2
\& $y = $x\->slice("1:3"); # Slice maintains a link between $x and $y.
\& $y += 5;               # $x is changed!
.Ve
.PP
If you want to force a physical copy and no data flow, you can copy or
sever the slice expression:
.PP
.Vb 2
\& $y = $x\->slice("1:3")\->copy;
\& $y += 5;               # $x is not changed.
\&
\& $y = $x\->slice("1:3")\->sever;
\& $y += 5;               # $x is not changed.
.Ve
.PP
The difference between \f(CW\*(C`sever\*(C'\fR and \f(CW\*(C`copy\*(C'\fR is that sever acts on (and
returns) its argument, while copy produces a disconnected copy.  If you
say
.PP
.Vb 2
\& $y = $x\->slice("1:3");
\& $c = $y\->sever;
.Ve
.PP
then the variables \f(CW$y\fR and \f(CW$c\fR point to the same object but with
\&\f(CW\*(C`\->copy\*(C'\fR they would not.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "index"
.IX Subsection "index"
.Vb 1
\&  Signature: (a(n); indx ind(); [oca] c())
.Ve
.PP
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`index1d\*(C'\fR, and \f(CW\*(C`index2d\*(C'\fR provide rudimentary index indirection.
.PP
.Vb 3
\& $c = index($source,$ind);
\& $c = index1d($source,$ind);
\& $c = index2d($source2,$ind1,$ind2);
.Ve
.PP
use the \f(CW$ind\fR variables as indices to look up values in \f(CW$source\fR.
The three routines broadcast slightly differently.
.IP "\(bu" 3
\&\f(CW\*(C`index\*(C'\fR uses direct broadcasting for 1\-D indexing across the 0 dim
of \f(CW$source\fR.  It can broadcast over source broadcast dims or index broadcast
dims, but not (easily) both: If \f(CW$source\fR has more than 1
dimension and \f(CW$ind\fR has more than 0 dimensions, they must agree in
a broadcasting sense.
.IP "\(bu" 3
\&\f(CW\*(C`index1d\*(C'\fR uses a single active dim in \f(CW$ind\fR to produce a list of
indexed values in the 0 dim of the output \- it is useful for
collapsing \f(CW$source\fR by indexing with a single row of values along
\&\f(CW$source\fR's 0 dimension.  The output has the same number of dims as
\&\f(CW$source\fR.  The 0 dim of the output has size 1 if \f(CW$ind\fR is a
scalar, and the same size as the 0 dim of \f(CW$ind\fR if it is not. If
\&\f(CW$ind\fR and \f(CW$source\fR both have more than 1 dim, then all dims higher
than 0 must agree in a broadcasting sense.
.IP "\(bu" 3
\&\f(CW\*(C`index2d\*(C'\fR works like \f(CW\*(C`index\*(C'\fR but uses separate ndarrays for X and Y
coordinates.  For more general N\-dimensional indexing, see the
PDL::NiceSlice syntax or PDL::Slices (in particular \f(CW\*(C`slice\*(C'\fR,
\&\f(CW\*(C`indexND\*(C'\fR, and \f(CW\*(C`range\*(C'\fR).
.PP
These functions are two-way, i.e. after
.PP
.Vb 2
\& $c = $x\->index(pdl[0,5,8]);
\& $c .= pdl [0,2,4];
.Ve
.PP
the changes in \f(CW$c\fR will flow back to \f(CW$x\fR.
.PP
\&\f(CW\*(C`index\*(C'\fR provids simple broadcasting:  multiple-dimensioned arrays are treated
as collections of 1\-D arrays, so that
.PP
.Vb 3
\& $x = xvals(10,10)+10*yvals(10,10);
\& $y = $x\->index(3);
\& $c = $x\->index(9\-xvals(10));
.Ve
.PP
puts a single column from \f(CW$x\fR into \f(CW$y\fR, and puts a single element
from each column of \f(CW$x\fR into \f(CW$c\fR.  If you want to extract multiple
columns from an array in one operation, see \*(L"dice\*(R" or
\&\*(L"indexND\*(R".
.PP
index barfs if any of the index values are bad.
.SS "index1d"
.IX Subsection "index1d"
.Vb 1
\&  Signature: (a(n); indx ind(m); [oca] c(m))
.Ve
.PP
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`index1d\*(C'\fR, and \f(CW\*(C`index2d\*(C'\fR provide rudimentary index indirection.
.PP
.Vb 3
\& $c = index($source,$ind);
\& $c = index1d($source,$ind);
\& $c = index2d($source2,$ind1,$ind2);
.Ve
.PP
use the \f(CW$ind\fR variables as indices to look up values in \f(CW$source\fR.
The three routines broadcast slightly differently.
.IP "\(bu" 3
\&\f(CW\*(C`index\*(C'\fR uses direct broadcasting for 1\-D indexing across the 0 dim
of \f(CW$source\fR.  It can broadcast over source broadcast dims or index broadcast
dims, but not (easily) both: If \f(CW$source\fR has more than 1
dimension and \f(CW$ind\fR has more than 0 dimensions, they must agree in
a broadcasting sense.
.IP "\(bu" 3
\&\f(CW\*(C`index1d\*(C'\fR uses a single active dim in \f(CW$ind\fR to produce a list of
indexed values in the 0 dim of the output \- it is useful for
collapsing \f(CW$source\fR by indexing with a single row of values along
\&\f(CW$source\fR's 0 dimension.  The output has the same number of dims as
\&\f(CW$source\fR.  The 0 dim of the output has size 1 if \f(CW$ind\fR is a
scalar, and the same size as the 0 dim of \f(CW$ind\fR if it is not. If
\&\f(CW$ind\fR and \f(CW$source\fR both have more than 1 dim, then all dims higher
than 0 must agree in a broadcasting sense.
.IP "\(bu" 3
\&\f(CW\*(C`index2d\*(C'\fR works like \f(CW\*(C`index\*(C'\fR but uses separate ndarrays for X and Y
coordinates.  For more general N\-dimensional indexing, see the
PDL::NiceSlice syntax or PDL::Slices (in particular \f(CW\*(C`slice\*(C'\fR,
\&\f(CW\*(C`indexND\*(C'\fR, and \f(CW\*(C`range\*(C'\fR).
.PP
These functions are two-way, i.e. after
.PP
.Vb 2
\& $c = $x\->index(pdl[0,5,8]);
\& $c .= pdl [0,2,4];
.Ve
.PP
the changes in \f(CW$c\fR will flow back to \f(CW$x\fR.
.PP
\&\f(CW\*(C`index\*(C'\fR provids simple broadcasting:  multiple-dimensioned arrays are treated
as collections of 1\-D arrays, so that
.PP
.Vb 3
\& $x = xvals(10,10)+10*yvals(10,10);
\& $y = $x\->index(3);
\& $c = $x\->index(9\-xvals(10));
.Ve
.PP
puts a single column from \f(CW$x\fR into \f(CW$y\fR, and puts a single element
from each column of \f(CW$x\fR into \f(CW$c\fR.  If you want to extract multiple
columns from an array in one operation, see \*(L"dice\*(R" or
\&\*(L"indexND\*(R".
.PP
index1d propagates \s-1BAD\s0 index elements to the output variable.
.SS "index2d"
.IX Subsection "index2d"
.Vb 1
\&  Signature: (a(na,nb); indx inda(); indx indb(); [oca] c())
.Ve
.PP
\&\f(CW\*(C`index\*(C'\fR, \f(CW\*(C`index1d\*(C'\fR, and \f(CW\*(C`index2d\*(C'\fR provide rudimentary index indirection.
.PP
.Vb 3
\& $c = index($source,$ind);
\& $c = index1d($source,$ind);
\& $c = index2d($source2,$ind1,$ind2);
.Ve
.PP
use the \f(CW$ind\fR variables as indices to look up values in \f(CW$source\fR.
The three routines broadcast slightly differently.
.IP "\(bu" 3
\&\f(CW\*(C`index\*(C'\fR uses direct broadcasting for 1\-D indexing across the 0 dim
of \f(CW$source\fR.  It can broadcast over source broadcast dims or index broadcast
dims, but not (easily) both: If \f(CW$source\fR has more than 1
dimension and \f(CW$ind\fR has more than 0 dimensions, they must agree in
a broadcasting sense.
.IP "\(bu" 3
\&\f(CW\*(C`index1d\*(C'\fR uses a single active dim in \f(CW$ind\fR to produce a list of
indexed values in the 0 dim of the output \- it is useful for
collapsing \f(CW$source\fR by indexing with a single row of values along
\&\f(CW$source\fR's 0 dimension.  The output has the same number of dims as
\&\f(CW$source\fR.  The 0 dim of the output has size 1 if \f(CW$ind\fR is a
scalar, and the same size as the 0 dim of \f(CW$ind\fR if it is not. If
\&\f(CW$ind\fR and \f(CW$source\fR both have more than 1 dim, then all dims higher
than 0 must agree in a broadcasting sense.
.IP "\(bu" 3
\&\f(CW\*(C`index2d\*(C'\fR works like \f(CW\*(C`index\*(C'\fR but uses separate ndarrays for X and Y
coordinates.  For more general N\-dimensional indexing, see the
PDL::NiceSlice syntax or PDL::Slices (in particular \f(CW\*(C`slice\*(C'\fR,
\&\f(CW\*(C`indexND\*(C'\fR, and \f(CW\*(C`range\*(C'\fR).
.PP
These functions are two-way, i.e. after
.PP
.Vb 2
\& $c = $x\->index(pdl[0,5,8]);
\& $c .= pdl [0,2,4];
.Ve
.PP
the changes in \f(CW$c\fR will flow back to \f(CW$x\fR.
.PP
\&\f(CW\*(C`index\*(C'\fR provids simple broadcasting:  multiple-dimensioned arrays are treated
as collections of 1\-D arrays, so that
.PP
.Vb 3
\& $x = xvals(10,10)+10*yvals(10,10);
\& $y = $x\->index(3);
\& $c = $x\->index(9\-xvals(10));
.Ve
.PP
puts a single column from \f(CW$x\fR into \f(CW$y\fR, and puts a single element
from each column of \f(CW$x\fR into \f(CW$c\fR.  If you want to extract multiple
columns from an array in one operation, see \*(L"dice\*(R" or
\&\*(L"indexND\*(R".
.PP
index2d barfs if either of the index values are bad.
.SS "indexNDb"
.IX Subsection "indexNDb"
.Vb 1
\&  Backwards\-compatibility alias for indexND
.Ve
.SS "indexND"
.IX Subsection "indexND"
.Vb 1
\&  Find selected elements in an N\-D ndarray, with optional boundary handling
.Ve
.PP
.Vb 1
\&  $out = $source\->indexND( $index, [$method] )
\&
\&  $source = 10*xvals(10,10) + yvals(10,10);
\&  $index  = pdl([[2,3],[4,5]],[[6,7],[8,9]]);
\&  print $source\->indexND( $index );
\&
\&  [
\&   [23 45]
\&   [67 89]
\&  ]
.Ve
.PP
IndexND collapses \f(CW$index\fR by lookup into \f(CW$source\fR.  The
0th dimension of \f(CW$index\fR is treated as coordinates in \f(CW$source\fR, and
the return value has the same dimensions as the rest of \f(CW$index\fR.
The returned elements are looked up from \f(CW$source\fR.  Dataflow
works \*(-- propagated assignment flows back into \f(CW$source\fR.
.PP
IndexND and IndexNDb were originally separate routines but they are both
now implemented as a call to \*(L"range\*(R", and have identical syntax to
one another.
.PP
\&\s-1SEE ALSO:\s0
.PP
\&\*(L"whichND\*(R" in PDL::Primitive returns N\-D indices into a multidimensional
\&\s-1PDL,\s0 suitable for feeding to this.
.SS "rangeb"
.IX Subsection "rangeb"
.Vb 1
\&  Signature: (P(); C(); pdl *ind_pdl; SV *size; SV *boundary_sv)
.Ve
.PP
Engine for \*(L"range\*(R"
.PP
Same calling convention as \*(L"range\*(R", but you must supply all
parameters.  \f(CW\*(C`rangeb\*(C'\fR is marginally faster as it makes a direct \s-1PP\s0 call,
avoiding the perl argument-parsing step.
.SS "range"
.IX Subsection "range"
Extract selected chunks from a source ndarray, with boundary conditions
.PP
.Vb 1
\&        $out = $source\->range($index,[$size,[$boundary]])
.Ve
.PP
Returns elements or rectangular slices of the original ndarray, indexed by
the \f(CW$index\fR ndarray.  \f(CW$source\fR is an N\-dimensional ndarray, and \f(CW$index\fR is
an ndarray whose first dimension has size up to N.  Each row of \f(CW$index\fR is
treated as coordinates of a single value or chunk from \f(CW$source\fR, specifying
the location(s) to extract.
.PP
If you specify a single index location, then range is essentially an expensive
slice, with controllable boundary conditions.
.PP
\&\fB\s-1INPUTS\s0\fR
.PP
\&\f(CW$index\fR and \f(CW$size\fR can be ndarrays or array refs such as you would
feed to zeroes and its ilk.  If \f(CW$index\fR's 0th dimension
has size higher than the number of dimensions in \f(CW$source\fR, then
\&\f(CW$source\fR is treated as though it had trivial dummy dimensions of
size 1, up to the required size to be indexed by \f(CW$index\fR \*(-- so if
your source array is 1\-D and your index array is a list of 3\-vectors,
you get two dummy dimensions of size 1 on the end of your source array.
.PP
You can extract single elements or N\-D rectangular ranges from \f(CW$source\fR,
by setting \f(CW$size\fR.  If \f(CW$size\fR is undef or zero, then you get a single
sample for each row of \f(CW$index\fR.  This behavior is similar to
\&\*(L"indexNDb\*(R", which is in fact implemented as a call to \*(L"range\*(R".
.PP
If \f(CW$size\fR is positive then you get a range of values from \f(CW$source\fR at
each location, and the output has extra dimensions allocated for them.
\&\f(CW$size\fR can be a scalar, in which case it applies to all dimensions, or an
N\-vector, in which case each element is applied independently to the
corresponding dimension in \f(CW$source\fR.  See below for details.
.PP
\&\f(CW$boundary\fR is a number, string, or list ref indicating the type of
boundary conditions to use when ranges reach the edge of \f(CW$source\fR.  If you
specify no boundary conditions the default is to forbid boundary violations
on all axes.  If you specify exactly one boundary condition, it applies to
all axes.  If you specify more (as elements of a list ref, or as a packed
string, see below), then they apply to dimensions in the order in which they
appear, and the last one applies to all subsequent dimensions.  (This is
less difficult than it sounds; see the examples below).
.IP "0 (synonyms: 'f','forbid') \fB(default)\fR" 3
.IX Item "0 (synonyms: 'f','forbid') (default)"
Ranges are not allowed to cross the boundary of the original \s-1PDL.\s0  Disallowed
ranges throw an error.  The errors are thrown at evaluation time, not
at the time of the range call (this is the same behavior as \*(L"slice\*(R").
.IP "1 (synonyms: 't','truncate')" 3
.IX Item "1 (synonyms: 't','truncate')"
Values outside the original ndarray get \s-1BAD\s0 if you've got bad value
support compiled into your \s-1PDL\s0 and set the badflag for the source \s-1PDL\s0;
or 0 if you haven't (you must set the badflag if you want BADs for out
of bound values, otherwise you get 0).  Reverse dataflow works \s-1OK\s0 for
the portion of the child that is in-bounds.  The out-of-bounds part of
the child is reset to (BAD|0) during each dataflow operation, but
execution continues.
.IP "2 (synonyms: 'e','x','extend')" 3
.IX Item "2 (synonyms: 'e','x','extend')"
Values that would be outside the original ndarray point instead to the
nearest allowed value within the ndarray.  See the \s-1CAVEAT\s0 below on
mappings that are not single valued.
.IP "3 (synonyms: 'p','periodic')" 3
.IX Item "3 (synonyms: 'p','periodic')"
Periodic boundary conditions apply: the numbers in \f(CW$index\fR are applied,
strict-modulo the corresponding dimensions of \f(CW$source\fR.  This is equivalent to
duplicating the \f(CW$source\fR ndarray throughout N\-D space.  See the \s-1CAVEAT\s0 below
about mappings that are not single valued.
.IP "4 (synonyms: 'm','mirror')" 3
.IX Item "4 (synonyms: 'm','mirror')"
Mirror-reflection periodic boundary conditions apply.  See the \s-1CAVEAT\s0
below about mappings that are not single valued.
.PP
The boundary condition identifiers all begin with unique characters, so
you can feed in multiple boundary conditions as either a list ref or a
packed string.  (The packed string is marginally faster to run).  For
example, the four expressions [0,1], ['forbid','truncate'], ['f','t'],
and 'ft' all specify that violating the boundary in the 0th dimension
throws an error, and all other dimensions get truncated.
.PP
If you feed in a single string, it is interpreted as a packed boundary
array if all of its characters are valid boundary specifiers (e.g. 'pet'),
but as a single word-style specifier if they are not (e.g. 'forbid').
.PP
\&\fB\s-1OUTPUT\s0\fR
.PP
The output broadcasts over both \f(CW$index\fR and \f(CW$source\fR.  Because implicit
broadcasting can happen in a couple of ways, a little thought is needed.  The
returned dimension list is stacked up like this:
.PP
.Vb 1
\&   (index broadcast dims), (index dims (size)), (source broadcast dims)
.Ve
.PP
The first few dims of the output correspond to the extra dims of
\&\f(CW$index\fR (beyond the 0 dim). They allow you to pick out individual
ranges from a large, broadcasted collection.
.PP
The middle few dims of the output correspond to the size dims
specified in \f(CW$size\fR, and contain the range of values that is extracted
at each location in \f(CW$source\fR.  Every nonzero element of \f(CW$size\fR is copied to
the dimension list here, so that if you feed in (for example) \f(CW\*(C`$size
= [2,0,1]\*(C'\fR you get an index dim list of \f(CW\*(C`(2,1)\*(C'\fR.
.PP
The last few dims of the output correspond to extra dims of \f(CW$source\fR beyond
the number of dims indexed by \f(CW$index\fR.  These dims act like ordinary
broadcast dims, because adding more dims to \f(CW$source\fR just tacks extra dims
on the end of the output.  Each source broadcast dim ranges over the entire
corresponding dim of \f(CW$source\fR.
.PP
\&\fBDataflow\fR: Dataflow is bidirectional.
.PP
\&\fBExamples\fR:
Here are basic examples of \f(CW\*(C`range\*(C'\fR operation, showing how to get
ranges out of a small matrix.  The first few examples show extraction
and selection of individual chunks.  The last example shows
how to mark loci in the original matrix (using dataflow).
.PP
.Vb 10
\& pdl> $src = 10*xvals(10,5)+yvals(10,5)
\& pdl> print $src\->range([2,3])    # Cut out a single element
\& 23
\& pdl> print $src\->range([2,3],1)  # Cut out a single 1x1 block
\& [
\&  [23]
\& ]
\& pdl> print $src\->range([2,3], [2,1]) # Cut a 2x1 chunk
\& [
\&  [23 33]
\& ]
\& pdl> print $src\->range([[2,3]],[2,1]) # Trivial list of 1 chunk
\& [
\&  [
\&   [23]
\&   [33]
\&  ]
\& ]
\& pdl> print $src\->range([[2,3],[0,1]], [2,1])   # two 2x1 chunks
\& [
\&  [
\&   [23  1]
\&   [33 11]
\&  ]
\& ]
\& pdl> # A 2x2 collection of 2x1 chunks
\& pdl> print $src\->range([[[1,1],[2,2]],[[2,3],[0,1]]],[2,1])
\& [
\&  [
\&   [
\&    [11 22]
\&    [23  1]
\&   ]
\&   [
\&    [21 32]
\&    [33 11]
\&   ]
\&  ]
\& ]
\& pdl> $src = xvals(5,3)*10+yvals(5,3)
\& pdl> print $src\->range(3,1)  # Broadcast over y dimension in $src
\& [
\&  [30]
\&  [31]
\&  [32]
\& ]
\&
\& pdl> $src = zeroes(5,4);
\& pdl> $src\->range(pdl([2,3],[0,1]),pdl(2,1)) .= xvals(2,2,1) + 1
\& pdl> print $src
\& [
\&  [0 0 0 0 0]
\&  [2 2 0 0 0]
\&  [0 0 0 0 0]
\&  [0 0 1 1 0]
\& ]
.Ve
.PP
\&\fB\s-1CAVEAT\s0\fR: It's quite possible to select multiple ranges that
intersect.  In that case, modifying the ranges doesn't have a
guaranteed result in the original \s-1PDL\s0 \*(-- the result is an arbitrary
choice among the valid values.  For some things that's \s-1OK\s0; but for
others it's not. In particular, this doesn't work:
.PP
.Vb 3
\&    pdl> $photon_list = new PDL::RandVar\->sample(500)\->reshape(2,250)*10
\&    pdl> $histogram = zeroes(10,10)
\&    pdl> $histogram\->range($photon_list,1)++;  #not what you wanted
.Ve
.PP
The reason is that if two photons land in the same bin, then that bin
doesn't get incremented twice.  (That may get fixed in a later version...)
.PP
\&\fB\s-1PERMISSIVE RANGING\s0\fR: If \f(CW$index\fR has too many dimensions compared
to \f(CW$source\fR, then \f(CW$source\fR is treated as though it had dummy
dimensions of size 1, up to the required number of dimensions.  These
virtual dummy dimensions have the usual boundary conditions applied to
them.
.PP
If the 0 dimension of \f(CW$index\fR is ludicrously large (if its size is
more than 5 greater than the number of dims in the source \s-1PDL\s0) then
range will insist that you specify a size in every dimension, to make
sure that you know what you're doing.  That catches a common error with
range usage: confusing the initial dim (which is usually small) with another
index dim (perhaps of size 1000).
.PP
If the index variable is Empty, then \fBrange()\fR always returns the Empty \s-1PDL.\s0
If the index variable is not Empty, indexing it always yields a boundary
violation.  All non-barfing conditions are treated as truncation, since
there are no actual data to return.
.PP
\&\fB\s-1EFFICIENCY\s0\fR: Because \f(CW\*(C`range\*(C'\fR isn't an affine transformation (it
involves lookup into a list of N\-D indices), it is somewhat
memory-inefficient for long lists of ranges, and keeping dataflow open
is much slower than for affine transformations (which don't have to copy
data around).
.PP
Doing operations on small subfields of a large range is inefficient
because the engine must flow the entire range back into the original
\&\s-1PDL\s0 with every atomic perl operation, even if you only touch a single element.
One way to speed up such code is to sever your range, so that \s-1PDL\s0
doesn't have to copy the data with each operation, then copy the
elements explicitly at the end of your loop.  Here's an example that
labels each region in a range sequentially, using many small
operations rather than a single xvals assignment:
.PP
.Vb 5
\&  ### How to make a collection of small ops run fast with range...
\&  $x =  $data\->range($index, $sizes, $bound)\->sever;
\&  $aa = $data\->range($index, $sizes, $bound);
\&  $x($_ \- 1) .= $_ for 1..$x\->nelem;    # Lots of little ops
\&  $aa .= $x;
.Ve
.PP
\&\f(CW\*(C`range\*(C'\fR is a perl front-end to a \s-1PP\s0 function, \f(CW\*(C`rangeb\*(C'\fR.  Calling
\&\f(CW\*(C`rangeb\*(C'\fR is marginally faster but requires that you include all arguments.
.PP
\&\s-1DEVEL NOTES\s0
.PP
* index broadcast dimensions are effectively clumped internally.  This
makes it easier to loop over the index array but a little more brain-bending
to tease out the algorithm.
.PP
rangeb processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rld"
.IX Subsection "rld"
.Vb 1
\&  Signature: (indx a(n); b(n); [o]c(m))
.Ve
.PP
Run-length decode a vector
.PP
Given a vector \f(CW$x\fR of the numbers of instances of values \f(CW$y\fR, run-length
decode to \f(CW$c\fR.
.PP
.Vb 1
\& rld($x,$y,$c=null);
.Ve
.PP
rld does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rle"
.IX Subsection "rle"
.Vb 1
\&  Signature: (c(n); indx [o]a(m); [o]b(m))
.Ve
.PP
Run-length encode a vector
.PP
Given vector \f(CW$c\fR, generate a vector \f(CW$x\fR with the number of each
element, and a vector \f(CW$y\fR of the unique values.  New in \s-1PDL 2.017,\s0
only the elements up to the first instance of \f(CW0\fR in \f(CW$x\fR are
returned, which makes the common use case of a 1\-dimensional \f(CW$c\fR simpler.
For broadcast operation, \f(CW$x\fR and \f(CW$y\fR will be large enough
to hold the largest row of \f(CW$y\fR, and only the elements up to the
first instance of \f(CW0\fR in each row of \f(CW$x\fR should be considered.
.PP
.Vb 4
\& $c = floor(4*random(10));
\& rle($c,$x=null,$y=null);
\& #or
\& ($x,$y) = rle($c);
\&
\& #for $c of shape [10, 4]:
\& $c = floor(4*random(10,4));
\& ($x,$y) = rle($c);
\&
\& #to see the results of each row one at a time:
\& foreach (0..$c\->dim(1)\-1){
\&  my ($as,$bs) = ($x(:,($_)),$y(:,($_)));
\&  my ($ta,$tb) = where($as,$bs,$as!=0); #only the non\-zero elements of $x
\&  print $c(:,($_)) . " rle==> " , ($ta,$tb) , "\etrld==> " . rld($ta,$tb) . "\en";
\& }
\&
\& # the inverse of (chance of all 6 3d6 rolls being >= each possible sum)
\& ($nrolls, $ndice, $dmax) = (6, 3, 6);
\& ($x, $x1) = (allaxisvals(($dmax) x $ndice)+1)\->sumover\->flat\->qsort\->rle;
\& $y = $x\->cumusumover;
\& $yprob1x = $y\->slice(\*(Aq\-1:0\*(Aq)\->double / $y\->slice(\*(Aq(\-1)\*(Aq);
\& $z = cat($x1, 1 / $yprob1x**$nrolls)\->transpose;
.Ve
.PP
rle does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rlevec"
.IX Subsection "rlevec"
.Vb 1
\&  Signature: (c(M,N); indx [o]a(N); [o]b(M,N))
.Ve
.PP
Run-length encode a set of vectors.
.PP
Higher-order \fBrle()\fR, for use with \fBqsortvec()\fR.
.PP
Given set of vectors \f(CW$c\fR, generate a vector \f(CW$a\fR with the number of occurrences of each element
(where an \*(L"element\*(R" is a vector of length \f(CW$M\fR ocurring in \f(CW$c\fR),
and a set of vectors \f(CW$b\fR containing the unique values.
As for \fBrle()\fR, only the elements up to the first instance of 0 in \f(CW$a\fR should be considered.
.PP
Can be used together with \fBclump()\fR to run-length encode \*(L"values\*(R" of arbitrary dimensions.
Can be used together with \fBrotate()\fR, \fBcat()\fR, \fBappend()\fR, and \fBqsortvec()\fR to count N\-grams
over a 1d \s-1PDL.\s0
.PP
See also: \*(L"rle\*(R", \*(L"qsortvec\*(R" in PDL::Ufunc, \*(L"uniqvec\*(R" in PDL::Primitive
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
rlevec does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rldvec"
.IX Subsection "rldvec"
.Vb 1
\&  Signature: (indx a(N); b(M,N); [o]c(M,N))
.Ve
.PP
Run-length decode a set of vectors, akin to a higher-order \fBrld()\fR.
.PP
Given a vector $a() of the number of occurrences of each row, and a set $c()
of row-vectors each of length \f(CW$M\fR, run-length decode to $c().
.PP
Can be used together with \fBclump()\fR to run-length decode \*(L"values\*(R" of arbitrary dimensions.
.PP
See also: \*(L"rld\*(R".
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
rldvec does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rleseq"
.IX Subsection "rleseq"
.Vb 1
\&  Signature: (c(N); indx [o]a(N); [o]b(N))
.Ve
.PP
Run-length encode a vector of subsequences.
.PP
Given a vector of $c() of concatenated variable-length, variable-offset subsequences,
generate a vector \f(CW$a\fR containing the length of each subsequence
and a vector \f(CW$b\fR containing the subsequence offsets.
As for \fBrle()\fR, only the elements up to the first instance of 0 in \f(CW$a\fR should be considered.
.PP
See also \*(L"rle\*(R".
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
rleseq does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rldseq"
.IX Subsection "rldseq"
.Vb 1
\&  Signature: (indx a(N); b(N); [o]c(M))
.Ve
.PP
Run-length decode a subsequence vector.
.PP
Given a vector $a() of sequence lengths
and a vector $b() of corresponding offsets,
decode concatenation of subsequences to $c(),
as for:
.PP
.Vb 2
\& $c = null;
\& $c = $c\->append($b($_)+sequence($a\->type,$a($_))) foreach (0..($N\-1));
.Ve
.PP
See also: \*(L"rld\*(R".
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
rldseq does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rleND"
.IX Subsection "rleND"
.Vb 1
\&  Signature: (data(@vdims,N); int [o]counts(N); [o]elts(@vdims,N))
.Ve
.PP
Run-length encode a set of (sorted) n\-dimensional values.
.PP
Generalization of \fBrle()\fR and \fBvv_rlevec()\fR:
given set of values \f(CW$data\fR, generate a vector \f(CW$counts\fR with the number of occurrences of each element
(where an \*(L"element\*(R" is a matrix of dimensions \f(CW@vdims\fR ocurring as a sequential run over the
final dimension in \f(CW$data\fR), and a set of vectors \f(CW$elts\fR containing the elements which begin a run.
Really just a wrapper for \fBclump()\fR and \fBrlevec()\fR.
.PP
See also: \*(L"rle\*(R", \*(L"rlevec\*(R".
Contributed by Bryan Jurish <moocow@cpan.org>.
.SS "rldND"
.IX Subsection "rldND"
.Vb 1
\&  Signature: (int counts(N); elts(@vdims,N); [o]data(@vdims,N);)
.Ve
.PP
Run-length decode a set of (sorted) n\-dimensional values.
.PP
Generalization of \fBrld()\fR and \fBrldvec()\fR:
given a vector $\fBcounts()\fR of the number of occurrences of each \f(CW@vdims\fR\-dimensioned element,
and a set $\fBelts()\fR of \f(CW@vdims\fR\-dimensioned elements, run-length decode to $\fBdata()\fR.
.PP
Really just a wrapper for \fBclump()\fR and \fBrldvec()\fR.
.PP
See also: \*(L"rld\*(R", \*(L"rldvec\*(R".
Contributed by Bryan Jurish <moocow@cpan.org>.
.SS "xchg"
.IX Subsection "xchg"
.Vb 1
\&  Signature: (P(); C(); PDL_Indx n1; PDL_Indx n2)
.Ve
.PP
exchange two dimensions
.PP
Negative dimension indices count from the end.
.PP
The command
.PP
.Vb 1
\& $y = $x\->xchg(2,3);
.Ve
.PP
creates \f(CW$y\fR to be like \f(CW$x\fR except that the dimensions 2 and 3
are exchanged with each other i.e.
.PP
.Vb 1
\& $y\->at(5,3,2,8) == $x\->at(5,3,8,2)
.Ve
.PP
xchg does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "reorder"
.IX Subsection "reorder"
Re-orders the dimensions of a \s-1PDL\s0 based on the supplied list.
.PP
Similar to the \*(L"xchg\*(R" method, this method re-orders the dimensions
of a \s-1PDL.\s0 While the \*(L"xchg\*(R" method swaps the position of two dimensions,
the reorder method can change the positions of many dimensions at
once.
.PP
.Vb 2
\& # Completely reverse the dimension order of a 6\-Dim array.
\& $reOrderedPDL = $pdl\->reorder(5,4,3,2,1,0);
.Ve
.PP
The argument to reorder is an array representing where the current dimensions
should go in the new array. In the above usage, the argument to reorder
\&\f(CW\*(C`(5,4,3,2,1,0)\*(C'\fR
indicates that the old dimensions (\f(CW$pdl\fR's dims) should be re-arranged to make the
new pdl (\f(CW$reOrderPDL\fR) according to the following:
.PP
.Vb 8
\&   Old Position   New Position
\&   \-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-
\&   5              0
\&   4              1
\&   3              2
\&   2              3
\&   1              4
\&   0              5
.Ve
.PP
You do not need to specify all dimensions, only a complete set
starting at position 0.  (Extra dimensions are left where they are).
This means, for example, that you can \fBreorder()\fR the X and Y dimensions of
an image, and not care whether it is an \s-1RGB\s0 image with a third dimension running
across color plane.
.PP
Example:
.PP
.Vb 10
\& pdl> $x = sequence(5,3,2);       # Create a 3\-d Array
\& pdl> p $x
\& [
\&  [
\&   [ 0  1  2  3  4]
\&   [ 5  6  7  8  9]
\&   [10 11 12 13 14]
\&  ]
\&  [
\&   [15 16 17 18 19]
\&   [20 21 22 23 24]
\&   [25 26 27 28 29]
\&  ]
\& ]
\& pdl> p $x\->reorder(2,1,0); # Reverse the order of the 3\-D PDL
\& [
\&  [
\&   [ 0 15]
\&   [ 5 20]
\&   [10 25]
\&  ]
\&  [
\&   [ 1 16]
\&   [ 6 21]
\&   [11 26]
\&  ]
\&  [
\&   [ 2 17]
\&   [ 7 22]
\&   [12 27]
\&  ]
\&  [
\&   [ 3 18]
\&   [ 8 23]
\&   [13 28]
\&  ]
\&  [
\&   [ 4 19]
\&   [ 9 24]
\&   [14 29]
\&  ]
\& ]
.Ve
.PP
The above is a simple example that could be duplicated by calling
\&\f(CW\*(C`$x\->xchg(0,2)\*(C'\fR, but it demonstrates the basic functionality of reorder.
.PP
As this is an index function, any modifications to the
result \s-1PDL\s0 will change the parent.
.SS "mv"
.IX Subsection "mv"
.Vb 1
\&  Signature: (P(); C(); PDL_Indx n1; PDL_Indx n2)
.Ve
.PP
move a dimension to another position
.PP
The command
.PP
.Vb 1
\& $y = $x\->mv(4,1);
.Ve
.PP
creates \f(CW$y\fR to be like \f(CW$x\fR except that the dimension 4 is moved to the
place 1, so:
.PP
.Vb 1
\& $y\->at(1,2,3,4,5,6) == $x\->at(1,5,2,3,4,6);
.Ve
.PP
The other dimensions are moved accordingly.
Negative dimension indices count from the end.
.PP
mv does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "using"
.IX Subsection "using"
Returns array of column numbers requested
.PP
.Vb 1
\& line $pdl\->using(1,2);
.Ve
.PP
Plot, as a line, column 1 of \f(CW$pdl\fR vs. column 2
.PP
.Vb 2
\& pdl> $pdl = rcols("file");
\& pdl> line $pdl\->using(1,2);
.Ve
.SS "diagonal"
.IX Subsection "diagonal"
.Vb 1
\&  Signature: (P(); C(); PDL_Indx whichdims[])
.Ve
.PP
Returns the multidimensional diagonal over the specified dimensions.
.PP
The diagonal is placed at the first (by number) dimension that is
diagonalized.
The other diagonalized dimensions are removed. So if \f(CW$x\fR has dimensions
\&\f(CW\*(C`(5,3,5,4,6,5)\*(C'\fR then after
.PP
.Vb 1
\& $d = $x\->diagonal(dim1, dim2,...)
.Ve
.PP
.Vb 1
\& $y = $x\->diagonal(0,2,5);
.Ve
.PP
the ndarray \f(CW$y\fR has dimensions \f(CW\*(C`(5,3,4,6)\*(C'\fR and
\&\f(CW\*(C`$y\->at(2,1,0,1)\*(C'\fR refers
to \f(CW\*(C`$x\->at(2,1,2,0,1,2)\*(C'\fR.
.PP
\&\s-1NOTE:\s0 diagonal doesn't handle broadcastids correctly. \s-1XXX FIX\s0
.PP
.Vb 10
\& pdl> $x = zeroes(3,3,3);
\& pdl> ($y = $x\->diagonal(0,1))++;
\& pdl> p $x
\& [
\&  [
\&   [1 0 0]
\&   [0 1 0]
\&   [0 0 1]
\&  ]
\&  [
\&   [1 0 0]
\&   [0 1 0]
\&   [0 0 1]
\&  ]
\&  [
\&   [1 0 0]
\&   [0 1 0]
\&   [0 0 1]
\&  ]
\& ]
.Ve
.PP
diagonal does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "lags"
.IX Subsection "lags"
.Vb 1
\&  Signature: (P(); C(); PDL_Indx nthdim;PDL_Indx step;PDL_Indx n)
.Ve
.PP
Returns an ndarray of lags to parent.
.PP
Usage:
.PP
.Vb 1
\&  $lags = $x\->lags($nthdim,$step,$nlags);
.Ve
.PP
I.e. if \f(CW$x\fR contains
.PP
.Vb 1
\& [0,1,2,3,4,5,6,7]
.Ve
.PP
then
.PP
.Vb 1
\& $y = $x\->lags(0,2,2);
.Ve
.PP
is a (5,2) matrix
.PP
.Vb 2
\& [2,3,4,5,6,7]
\& [0,1,2,3,4,5]
.Ve
.PP
This order of returned indices is kept because the function is
called \*(L"lags\*(R" i.e. the nth lag is n steps behind the original.
.PP
\&\f(CW$step\fR and \f(CW$nlags\fR must be positive. \f(CW$nthdim\fR can be
negative and will then be counted from the last dim backwards
in the usual way (\-1 = last dim).
.PP
lags does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "splitdim"
.IX Subsection "splitdim"
.Vb 1
\&  Signature: (P(); C(); PDL_Indx nthdim;PDL_Indx nsp)
.Ve
.PP
Splits a dimension in the parent ndarray (opposite of clump).
As of 2.076, throws exception if non-divisible \f(CW\*(C`nsp\*(C'\fR given, and can
give negative \f(CW\*(C`nthdim\*(C'\fR which then counts backwards.
.PP
After
.PP
.Vb 1
\& $y = $x\->splitdim(2,3);
.Ve
.PP
the expression
.PP
.Vb 1
\& $y\->at(6,4,m,n,3,6) == $x\->at(6,4,m+3*n)
.Ve
.PP
is always true (\f(CW\*(C`m\*(C'\fR has to be less than 3).
.PP
splitdim does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rotate"
.IX Subsection "rotate"
.Vb 1
\&  Signature: (x(n); indx shift(); [oca]y(n))
.Ve
.PP
Shift vector elements along with wrap. Flows data back&forth.
.PP
rotate does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "broadcastI"
.IX Subsection "broadcastI"
.Vb 1
\&  Signature: (P(); C(); PDL_Indx id; PDL_Indx whichdims[])
.Ve
.PP
internal
.PP
Put some dimensions to a broadcastid.
.PP
.Vb 1
\& $y = $x\->broadcastI(0,1,5); # broadcast over dims 1,5 in id 1
.Ve
.PP
broadcastI does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "unbroadcast"
.IX Subsection "unbroadcast"
.Vb 1
\&  Signature: (P(); C(); PDL_Indx atind)
.Ve
.PP
All broadcasted dimensions are made real again.
.PP
See [\s-1TBD\s0 Doc] for details and examples.
.PP
unbroadcast does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "dice"
.IX Subsection "dice"
Dice rows/columns/planes out of a \s-1PDL\s0 using indexes for
each dimension.
.PP
This function can be used to extract irregular subsets
along many dimension of a \s-1PDL,\s0 e.g. only certain rows in an image,
or planes in a cube. This can of course be done with
the usual dimension tricks but this saves having to
figure it out each time!
.PP
This method is similar in functionality to the \*(L"slice\*(R"
method, but \*(L"slice\*(R" requires that contiguous ranges or ranges
with constant offset be extracted. ( i.e. \*(L"slice\*(R" requires
ranges of the form \f(CW\*(C`1,2,3,4,5\*(C'\fR or \f(CW\*(C`2,4,6,8,10\*(C'\fR). Because of this
restriction, \*(L"slice\*(R" is more memory efficient and slightly faster
than dice
.PP
.Vb 1
\& $slice = $data\->dice([0,2,6],[2,1,6]); # Dicing a 2\-D array
.Ve
.PP
The arguments to dice are arrays (or 1D PDLs) for each dimension
in the \s-1PDL.\s0 These arrays are used as indexes to which rows/columns/cubes,etc
to dice-out (or extract) from the \f(CW$data\fR \s-1PDL.\s0
.PP
Use \f(CW\*(C`X\*(C'\fR to select all indices along a given dimension (compare also
mslice). As usual (in slicing methods) trailing
dimensions can be omitted implying \f(CW\*(C`X\*(C'\fR'es for those.
.PP
.Vb 10
\& pdl> $x = sequence(10,4)
\& pdl> p $x
\& [
\&  [ 0  1  2  3  4  5  6  7  8  9]
\&  [10 11 12 13 14 15 16 17 18 19]
\&  [20 21 22 23 24 25 26 27 28 29]
\&  [30 31 32 33 34 35 36 37 38 39]
\& ]
\& pdl> p $x\->dice([1,2],[0,3]) # Select columns 1,2 and rows 0,3
\& [
\&  [ 1  2]
\&  [31 32]
\& ]
\& pdl> p $x\->dice(X,[0,3])
\& [
\&  [ 0  1  2  3  4  5  6  7  8  9]
\&  [30 31 32 33 34 35 36 37 38 39]
\& ]
\& pdl> p $x\->dice([0,2,5])
\& [
\&  [ 0  2  5]
\&  [10 12 15]
\&  [20 22 25]
\&  [30 32 35]
\& ]
.Ve
.PP
As this is an index function, any modifications to the
slice will change the parent (use the \f(CW\*(C`.=\*(C'\fR operator).
.SS "dice_axis"
.IX Subsection "dice_axis"
Dice rows/columns/planes from a single \s-1PDL\s0 axis (dimension)
using index along a specified axis
.PP
This function can be used to extract irregular subsets
along any dimension, e.g. only certain rows in an image,
or planes in a cube. This can of course be done with
the usual dimension tricks but this saves having to
figure it out each time!
.PP
.Vb 1
\& $slice = $data\->dice_axis($axis,$index);
.Ve
.PP
.Vb 10
\& pdl> $x = sequence(10,4)
\& pdl> $idx = pdl(1,2)
\& pdl> p $x\->dice_axis(0,$idx) # Select columns
\& [
\&  [ 1  2]
\&  [11 12]
\&  [21 22]
\&  [31 32]
\& ]
\& pdl> $t = $x\->dice_axis(1,$idx) # Select rows
\& pdl> $t.=0
\& pdl> p $x
\& [
\&  [ 0  1  2  3  4  5  6  7  8  9]
\&  [ 0  0  0  0  0  0  0  0  0  0]
\&  [ 0  0  0  0  0  0  0  0  0  0]
\&  [30 31 32 33 34 35 36 37 38 39]
\& ]
.Ve
.PP
The trick to using this is that the index selects
elements along the dimensions specified, so if you
have a 2D image \f(CW\*(C`axis=0\*(C'\fR will select certain \f(CW\*(C`X\*(C'\fR values
\&\- i.e. extract columns
.PP
As this is an index function, any modifications to the
slice will change the parent.
.SS "slice"
.IX Subsection "slice"
.Vb 1
\&  Signature: (P(); C(); pdl_slice_args *arglist)
.Ve
.PP
.Vb 1
\&  $slice = $data\->slice([2,3],\*(Aqx\*(Aq,[2,2,0],"\-1:1:\-1", "*3");
.Ve
.PP
Extract rectangular slices of an ndarray, from a string specifier,
an array ref specifier, or a combination.
.PP
\&\f(CW\*(C`slice\*(C'\fR is the main method for extracting regions of PDLs and
manipulating their dimensionality.  You can call it directly or
via the NiceSlice source prefilter that extends
Perl syntax to include array slicing.
.PP
\&\f(CW\*(C`slice\*(C'\fR can extract regions along each dimension of a source \s-1PDL,\s0
subsample or reverse those regions, dice each dimension by selecting a
list of locations along it, or basic \s-1PDL\s0 indexing routine.  The
selected subfield remains connected to the original \s-1PDL\s0 via dataflow.
In most cases this neither allocates more memory nor slows down
subsequent operations on either of the two connected PDLs.
.PP
You pass in a list of arguments.  Each term in the list controls
the disposition of one axis of the source \s-1PDL\s0 and/or returned \s-1PDL.\s0
Each term can be a string-format cut specifier, a list ref that
gives the same information without recourse to string manipulation,
or a \s-1PDL\s0 with up to 1 dimension giving indices along that axis that
should be selected.
.PP
If you want to pass in a single string specifier for the entire
operation, you can pass in a comma-delimited list as the first
argument.  \f(CW\*(C`slice\*(C'\fR detects this condition and splits the string
into a regular argument list.  This calling style is fully
backwards compatible with \f(CW\*(C`slice\*(C'\fR calls from before \s-1PDL 2.006.\s0
.PP
\&\fB\s-1STRING SYNTAX\s0\fR
.PP
If a particular argument to \f(CW\*(C`slice\*(C'\fR is a string, it is parsed as a
selection, an affine slice, or a dummy dimension depending on the
form.  Leading or trailing whitespace in any part of each specifier is
ignored (though it is not ignored within numbers).
.ie n .IP "\*(Aq\*(Aq, "":"", or ""X"" \*(-- keep" 3
.el .IP "\f(CW\*(Aq\*(Aq\fR, \f(CW:\fR, or \f(CWX\fR \*(-- keep" 3
.IX Item ", :, or X keep"
The empty string, \f(CW\*(C`:\*(C'\fR, or \f(CW\*(C`X\*(C'\fR cause the entire corresponding
dimension to be kept unchanged.
.ie n .IP """<n>"" \*(-- selection" 3
.el .IP "\f(CW<n>\fR \*(-- selection" 3
.IX Item "<n> selection"
A single number alone causes a single index to be selected from the
corresponding dimension.  The dimension is kept (and reduced to size
1) in the output.
.ie n .IP """(<n>)"" \*(-- selection and collapse" 3
.el .IP "\f(CW(<n>)\fR \*(-- selection and collapse" 3
.IX Item "(<n>) selection and collapse"
A single number in parenthesis causes a single index to be selected
from the corresponding dimension.  The dimension is discarded
(completely eliminated) in the output.
.ie n .IP """<n>:<m>"" \*(-- select an inclusive range" 3
.el .IP "\f(CW<n>:<m>\fR \*(-- select an inclusive range" 3
.IX Item "<n>:<m> select an inclusive range"
Two numbers separated by a colon selects a range of values from the
corresponding axis, e.g. \f(CW\*(C`3:4\*(C'\fR selects elements 3 and 4 along the
corresponding axis, and reduces that axis to size 2 in the output.
Both numbers are regularized so that you can address the last element
of the axis with an index of \f(CW\*(C` \-1 \*(C'\fR.  If, after regularization, the
two numbers are the same, then exactly one element gets selected (just
like the \f(CW\*(C`<n>\*(C'\fR case).  If, after regulariation, the second number
is lower than the first, then the resulting slice counts down rather
than up \*(-- e.g. \f(CW\*(C`\-1:0\*(C'\fR will return the entire axis, in reversed
order.
.ie n .IP """<n>:<m>:<s>"" \*(-- select a range with explicit step" 3
.el .IP "\f(CW<n>:<m>:<s>\fR \*(-- select a range with explicit step" 3
.IX Item "<n>:<m>:<s> select a range with explicit step"
If you include a third parameter, it is the stride of the extracted
range.  For example, \f(CW\*(C`0:\-1:2\*(C'\fR will sample every other element
across the complete dimension.  Specifying a stride of 1 prevents
autoreversal \*(-- so to ensure that your slice is *always* forward
you can specify, e.g., \f(CW\*(C`2:$n:1\*(C'\fR.  In that case, an \*(L"impossible\*(R"
slice gets an Empty \s-1PDL\s0 (with 0 elements along the corresponding
dimension), so you can generate an Empty \s-1PDL\s0 with a slice of the
form \f(CW\*(C`2:1:1\*(C'\fR.
.ie n .IP """*<n>"" \*(-- insert a dummy dimension" 3
.el .IP "\f(CW*<n>\fR \*(-- insert a dummy dimension" 3
.IX Item "*<n> insert a dummy dimension"
Dummy dimensions aren't present in the original source and are
\&\*(L"mocked up\*(R" to match dimensional slots, by repeating the data
in the original \s-1PDL\s0 some number of times.  An asterisk followed
by a number produces a dummy dimension in the output, for
example \f(CW*2\fR will generate a dimension of size 2 at
the corresponding location in the output dim list.  Omitting
the number (and using just an asterisk) inserts a dummy dimension
of size 1.
.PP
\&\fB\s-1ARRAY REF SYNTAX\s0\fR
.PP
If you feed in an \s-1ARRAY\s0 ref as a slice term, then it can have
0\-3 elements.  The first element is the start of the slice along
the corresponding dim; the second is the end; and the third is
the stepsize.  Different combinations of inputs give the same
flexibility as the string syntax.
.ie n .IP """[]"" \- keep dim intact" 3
.el .IP "\f(CW[]\fR \- keep dim intact" 3
.IX Item "[] - keep dim intact"
An empty \s-1ARRAY\s0 ref keeps the entire corresponding dim
.ie n .IP """[ \*(AqX\*(Aq ]"" \- keep dim intact" 3
.el .IP "\f(CW[ \*(AqX\*(Aq ]\fR \- keep dim intact" 3
.IX Item "[ X ] - keep dim intact"
.PD 0
.ie n .IP """[ \*(Aq*\*(Aq,$n ]"" \- generate a dummy dim of size $n" 3
.el .IP "\f(CW[ \*(Aq*\*(Aq,$n ]\fR \- generate a dummy dim of size \f(CW$n\fR" 3
.IX Item "[ *,$n ] - generate a dummy dim of size $n"
.PD
If \f(CW$n\fR is missing, you get a dummy dim of size 1.
.ie n .IP """[ $dex, , 0 ]"" \- collapse and discard dim" 3
.el .IP "\f(CW[ $dex, , 0 ]\fR \- collapse and discard dim" 3
.IX Item "[ $dex, , 0 ] - collapse and discard dim"
\&\f(CW$dex\fR must be a single value.  It is used to index
the source, and the corresponding dimension is discarded.
.ie n .IP """[ $start, $end ]"" \- collect inclusive slice" 3
.el .IP "\f(CW[ $start, $end ]\fR \- collect inclusive slice" 3
.IX Item "[ $start, $end ] - collect inclusive slice"
In the simple two-number case, you get a slice that runs
up or down (as appropriate) to connect \f(CW$start\fR and \f(CW$end\fR.
.ie n .IP """[ $start, $end, $inc ]"" \- collect inclusive slice" 3
.el .IP "\f(CW[ $start, $end, $inc ]\fR \- collect inclusive slice" 3
.IX Item "[ $start, $end, $inc ] - collect inclusive slice"
The three-number case works exactly like the three-number
string case above.
.PP
\&\fB\s-1PDL\s0 args for dicing\fR
.PP
If you pass in a 0\- or 1\-D \s-1PDL\s0 as a slicing argument, the
corresponding dimension is \*(L"diced\*(R" \*(-- you get one position
along the corresponding dim, per element of the indexing \s-1PDL,\s0
e.g. \f(CW\*(C`$x\->slice( pdl(3,4,9))\*(C'\fR gives you elements 3, 4, and
9 along the 0 dim of \f(CW$x\fR.
.PP
Because dicing is not an affine transformation, it is slower than
direct slicing even though the syntax is convenient.
.PP
.Vb 3
\& $x\->slice(\*(Aq1:3\*(Aq);  #  return the second to fourth elements of $x
\& $x\->slice(\*(Aq3:1\*(Aq);  #  reverse the above
\& $x\->slice(\*(Aq\-2:1\*(Aq); #  return last\-but\-one to second elements of $x
\&
\& $x\->slice([1,3]);  # Same as above three calls, but using array ref syntax
\& $x\->slice([3,1]);
\& $x\->slice([\-2,1]);
.Ve
.PP
slice does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SH "BUGS"
.IX Header "BUGS"
For the moment, you can't slice one of the zero-length dims of an
empty ndarray.  It is not clear how to implement this in a way that makes
sense.
.PP
Many types of index errors are reported far from the indexing
operation that caused them.  This is caused by the underlying architecture:
\&\fBslice()\fR sets up a mapping between variables, but that mapping isn't
tested for correctness until it is used (potentially much later).
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 1997 Tuomas J. Lukka.  Contributions by
Craig DeForest, deforest@boulder.swri.edu.
Documentation contributions by David Mertens.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution,
the copyright notice should be included in the file.
