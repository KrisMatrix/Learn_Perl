.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Image2D 3"
.TH Image2D 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Image2D \- Miscellaneous 2D image processing functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Miscellaneous 2D image processing functions \- for want
of anywhere else to put them.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use PDL::Image2D;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "conv2d"
.IX Subsection "conv2d"
.Vb 1
\&  Signature: (a(m,n); kern(p,q); [o]b(m,n); int opt)
.Ve
.PP
2D convolution of an array with a kernel (smoothing)
.PP
For large kernels, using a \s-1FFT\s0 routine,
such as \fBfftconvolve()\fR in \f(CW\*(C`PDL::FFT\*(C'\fR,
will be quicker.
.PP
.Vb 1
\& $new = conv2d $old, $kernel, {OPTIONS}
.Ve
.PP
.Vb 1
\& $smoothed = conv2d $image, ones(3,3), {Boundary => Reflect}
.Ve
.PP
.Vb 7
\& Boundary \- controls what values are assumed for the image when kernel
\&            crosses its edge:
\&            => Default   \- periodic boundary conditions
\&                           (i.e. wrap around axis)
\&            => Reflect   \- reflect at boundary
\&            => Truncate  \- truncate at boundary
\&            => Replicate \- repeat boundary pixel values
.Ve
.PP
Unlike the \s-1FFT\s0 routines, conv2d is able to process bad values.
.SS "med2d"
.IX Subsection "med2d"
.Vb 1
\&  Signature: (a(m,n); kern(p,q); [o]b(m,n); double [t]tmp(pq); int opt)
.Ve
.PP
2D median-convolution of an array with a kernel (smoothing)
.PP
Note: only points in the kernel >0 are included in the median, other
points are weighted by the kernel value (medianing lots of zeroes
is rather pointless)
.PP
.Vb 1
\& $new = med2d $old, $kernel, {OPTIONS}
.Ve
.PP
.Vb 1
\& $smoothed = med2d $image, ones(3,3), {Boundary => Reflect}
.Ve
.PP
.Vb 6
\& Boundary \- controls what values are assumed for the image when kernel
\&            crosses its edge:
\&            => Default   \- periodic boundary conditions (i.e. wrap around axis)
\&            => Reflect   \- reflect at boundary
\&            => Truncate  \- truncate at boundary
\&            => Replicate \- repeat boundary pixel values
.Ve
.PP
Bad values are ignored in the calculation. If all elements within the
kernel are bad, the output is set bad.
.SS "med2df"
.IX Subsection "med2df"
.Vb 1
\&  Signature: (a(m,n); [o]b(m,n); int _\|_p_size; int _\|_q_size; int opt)
.Ve
.PP
2D median-convolution of an array in a pxq window (smoothing)
.PP
Note: this routine does the median over all points in a rectangular
      window and is not quite as flexible as \f(CW\*(C`med2d\*(C'\fR in this regard
      but slightly faster instead
.PP
.Vb 1
\& $new = med2df $old, $xwidth, $ywidth, {OPTIONS}
.Ve
.PP
.Vb 1
\& $smoothed = med2df $image, 3, 3, {Boundary => Reflect}
.Ve
.PP
.Vb 6
\& Boundary \- controls what values are assumed for the image when kernel
\&            crosses its edge:
\&            => Default   \- periodic boundary conditions (i.e. wrap around axis)
\&            => Reflect   \- reflect at boundary
\&            => Truncate  \- truncate at boundary
\&            => Replicate \- repeat boundary pixel values
.Ve
.PP
med2df does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "box2d"
.IX Subsection "box2d"
.Vb 1
\&  Signature: (a(n,m); [o] b(n,m); int wx; int wy; int edgezero)
.Ve
.PP
fast 2D boxcar average
.PP
.Vb 1
\&  $smoothim = $im\->box2d($wx,$wy,$edgezero=1);
.Ve
.PP
The edgezero argument controls if edge is set to zero (edgezero=1)
or just keeps the original (unfiltered) values.
.PP
\&\f(CW\*(C`box2d\*(C'\fR should be updated to support similar edge options
as \f(CW\*(C`conv2d\*(C'\fR and \f(CW\*(C`med2d\*(C'\fR etc.
.PP
Boxcar averaging is a pretty crude way of filtering. For serious stuff
better filters are around (e.g., use \*(L"conv2d\*(R" with the appropriate
kernel). On the other hand it is fast and computational cost grows only
approximately linearly with window size.
.PP
box2d does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "patch2d"
.IX Subsection "patch2d"
.Vb 1
\&  Signature: (a(m,n); int bad(m,n); [o]b(m,n))
.Ve
.PP
patch bad pixels out of 2D images using a mask
.PP
.Vb 1
\& $patched = patch2d $data, $bad;
.Ve
.PP
\&\f(CW$bad\fR is a 2D mask array where 1=bad pixel 0=good pixel.
Pixels are replaced by the average of their non-bad neighbours;
if all neighbours are bad, the original data value is
copied across.
.PP
This routine does not handle bad values \- use \*(L"patchbad2d\*(R" instead
.SS "patchbad2d"
.IX Subsection "patchbad2d"
.Vb 1
\&  Signature: (a(m,n); [o]b(m,n))
.Ve
.PP
patch bad pixels out of 2D images containing bad values
.PP
.Vb 1
\& $patched = patchbad2d $data;
.Ve
.PP
Pixels are replaced by the average of their non-bad neighbours;
if all neighbours are bad, the output is set bad.
If the input ndarray contains \fIno\fR bad values, then a straight copy
is performed (see \*(L"patch2d\*(R").
.PP
patchbad2d handles bad values. The output ndarray \fImay\fR contain
bad values, depending on the pattern of bad values in the input ndarray.
.SS "max2d_ind"
.IX Subsection "max2d_ind"
.Vb 1
\&  Signature: (a(m,n); [o]val(); int [o]x(); int[o]y())
.Ve
.PP
Return value/position of maximum value in 2D image
.PP
Contributed by Tim Jeness
.PP
Bad values are excluded from the search. If all pixels
are bad then the output is set bad.
.SS "centroid2d"
.IX Subsection "centroid2d"
.Vb 1
\&  Signature: (im(m,n); x(); y(); box(); [o]xcen(); [o]ycen())
.Ve
.PP
Refine a list of object positions in 2D image by centroiding in a box
.PP
\&\f(CW$box\fR is the full-width of the box, i.e. the window
is \f(CW\*(C`+/\- $box/2\*(C'\fR.
.PP
Bad pixels are excluded from the centroid calculation. If all elements are
bad (or the pixel sum is 0 \- but why would you be centroiding
something with negatives in...) then the output values are set bad.
.SS "crop"
.IX Subsection "crop"
Return bounding box of given mask in an \f(CW\*(C`indx\*(C'\fR ndarray, so it can broadcast.
Use other operations (such as \*(L"isgood\*(R" in PDL::Bad, or
\&\*(L"eqvec\*(R" in PDL::Primitive with a colour vector) to create a mask suitable
for your application.
.PP
.Vb 1
\&  $x1x2y1y2 = crop($image);
.Ve
.SS "cc8compt"
.IX Subsection "cc8compt"
Connected 8\-component labeling of a binary image.
.PP
Connected 8\-component labeling of 0,1 image \- i.e. find separate
segmented objects and fill object pixels with object number.
8\-component labeling includes all neighboring pixels.
This is just a front-end to ccNcompt.  See also \*(L"cc4compt\*(R".
.PP
.Vb 1
\& $segmented = cc8compt( $image > $threshold );
.Ve
.SS "cc4compt"
.IX Subsection "cc4compt"
Connected 4\-component labeling of a binary image.
.PP
Connected 4\-component labeling of 0,1 image \- i.e. find separate
segmented objects and fill object pixels with object number.
4\-component labling does not include the diagonal neighbors.
This is just a front-end to ccNcompt.  See also \*(L"cc8compt\*(R".
.PP
.Vb 1
\& $segmented = cc4compt( $image > $threshold );
.Ve
.SS "ccNcompt"
.IX Subsection "ccNcompt"
.Vb 1
\&  Signature: (a(m,n); int+ [o]b(m,n); int con)
.Ve
.PP
Connected component labeling of a binary image.
.PP
Connected component labeling of 0,1 image \- i.e. find separate
segmented objects and fill object pixels with object number.
See also \*(L"cc4compt\*(R" and \*(L"cc8compt\*(R".
.PP
The connectivity parameter must be 4 or 8.
.PP
.Vb 1
\& $segmented = ccNcompt( $image > $threshold, 4);
\&
\& $segmented2 = ccNcompt( $image > $threshold, 8);
.Ve
.PP
where the second parameter specifies the connectivity (4 or 8) of the labeling.
.PP
ccNcompt ignores the bad-value flag of the input ndarrays.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "polyfill"
.IX Subsection "polyfill"
fill the area of the given polygon with the given colour.
.PP
This function works inplace, i.e. modifies \f(CW\*(C`im\*(C'\fR.
.PP
.Vb 1
\&  polyfill($im,$ps,$colour,[\e%options]);
.Ve
.PP
The default method of determining which points lie inside of the polygon used
is not as strict as the method used in \*(L"pnpoly\*(R". Often, it includes vertices
and edge points. Set the \f(CW\*(C`Method\*(C'\fR option to change this behaviour.
.PP
Method   \-  Set the method used to determine which points lie in the polygon.
            => Default \- internal \s-1PDL\s0 algorithm
            => pnpoly  \- use the \*(L"pnpoly\*(R" algorithm
.PP
.Vb 3
\&  # Make a convex 3x3 square of 1s in an image using the pnpoly algorithm
\&  $ps = pdl([3,3],[3,6],[6,6],[6,3]);
\&  polyfill($im,$ps,1,{\*(AqMethod\*(Aq =>\*(Aqpnpoly\*(Aq});
.Ve
.SS "pnpoly"
.IX Subsection "pnpoly"
\&'points in a polygon' selection from a 2\-D ndarray
.PP
.Vb 1
\&  $mask = $img\->pnpoly($ps);
\&
\&  # Old style, do not use
\&  $mask = pnpoly($x, $y, $px, $py);
.Ve
.PP
For a closed polygon determined by the sequence of points in {$px,$py}
the output of pnpoly is a mask corresponding to whether or not each
coordinate (x,y) in the set of test points, {$x,$y}, is in the interior
of the polygon.  This is the 'points in a polygon' algorithm from
<http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html>
and vectorized for \s-1PDL\s0 by Karl Glazebrook.
.PP
.Vb 2
\&  # define a 3\-sided polygon (a triangle)
\&  $ps = pdl([3, 3], [20, 20], [34, 3]);
\&
\&  # $tri is 0 everywhere except for points in polygon interior
\&  $tri = $img\->pnpoly($ps);
\&
\&  With the second form, the x and y coordinates must also be specified.
\&  B< I<THIS IS MAINTAINED FOR BACKWARD COMPATIBILITY ONLY> >.
\&
\&  $px = pdl( 3, 20, 34 );
\&  $py = pdl( 3, 20,  3 );
\&  $x = $img\->xvals;      # get x pixel coords
\&  $y = $img\->yvals;      # get y pixel coords
\&
\&  # $tri is 0 everywhere except for points in polygon interior
\&  $tri = pnpoly($x,$y,$px,$py);
.Ve
.SS "polyfillv"
.IX Subsection "polyfillv"
return the (dataflowed) area of an image described by a polygon
.PP
.Vb 1
\&  polyfillv($im,$ps,[\e%options]);
.Ve
.PP
The default method of determining which points lie inside of the polygon used
is not as strict as the method used in \*(L"pnpoly\*(R". Often, it includes vertices
and edge points. Set the \f(CW\*(C`Method\*(C'\fR option to change this behaviour.
.PP
Method   \-  Set the method used to determine which points lie in the polygon.
            => Default \- internal \s-1PDL\s0 algorithm
            => pnpoly  \- use the \*(L"pnpoly\*(R" algorithm
.PP
.Vb 2
\&  # increment intensity in area bounded by $poly using the pnpoly algorithm
\&  $im\->polyfillv($poly,{\*(AqMethod\*(Aq=>\*(Aqpnpoly\*(Aq})++; # legal in perl >= 5.6
\&
\&  # compute average intensity within area bounded by $poly using the default algorithm
\&  $av = $im\->polyfillv($poly)\->avg;
.Ve
.SS "rot2d"
.IX Subsection "rot2d"
.Vb 1
\&  Signature: (im(m,n); float angle(); bg(); int aa(); [o] om(p,q))
.Ve
.PP
rotate an image by given \f(CW\*(C`angle\*(C'\fR
.PP
.Vb 2
\&  # rotate by 10.5 degrees with antialiasing, set missing values to 7
\&  $rot = $im\->rot2d(10.5,7,1);
.Ve
.PP
This function rotates an image through an \f(CW\*(C`angle\*(C'\fR between \-90 and + 90
degrees. Uses/doesn't use antialiasing depending on the \f(CW\*(C`aa\*(C'\fR flag.
Pixels outside the rotated image are set to \f(CW\*(C`bg\*(C'\fR.
.PP
Code modified from pnmrotate (Copyright Jef Poskanzer) with an algorithm based
on \*(L"A Fast Algorithm for General  Raster  Rotation\*(R"  by  Alan Paeth,
Graphics Interface '86, pp. 77\-81.
.PP
Use the \f(CW\*(C`rotnewsz\*(C'\fR function to find out about the dimension of the
newly created image
.PP
.Vb 1
\&  ($newcols,$newrows) = rotnewsz $oldn, $oldm, $angle;
.Ve
.PP
PDL::Transform offers a more general interface to
distortions, including rotation, with various types of sampling; but
rot2d is faster.
.PP
rot2d ignores the bad-value flag of the input ndarrays.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bilin2d"
.IX Subsection "bilin2d"
.Vb 1
\&  Signature: (Int(n,m); O(q,p))
.Ve
.PP
Bilinearly maps the first ndarray in the second. The
interpolated values are actually added to the second
ndarray which is supposed to be larger than the first one.
.PP
bilin2d ignores the bad-value flag of the input ndarrays.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rescale2d"
.IX Subsection "rescale2d"
.Vb 1
\&  Signature: (Int(m,n); O(p,q))
.Ve
.PP
The first ndarray is rescaled to the dimensions of the second
(expanding or meaning values as needed) and then added to it in place.
Nothing useful is returned.
.PP
If you want photometric accuracy or automatic \s-1FITS\s0 header metadata
tracking, consider using PDL::Transform::map
instead: it does these things, at some speed penalty compared to
rescale2d.
.PP
rescale2d ignores the bad-value flag of the input ndarrays.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "fitwarp2d"
.IX Subsection "fitwarp2d"
Find the best-fit 2D polynomial to describe
a coordinate transformation.
.PP
.Vb 1
\&  ( $px, $py ) = fitwarp2d( $x, $y, $u, $v, $nf, { options } )
.Ve
.PP
Given a set of points in the output plane (\f(CW\*(C`$u,$v\*(C'\fR), find
the best-fit (using singular-value decomposition) 2D polynomial
to describe the mapping back to the image plane (\f(CW\*(C`$x,$y\*(C'\fR).
The order of the fit is controlled by the \f(CW$nf\fR parameter
(the maximum power of the polynomial is \f(CW\*(C`$nf \- 1\*(C'\fR), and you
can restrict the terms to fit using the \f(CW\*(C`FIT\*(C'\fR option.
.PP
\&\f(CW$px\fR and \f(CW$py\fR are \f(CW\*(C`np\*(C'\fR by \f(CW\*(C`np\*(C'\fR element ndarrays which describe
a polynomial mapping (of order \f(CW\*(C`np\-1\*(C'\fR)
from the \fIoutput\fR \f(CW\*(C`(u,v)\*(C'\fR image to the \fIinput\fR \f(CW\*(C`(x,y)\*(C'\fR image:
.PP
.Vb 2
\&  x = sum(j=0,np\-1) sum(i=0,np\-1) px(i,j) * u^i * v^j
\&  y = sum(j=0,np\-1) sum(i=0,np\-1) py(i,j) * u^i * v^j
.Ve
.PP
The transformation is returned for the reverse direction (ie
output to input image) since that is what is required by the
\&\fBwarp2d()\fR routine.  The \fBapplywarp2d()\fR
routine can be used to convert a set of \f(CW\*(C`$u,$v\*(C'\fR points given
\&\f(CW$px\fR and \f(CW$py\fR.
.PP
Options:
.PP
.Vb 1
\&  FIT     \- which terms to fit? default ones(byte,$nf,$nf)
.Ve
.IP "\s-1FIT\s0" 4
.IX Item "FIT"
\&\f(CW\*(C`FIT\*(C'\fR allows you to restrict which terms of the polynomial to fit:
only those terms for which the \s-1FIT\s0 ndarray evaluates to true will be
evaluated.  If a 2D ndarray is sent in, then it is
used for the x and y polynomials; otherwise
\&\f(CW\*(C`$fit\->slice(":,:,(0)")\*(C'\fR will be used for \f(CW$px\fR and
\&\f(CW\*(C`$fit\->slice(":,:,(1)")\*(C'\fR will be used for \f(CW$py\fR.
.PP
The number of points must be at least equal to the number of
terms to fit (\f(CW\*(C`$nf*$nf\*(C'\fR points for the default value of \f(CW\*(C`FIT\*(C'\fR).
.PP
.Vb 10
\&  # points in original image
\&  $x = pdl( 0,   0, 100, 100 );
\&  $y = pdl( 0, 100, 100,   0 );
\&  # get warped to these positions
\&  $u = pdl( 10, 10, 90, 90 );
\&  $v = pdl( 10, 90, 90, 10 );
\&  #
\&  # shift of origin + scale x/y axis only
\&  $fit = byte( [ [1,1], [0,0] ], [ [1,0], [1,0] ] );
\&  ( $px, $py ) = fitwarp2d( $x, $y, $u, $v, 2, { FIT => $fit } );
\&  print "px = ${px}py = $py";
\&  px =
\&  [
\&   [\-12.5  1.25]
\&   [    0     0]
\&  ]
\&  py =
\&  [
\&   [\-12.5     0]
\&   [ 1.25     0]
\&  ]
\&  #
\&  # Compared to allowing all 4 terms
\&  ( $px, $py ) = fitwarp2d( $x, $y, $u, $v, 2 );
\&  print "px = ${px}py = $py";
\&  px =
\&  [
\&   [         \-12.5           1.25]
\&   [  1.110223e\-16 \-1.1275703e\-17]
\&  ]
\&  py =
\&  [
\&   [         \-12.5  1.6653345e\-16]
\&   [          1.25 \-5.8546917e\-18]
\&  ]
\&
\&  # A higher\-degree polynomial should not affect the answer much, but
\&  # will require more control points
\&
\&  $x = $x\->glue(0,pdl(50,12.5, 37.5, 12.5, 37.5));
\&  $y = $y\->glue(0,pdl(50,12.5, 37.5, 37.5, 12.5));
\&  $u = $u\->glue(0,pdl(73,20,40,20,40));
\&  $v = $v\->glue(0,pdl(29,20,40,40,20));
\&  ( $px3, $py3 ) = fitwarp2d( $x, $y, $u, $v, 3 );
\&  print "px3 =${px3}py3 =$py3";
\&  px3 =
\&  [
\&   [\-6.4981162e+08       71034917     \-726498.95]
\&   [      49902244     \-5415096.7      55945.388]
\&   [    \-807778.46      88457.191     \-902.51612]
\&  ]
\&  py3 =
\&  [
\&   [\-6.2732159e+08       68576392     \-701354.77]
\&   [      48175125     \-5227679.8      54009.114]
\&   [    \-779821.18      85395.681     \-871.27997]
\&  ]
\&
\&  #This illustrates an important point about singular value
\&  #decompositions that are used in fitwarp2d: like all SVDs, the
\&  #rotation matrices are not unique, and so the $px and $py returned
\&  #by fitwarp2d are not guaranteed to be the "simplest" solution.
\&  #They do still work, though:
\&
\&  ($x3,$y3) = applywarp2d($px3,$py3,$u,$v);
\&  print approx $x3,$x,1e\-4;
\&  [1 1 1 1 1 1 1 1 1]
\&  print approx $y3,$y;
\&  [1 1 1 1 1 1 1 1 1]
.Ve
.SS "applywarp2d"
.IX Subsection "applywarp2d"
Transform a set of points using a 2\-D polynomial mapping
.PP
.Vb 1
\&  ( $x, $y ) = applywarp2d( $px, $py, $u, $v )
.Ve
.PP
Convert a set of points (stored in 1D ndarrays \f(CW\*(C`$u,$v\*(C'\fR)
to \f(CW\*(C`$x,$y\*(C'\fR using the 2\-D polynomial with coefficients stored in \f(CW$px\fR
and \f(CW$py\fR.  See \fBfitwarp2d()\fR
for more information on the format of \f(CW$px\fR and \f(CW$py\fR.
.SS "warp2d"
.IX Subsection "warp2d"
.Vb 1
\&  Signature: (img(m,n); double px(np,np); double py(np,np); [o] warp(m,n); { options })
.Ve
.PP
Warp a 2D image given a polynomial describing the \fIreverse\fR mapping.
.PP
.Vb 1
\&  $out = warp2d( $img, $px, $py, { options } );
.Ve
.PP
Apply the polynomial transformation encoded in the \f(CW$px\fR and
\&\f(CW$py\fR ndarrays to warp the input image \f(CW$img\fR into the output
image \f(CW$out\fR.
.PP
The format for the polynomial transformation is described in
the documentation for the \fBfitwarp2d()\fR routine.
.PP
At each point \f(CW\*(C`x,y\*(C'\fR, the closest 16 pixel values are combined
with an interpolation kernel to calculate the value at \f(CW\*(C`u,v\*(C'\fR.
The interpolation is therefore done in the image, rather than
Fourier, domain.
By default, a \f(CW\*(C`tanh\*(C'\fR kernel is used, but this can be changed
using the \f(CW\*(C`KERNEL\*(C'\fR option discussed below
(the choice of kernel depends on the frequency content of the input image).
.PP
The routine is based on the \f(CW\*(C`warping\*(C'\fR command from
the Eclipse data-reduction package \- see http://www.eso.org/eclipse/ \- and
for further details on image resampling see
Wolberg, G., \*(L"Digital Image Warping\*(R", 1990, \s-1IEEE\s0 Computer
Society Press \s-1ISBN 0\-8186\-8944\-7\s0).
.PP
Currently the output image is the same size as the input one,
which means data will be lost if the transformation reduces
the pixel scale.  This will (hopefully) be changed soon.
.PP
.Vb 10
\&  $img = rvals(byte,501,501);
\&  imag $img, { JUSTIFY => 1 };
\&  #
\&  # use a not\-particularly\-obvious transformation:
\&  #   x = \-10 + 0.5 * $u \- 0.1 * $v
\&  #   y = \-20 + $v \- 0.002 * $u * $v
\&  #
\&  $px  = pdl( [ \-10, 0.5 ], [ \-0.1, 0 ] );
\&  $py  = pdl( [ \-20, 0 ], [ 1, 0.002 ] );
\&  $wrp = warp2d( $img, $px, $py );
\&  #
\&  # see the warped image
\&  imag $warp, { JUSTIFY => 1 };
.Ve
.PP
The options are:
.PP
.Vb 2
\&  KERNEL \- default value is tanh
\&  NOVAL  \- default value is 0
.Ve
.PP
\&\f(CW\*(C`KERNEL\*(C'\fR is used to specify which interpolation kernel to use
(to see what these kernels look like, use the
\&\fBwarp2d_kernel()\fR routine).
The options are:
.IP "tanh" 4
.IX Item "tanh"
Hyperbolic tangent: the approximation of an ideal box filter by the
product of symmetric tanh functions.
.IP "sinc" 4
.IX Item "sinc"
For a correctly sampled signal, the ideal filter in the fourier domain is a rectangle,
which produces a \f(CW\*(C`sinc\*(C'\fR interpolation kernel in the spatial domain:
.Sp
.Vb 1
\&  sinc(x) = sin(pi * x) / (pi * x)
.Ve
.Sp
However, it is not ideal for the \f(CW\*(C`4x4\*(C'\fR pixel region used here.
.IP "sinc2" 4
.IX Item "sinc2"
This is the square of the sinc function.
.IP "lanczos" 4
.IX Item "lanczos"
Although defined differently to the \f(CW\*(C`tanh\*(C'\fR kernel, the result is very
similar in the spatial domain.  The Lanczos function is defined as
.Sp
.Vb 2
\&  L(x) = sinc(x) * sinc(x/2)  if abs(x) < 2
\&       = 0                       otherwise
.Ve
.IP "hann" 4
.IX Item "hann"
This kernel is derived from the following function:
.Sp
.Vb 2
\&  H(x) = a + (1\-a) * cos(2*pi*x/(N\-1))  if abs(x) < 0.5*(N\-1)
\&       = 0                                 otherwise
.Ve
.Sp
with \f(CW\*(C`a = 0.5\*(C'\fR and N currently equal to 2001.
.IP "hamming" 4
.IX Item "hamming"
This kernel uses the same \f(CWH(x)\fR as the Hann filter, but with
\&\f(CW\*(C`a = 0.54\*(C'\fR.
.PP
\&\f(CW\*(C`NOVAL\*(C'\fR gives the value used to indicate that a pixel in the
output image does not map onto one in the input image.
.SS "warp2d_kernel"
.IX Subsection "warp2d_kernel"
Return the specified kernel, as used by \*(L"warp2d\*(R"
.PP
.Vb 1
\&  ( $x, $k ) = warp2d_kernel( $name )
.Ve
.PP
The valid values for \f(CW$name\fR are the same as the \f(CW\*(C`KERNEL\*(C'\fR option
of \fBwarp2d()\fR.
.PP
.Vb 1
\&  line warp2d_kernel( "hamming" );
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Copyright (C) Karl Glazebrook 1997 with additions by Robin Williams
(rjrw@ast.leeds.ac.uk), Tim Jeness (timj@jach.hawaii.edu),
and Doug Burke (burke@ifa.hawaii.edu).
.PP
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution,
the copyright notice should be included in the file.
