.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Complex 3"
.TH Complex 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Complex \- handle complex numbers (DEPRECATED \- use native complex)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use PDL;
\&  use PDL::Complex;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is deprecated in favour of using \*(L"native complex\*(R" data types, e.g.:
.PP
.Vb 3
\&  use PDL;
\&  my $complex_pdl = cdouble(\*(Aq[1+3i]\*(Aq);
\&  print $complex_pdl * pdl(\*(Aqi\*(Aq); # [\-3+i]
.Ve
.PP
This module features a growing number of functions manipulating complex
numbers. These are usually represented as a pair \f(CW\*(C`[ real imag ]\*(C'\fR or
\&\f(CW\*(C`[ magnitude phase ]\*(C'\fR. If not explicitly mentioned, the functions can work
inplace (not yet implemented!!!) and require rectangular form.
.PP
While there is a procedural interface available (\f(CW\*(C`$x/$y*$c <=> Cmul
(Cdiv ($x, $y), $c)\*(C'\fR), you can also opt to cast your pdl's into the
\&\f(CW\*(C`PDL::Complex\*(C'\fR datatype, which works just like your normal ndarrays, but
with all the normal perl operators overloaded.
.PP
The latter means that \f(CW\*(C`sin($x) + $y/$c\*(C'\fR will be evaluated using the
normal rules of complex numbers, while other pdl functions (like \f(CW\*(C`max\*(C'\fR)
just treat the ndarray as a real-valued ndarray with a lowest dimension of
size 2, so \f(CW\*(C`max\*(C'\fR will return the maximum of all real and imaginary parts,
not the \*(L"highest\*(R" (for some definition)
.SS "Native complex support"
.IX Subsection "Native complex support"
2.027 added changes in complex number handling, with support for C99
complex floating-point types, and most functions and modules in the core
distribution support these as well.
.PP
\&\s-1PDL\s0 can now handle complex numbers natively as scalars. This has
the advantage that real and complex valued ndarrays have the same
dimensions. Consider this when writing code in the future.
.PP
See \*(L"re\*(R" in PDL::Ops, \*(L"im\*(R" in PDL::Ops, \*(L"abs\*(R" in PDL::Ops, \*(L"carg\*(R" in PDL::Ops,
\&\*(L"conj\*(R" in PDL::Ops for more.
.SH "TIPS, TRICKS & CAVEATS"
.IX Header "TIPS, TRICKS & CAVEATS"
.IP "\(bu" 4
\&\f(CW\*(C`i\*(C'\fR is a function (not, as of 2.047, a constant) exported by this module,
which represents \f(CW\*(C`\-1**0.5\*(C'\fR, i.e. the imaginary unit. it can be used to
quickly and conveniently write complex constants like this: \f(CW\*(C`4+3*i\*(C'\fR.
.Sp
\&\fB\s-1NB\s0\fR This will override the PDL::Core function of the same name, which
returns a native complex value.
.IP "\(bu" 4
Use \f(CW\*(C`r2C(real\-values)\*(C'\fR to convert from real to complex, as in \f(CW\*(C`$r
= Cpow $cplx, r2C 2\*(C'\fR. The overloaded operators automatically do that for
you, all the other functions, do not. So \f(CW\*(C`Croots 1, 5\*(C'\fR will return all
the fifths roots of 1+1*i (due to broadcasting).
.IP "\(bu" 4
use \f(CW\*(C`cplx(real\-valued\-ndarray)\*(C'\fR to cast from normal ndarrays into the
complex datatype. Use \f(CW\*(C`real(complex\-valued\-ndarray)\*(C'\fR to cast back. This
requires a copy, though.
.SH "EXAMPLE WALK-THROUGH"
.IX Header "EXAMPLE WALK-THROUGH"
The complex constant five is equal to \f(CW\*(C`pdl(1,0)\*(C'\fR:
.PP
.Vb 2
\&   pdl> p $x = r2C 5
\&   5 +0i
.Ve
.PP
Now calculate the three cubic roots of five:
.PP
.Vb 2
\&   pdl> p $r = Croots $x, 3
\&   [1.70998 +0i  \-0.854988 +1.48088i  \-0.854988 \-1.48088i]
.Ve
.PP
Check that these really are the roots:
.PP
.Vb 2
\&   pdl> p $r ** 3
\&   [5 +0i  5 \-1.22465e\-15i  5 \-7.65714e\-15i]
.Ve
.PP
Duh! Could be better. Now try by multiplying \f(CW$r\fR three times with itself:
.PP
.Vb 2
\&   pdl> p $r*$r*$r
\&   [5 +0i  5 \-4.72647e\-15i  5 \-7.53694e\-15i]
.Ve
.PP
Well... maybe \f(CW\*(C`Cpow\*(C'\fR (which is used by the \f(CW\*(C`**\*(C'\fR operator) isn't as
bad as I thought. Now multiply by \f(CW\*(C`i\*(C'\fR and negate, then take the complex
conjugate, which is just a very expensive way of swapping real and
imaginary parts.
.PP
.Vb 2
\&   pdl> p Cconj(\-($r*i))
\&   [0 +1.70998i  1.48088 \-0.854988i  \-1.48088 \-0.854988i]
.Ve
.PP
Now plot the magnitude of (part of) the complex sine. First generate the
coefficients:
.PP
.Vb 1
\&   pdl> $sin = i * zeroes(50)\->xlinvals(2,4) + zeroes(50)\->xlinvals(0,7)
.Ve
.PP
Now plot the imaginary part, the real part and the magnitude of the sine
into the same diagram:
.PP
.Vb 5
\&   pdl> use PDL::Graphics::Gnuplot
\&   pdl> gplot( with => \*(Aqlines\*(Aq,
\&              PDL::cat(im ( sin $sin ),
\&                       re ( sin $sin ),
\&                       abs( sin $sin ) ))
.Ve
.PP
An \s-1ASCII\s0 version of this plot looks like this:
.PP
.Vb 10
\&  30 ++\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-++
\&     +      +      +      +      +      +      +      +      +      +      +
\&     |                                                                   $$|
\&     |                                                                  $  |
\&  25 ++                                                               $$  ++
\&     |                                                              ***    |
\&     |                                                            **   *** |
\&     |                                                         $$*        *|
\&  20 ++                                                       $**         ++
\&     |                                                     $$$*           #|
\&     |                                                  $$$   *          # |
\&     |                                                $$     *           # |
\&  15 ++                                            $$$       *          # ++
\&     |                                          $$$        **           #  |
\&     |                                      $$$$          *            #   |
\&     |                                  $$$$              *            #   |
\&  10 ++                            $$$$$                 *            #   ++
\&     |                        $$$$$                     *             #    |
\&     |                 $$$$$$$                         *             #     |
\&   5 ++       $$$############                          *             #    ++
\&     |*****$$$###            ###                      *             #      |
\&     *    #*****                #                     *             #      |
\&     | ###      ***              ###                **              #      |
\&   0 ##            ***              #              *               #      ++
\&     |                *              #             *              #        |
\&     |                 ***            #          **               #        |
\&     |                    *            #        *                #         |
\&  \-5 ++                    **           #      *                 #        ++
\&     |                       ***         ##  **                 #          |
\&     |                          *          #*                  #           |
\&     |                           ****    ***##                #            |
\& \-10 ++                              ****     #              #            ++
\&     |                                         #             #             |
\&     |                                          ##         ##              |
\&     +      +      +      +      +      +      +  ### + ###  +      +      +
\& \-15 ++\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-###\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-++
\&     0      5      10     15     20     25     30     35     40     45     50
.Ve
.SH "OPERATORS"
.IX Header "OPERATORS"
The following operators are overloaded:
.IP "+, += (addition)" 4
.IX Item "+, += (addition)"
.PD 0
.IP "\-, \-= (subtraction)" 4
.IX Item "-, -= (subtraction)"
.ie n .IP "*, *= (multiplication; ""Cmul"")" 4
.el .IP "*, *= (multiplication; ``Cmul'')" 4
.IX Item "*, *= (multiplication; Cmul)"
.ie n .IP "/, /= (division; ""Cdiv"")" 4
.el .IP "/, /= (division; ``Cdiv'')" 4
.IX Item "/, /= (division; Cdiv)"
.ie n .IP "**, **= (exponentiation; ""Cpow"")" 4
.el .IP "**, **= (exponentiation; ``Cpow'')" 4
.IX Item "**, **= (exponentiation; Cpow)"
.IP "atan2 (4\-quadrant arc tangent)" 4
.IX Item "atan2 (4-quadrant arc tangent)"
.ie n .IP "sin (""Csin"")" 4
.el .IP "sin (``Csin'')" 4
.IX Item "sin (Csin)"
.ie n .IP "cos (""Ccos"")" 4
.el .IP "cos (``Ccos'')" 4
.IX Item "cos (Ccos)"
.ie n .IP "exp (""Cexp"")" 4
.el .IP "exp (``Cexp'')" 4
.IX Item "exp (Cexp)"
.ie n .IP "abs (""Cabs"")" 4
.el .IP "abs (``Cabs'')" 4
.IX Item "abs (Cabs)"
.ie n .IP "log (""Clog"")" 4
.el .IP "log (``Clog'')" 4
.IX Item "log (Clog)"
.ie n .IP "sqrt (""Csqrt"")" 4
.el .IP "sqrt (``Csqrt'')" 4
.IX Item "sqrt (Csqrt)"
.IP "++, \*(-- (increment, decrement; they affect the real part of the complex number only)" 4
.IX Item "++, (increment, decrement; they affect the real part of the complex number only)"
.ie n .IP """"" (stringification)" 4
.el .IP "``'' (stringification)" 4
.IX Item """"" (stringification)"
.PD
.PP
Comparing complex numbers other than for equality is a fatal error.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "from_native"
.IX Subsection "from_native"
Class method to convert a native-complex ndarray to a PDL::Complex object.
.PP
.Vb 1
\& PDL::Complex\->from_native($native_complex_ndarray)
.Ve
.SS "as_native"
.IX Subsection "as_native"
Object method to convert a PDL::Complex object to a native-complex ndarray.
.PP
.Vb 1
\& $pdl_complex_obj\->as_native
.Ve
.SS "cplx"
.IX Subsection "cplx"
Cast a real-valued ndarray to the complex datatype.
.PP
The first dimension of the ndarray must be of size 2. After this the
usual (complex) arithmetic operators are applied to this pdl, rather
than the normal elementwise pdl operators.  Dataflow to the complex
parent works. Use \f(CW\*(C`sever\*(C'\fR on the result if you don't want this.
.PP
.Vb 1
\& cplx($real_valued_pdl)
.Ve
.SS "complex"
.IX Subsection "complex"
Cast a real-valued ndarray to the complex datatype \fIwithout\fR dataflow
and \fIinplace\fR.
.PP
Achieved by merely reblessing an ndarray. The first dimension of the
ndarray must be of size 2.
.PP
.Vb 1
\& complex($real_valued_pdl)
.Ve
.SS "real"
.IX Subsection "real"
Cast a complex valued pdl back to the \*(L"normal\*(R" pdl datatype.
.PP
Afterwards the normal elementwise pdl operators are used in
operations. Dataflow to the real parent works. Use \f(CW\*(C`sever\*(C'\fR on the
result if you don't want this.
.PP
.Vb 1
\& real($cplx_valued_pdl)
.Ve
.SS "r2C"
.IX Subsection "r2C"
.Vb 1
\&  Signature: (r(); [o]c(m=2))
.Ve
.PP
convert real to complex, assuming an imaginary part of zero
.PP
r2C does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "i2C"
.IX Subsection "i2C"
.Vb 1
\&  Signature: (r(); [o]c(m=2))
.Ve
.PP
convert imaginary to complex, assuming a real part of zero
.PP
i2C does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cr2p"
.IX Subsection "Cr2p"
.Vb 1
\&  Signature: (r(m=2); float+ [o]p(m=2))
.Ve
.PP
convert complex numbers in rectangular form to polar (mod,arg) form. Works inplace
.PP
Cr2p does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cp2r"
.IX Subsection "Cp2r"
.Vb 1
\&  Signature: (r(m=2); [o]p(m=2))
.Ve
.PP
convert complex numbers in polar (mod,arg) form to rectangular form. Works inplace
.PP
Cp2r does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cmul"
.IX Subsection "Cmul"
.Vb 1
\&  Signature: (a(m=2); b(m=2); [o]c(m=2))
.Ve
.PP
complex multiplication
.PP
Cmul does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cprodover"
.IX Subsection "Cprodover"
.Vb 1
\&  Signature: (a(m=2,n); [o]c(m=2))
.Ve
.PP
Project via product to N\-1 dimension
.PP
Cprodover does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cscale"
.IX Subsection "Cscale"
.Vb 1
\&  Signature: (a(m=2); b(); [o]c(m=2))
.Ve
.PP
mixed complex/real multiplication
.PP
Cscale does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cdiv"
.IX Subsection "Cdiv"
.Vb 1
\&  Signature: (a(m=2); b(m=2); [o]c(m=2))
.Ve
.PP
complex division
.PP
Cdiv does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Ceq"
.IX Subsection "Ceq"
.Vb 1
\&  Signature: (a(m=2); b(m=2); [o]c())
.Ve
.PP
Complex equality operator.
.PP
Ceq does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cconj"
.IX Subsection "Cconj"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
complex conjugation. Works inplace
.PP
Cconj does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cabs"
.IX Subsection "Cabs"
.Vb 1
\&  Signature: (a(m=2); [o]c())
.Ve
.PP
complex \f(CW\*(C`abs()\*(C'\fR (also known as \fImodulus\fR)
.PP
Cabs does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cabs2"
.IX Subsection "Cabs2"
.Vb 1
\&  Signature: (a(m=2); [o]c())
.Ve
.PP
complex squared \f(CW\*(C`abs()\*(C'\fR (also known \fIsquared modulus\fR)
.PP
Cabs2 does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Carg"
.IX Subsection "Carg"
.Vb 1
\&  Signature: (a(m=2); [o]c())
.Ve
.PP
complex argument function (\*(L"angle\*(R")
.PP
Carg does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Csin"
.IX Subsection "Csin"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
.Vb 1
\&  sin (a) = 1/(2*i) * (exp (a*i) \- exp (\-a*i)). Works inplace
.Ve
.PP
Csin does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Ccos"
.IX Subsection "Ccos"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
.Vb 1
\&  cos (a) = 1/2 * (exp (a*i) + exp (\-a*i)). Works inplace
.Ve
.PP
Ccos does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Ctan"
.IX Subsection "Ctan"
Complex tangent
.PP
.Vb 1
\&  tan (a) = \-i * (exp (a*i) \- exp (\-a*i)) / (exp (a*i) + exp (\-a*i))
.Ve
.PP
Does not work inplace.
.SS "Cexp"
.IX Subsection "Cexp"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
.Vb 1
\&  exp (a) = exp (real (a)) * (cos (imag (a)) + i * sin (imag (a))). Works inplace
.Ve
.PP
Cexp does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Clog"
.IX Subsection "Clog"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
.Vb 1
\&  log (a) = log (cabs (a)) + i * carg (a). Works inplace
.Ve
.PP
Clog does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cpow"
.IX Subsection "Cpow"
.Vb 1
\&  Signature: (a(m=2); b(m=2); [o]c(m=2))
.Ve
.PP
complex \f(CW\*(C`pow()\*(C'\fR (\f(CW\*(C`**\*(C'\fR\-operator)
.PP
Cpow does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Csqrt"
.IX Subsection "Csqrt"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
Works inplace
.PP
Csqrt does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Casin"
.IX Subsection "Casin"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
Works inplace
.PP
Casin does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cacos"
.IX Subsection "Cacos"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
Works inplace
.PP
Cacos does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Catan"
.IX Subsection "Catan"
Return the complex \f(CW\*(C`atan()\*(C'\fR.
.PP
Does not work inplace.
.SS "Csinh"
.IX Subsection "Csinh"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
.Vb 1
\&  sinh (a) = (exp (a) \- exp (\-a)) / 2. Works inplace
.Ve
.PP
Csinh does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Ccosh"
.IX Subsection "Ccosh"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
.Vb 1
\&  cosh (a) = (exp (a) + exp (\-a)) / 2. Works inplace
.Ve
.PP
Ccosh does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Ctanh"
.IX Subsection "Ctanh"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
Works inplace
.PP
Ctanh does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Casinh"
.IX Subsection "Casinh"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
Works inplace
.PP
Casinh does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cacosh"
.IX Subsection "Cacosh"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
Works inplace
.PP
Cacosh does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Catanh"
.IX Subsection "Catanh"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
Works inplace
.PP
Catanh does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Cproj"
.IX Subsection "Cproj"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2))
.Ve
.PP
compute the projection of a complex number to the riemann sphere. Works inplace
.PP
Cproj does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "Croots"
.IX Subsection "Croots"
.Vb 1
\&  Signature: (a(m=2); [o]c(m=2,n); int n => n)
.Ve
.PP
Compute the \f(CW\*(C`n\*(C'\fR roots of \f(CW\*(C`a\*(C'\fR. \f(CW\*(C`n\*(C'\fR must be a positive integer. The result will always be a complex type!
.PP
Croots does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "re, im"
.IX Subsection "re, im"
Return the real or imaginary part of the complex number(s) given.
.PP
These are slicing operators, so data flow works. The real and
imaginary parts are returned as ndarrays (ref eq \s-1PDL\s0).
.SS "rCpolynomial"
.IX Subsection "rCpolynomial"
.Vb 1
\&  Signature: (coeffs(n); x(c=2,m); [o]out(c=2,m))
.Ve
.PP
evaluate the polynomial with (real) coefficients \f(CW\*(C`coeffs\*(C'\fR at the (complex) position(s) \f(CW\*(C`x\*(C'\fR. \f(CW\*(C`coeffs[0]\*(C'\fR is the constant term.
.PP
rCpolynomial does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2000 Marc Lehmann <pcg@goof.com>.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation as described
in the file \s-1COPYING\s0 in the \s-1PDL\s0 distribution.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperl\fR\|(1), \s-1PDL\s0.
