.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "FlexRaw 3"
.TH FlexRaw 3 "2022-02-27" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::IO::FlexRaw \-\- A flexible binary I/O format for PerlDL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use PDL;
\&    use PDL::IO::FlexRaw;
\&
\&    # To obtain the header for reading (if multiple files use the
\&    # same header, for example):
\&    #
\&    $hdr = PDL::IO::FlexRaw::_read_flexhdr("filename.hdr")
\&
\&    ($x,$y,...) = readflex("filename" [, $hdr])
\&    ($x,$y,...) = mapflex("filename" [, $hdr] [, $opts])
\&
\&    $hdr = writeflex($file, $pdl1, $pdl2,...)
\&    writeflexhdr($file, $hdr)
\&
\&    # if $PDL::IO::FlexRaw::writeflexhdr is true and
\&    #    $file is a filename, writeflexhdr() is called automatically
\&    #
\&    $hdr = writeflex($file, $pdl1, $pdl2,...)  # need $hdr for something
\&    writeflex($file, $pdl1, $pdl2,...)         # ..if $hdr not needed
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
FlexRaw is a generic method for the input and output of `raw' data
arrays.  In particular, it is designed to read output from \s-1FORTRAN 77
UNFORMATTED\s0 files and the low-level C write function, even if the
files are compressed or gzipped.  As in FastRaw, the data file is
supplemented by a header file (although this can be replaced by the
optional \f(CW$hdr\fR argument).  More information can be included in the
header file than for FastRaw \*(-- the description can be extended to
several data objects within a single input file.
.PP
For example, to read the output of a \s-1FORTRAN\s0 program
.PP
.Vb 4
\&    real*4 a(4,600,600)
\&    open (8,file=\*(Aqbanana\*(Aq,status=\*(Aqnew\*(Aq,form=\*(Aqunformatted\*(Aq)
\&    write (8) a
\&    close (8)
.Ve
.PP
the header file (`banana.hdr') could look like
.PP
.Vb 7
\&    # FlexRaw file header
\&    # Header word for F77 form=unformatted
\&    Byte 1 4
\&    # Data
\&    Float 3            # this is ignored
\&             4 600 600
\&    Byte 1 4           As is this, as we\*(Aqve got all dims
.Ve
.PP
The data can then be input using
.PP
.Vb 1
\&    $x = (readflex(\*(Aqbanana\*(Aq))[1];
.Ve
.PP
The format of the hdr file is an extension of that used by FastRaw.
Comment lines (starting with #) are allowed, as are descriptive names
(as elsewhere: byte, short, ushort, long, float, double) for the data
types \*(-- note that case is ignored by FlexRaw.  After the type, one
integer specifies the number of dimensions of the data `chunk', and
subsequent integers the size of each dimension.  So the specifier
above (`Float 3 4 600 600') describes our \s-1FORTRAN\s0 array.  A scalar can
be described as `float 0' (or `float 1 1', or `float 2 1 1', etc.).
.PP
When all the dimensions are read \*(-- or a # appears after whitespace \*(--
the rest of the current input line is ignored, \fIunless\fR badvalues
are being read or written.  In that case, the next token will be the
string \f(CW\*(C`badvalue\*(C'\fR followed by the bad value used, if needed.
.PP
What about the extra 4 bytes at the head and tail, which we just threw
away?  These are added by \s-1FORTRAN\s0 (at least on Suns, Alphas and
Linux), and specify the number of bytes written by each \s-1WRITE\s0 \*(-- the
same number is put at the start and the end of each chunk of data.
You \fImay\fR need to know all this in some cases.  In general, FlexRaw
tries to handle it itself, if you simply add a line saying `f77' to
the header file, \fIbefore\fR any data specifiers:
.PP
.Vb 5
\&    # FlexRaw file header for F77 form=unformatted
\&    F77
\&    # Data
\&    Float 3
\&    4 600 600
.Ve
.PP
\&\-\- the redundancy in \s-1FORTRAN\s0 data files even allows FlexRaw to
automatically deal with files written on other machines which use
back-to-front byte ordering.  This won't always work \*(-- it's a 1 in 4
billion chance it won't, even if you regularly read 4Gb files!  Also,
it currently doesn't work for compressed files, so you can say `swap'
(again before any data specifiers) to make certain the byte order is
swapped.
.PP
The optional \f(CW$hdr\fR argument allows the use of an anonymous array to
give header information, rather than using a .hdr file.  For example,
.PP
.Vb 5
\&    $header = [
\&        {Type => \*(Aqf77\*(Aq},
\&        {Type => \*(Aqfloat\*(Aq, NDims => 3, Dims => [ 4,600,600 ] }
\&    ];
\&    @a = readflex(\*(Aqbanana\*(Aq,$header);
.Ve
.PP
reads our example file again.  As a special case, when NDims is 1, Dims
may be given as a scalar.
.PP
The highest dimension can be given as \f(CW\*(C`undef\*(C'\fR, which will read as many
frames as possible of the given size (but only if only one hash-ref is given):
.PP
.Vb 3
\&  $video = readflex(\*(Aqframes.raw\*(Aq, [
\&    { Type=>\*(Aqbyte\*(Aq, NDims=>4, Dims=>[4,640,480,undef] },
\&  ]);
.Ve
.PP
Within \s-1PDL,\s0 readflex and writeflex can be used to write several pdls
to a single file \*(-- e.g.
.PP
.Vb 2
\&    use PDL;
\&    use PDL::IO::FlexRaw;
\&
\&    @pdls = ($pdl1, $pdl2, ...);
\&    $hdr = writeflex("fname",@pdls);
\&    @pdl2 = readflex("fname",$hdr);
\&
\&    writeflexhdr("fname",$hdr);  # not needed if $PDL::IO::FlexRaw::writeflexhdr is set
\&    @pdl3 = readflex("fname");
.Ve
.PP
\&\-\- \f(CW\*(C`writeflex\*(C'\fR produces the data file and returns the file header as an
anonymous hash, which can be written to a .hdr file using
\&\f(CW\*(C`writeflexhdr\*(C'\fR.
.PP
If the package variable \f(CW$PDL::IO::FlexRaw::writeflexhdr\fR
is true, and the \f(CW\*(C`writeflex\*(C'\fR call was with a \fIfilename\fR and not
a handle, \f(CW\*(C`writeflexhdr\*(C'\fR will be called automatically (as done by
\&\f(CW\*(C`writefraw\*(C'\fR.
.PP
The reading of compressed data is switched on automatically if the
filename requested ends in .gz or .Z, or if the originally specified
filename does not exist, but one of these compressed forms does.
.PP
If \f(CW\*(C`writeflex\*(C'\fR and \f(CW\*(C`readflex\*(C'\fR are given a reference to a
file handle as a first parameter instead of a filename, then
the data is read or written to the open filehandle.  This
gives an easy way to read an arbitrary slice in a big data
volume, as in the following example:
.PP
.Vb 2
\&    use PDL;
\&    use PDL::IO::FastRaw;
\&
\&    open(DATA, "raw3d.dat");
\&    binmode(DATA);
\&
\&    # assume we know the data size from an external source
\&    ($width, $height, $data_size) = (256,256, 4);
\&
\&    my $slice_num = 64;   # slice to look at
\&    # Seek to slice
\&    seek(DATA, $width*$height*$data_size * $slice_num, 0);
\&    $pdl = readflex \e*DATA, [{Dims=>[$width, $height], Type=>\*(Aqlong\*(Aq}];
.Ve
.PP
\&\s-1WARNING:\s0 In later versions of perl (5.8 and up) you must
be sure that your file is in \*(L"raw\*(R" mode (see the perlfunc
man page entry for \*(L"binmode\*(R", for details).  Both readflex
and writeflex automagically switch the file to raw mode for
you \*(-- but in code like the snipped above, you could end up
seeking the wrong byte if you forget to make the \fBbinmode()\fR call.
.PP
\&\f(CW\*(C`mapflex\*(C'\fR memory maps, rather than reads, the data files.  Its interface
is similar to \f(CW\*(C`readflex\*(C'\fR.  Extra options specify if the data is to be
loaded `ReadOnly', if the data file is to be `Creat'\-ed anew on the
basis of the header information or `Trunc'\-ated to the length of the
data read.  The extra speed of access brings with it some limitations:
\&\f(CW\*(C`mapflex\*(C'\fR won't read compressed data, auto-detect f77 files, or read f77
files written by more than a single unformatted write statement.  More
seriously, data alignment constraints mean that \f(CW\*(C`mapflex\*(C'\fR cannot read
some files, depending on the requirements of the host \s-1OS\s0 (it may also
vary depending on the setting of the `uac' flag on any given machine).
You may have run into similar problems with common blocks in \s-1FORTRAN.\s0
.PP
For instance, floating point numbers may have to align on 4 byte
boundaries \*(-- if the data file consists of 3 bytes then a float, it
cannot be read.  \f(CW\*(C`mapflex\*(C'\fR will warn about this problem when it occurs,
and return the PDLs mapped before the problem arose.  This can be
dealt with either by reorganizing the data file (large types first
helps, as a rule-of-thumb), or more simply by using \f(CW\*(C`readflex\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "glueflex"
.IX Subsection "glueflex"
Append a single data item to an existing binary file written by
\&\*(L"writeflex\*(R".  Must be to the last data item in that file. Error if
dims not compatible with existing data.
.PP
.Vb 4
\&    $hdr = glueflex($file, $pdl[, $hdr]); # or
\&    $hdr = glueflex(FILEHANDLE, $pdl[, $hdr]);
\&    # now you must call writeflexhdr()
\&    writeflexhdr($file, $hdr);
.Ve
.PP
or
.PP
.Vb 3
\&    $PDL::IO::FlexRaw::writeflexhdr = 1; # set so we don\*(Aqt have to call writeflexhdr
\&    $hdr = glueflex($file, $pdl[, $hdr])  # remember, $file must be filename
\&    glueflex($file, $pdl[, $hdr])         # remember, $file must be filename
.Ve
.SS "readflex"
.IX Subsection "readflex"
Read a binary file with flexible format specification
.PP
.Vb 1
\&    Usage:
\&
\&    ($x,$y,...) = readflex("filename" [, $hdr])
\&    ($x,$y,...) = readflex(FILEHANDLE [, $hdr])
.Ve
.SS "mapflex"
.IX Subsection "mapflex"
Memory map a binary file with flexible format specification
.PP
.Vb 1
\&    Usage:
\&
\&    ($x,$y,...) = mapflex("filename" [, $hdr] [, $opts])
.Ve
.PP
.Vb 1
\&    All of these options default to false unless set true:
\&
\&    ReadOnly \- Data should be readonly
\&    Creat    \- Create file if it doesn\*(Aqt exist
\&    Trunc    \- File should be truncated to a length that conforms
\&               with the header
.Ve
.SS "writeflex"
.IX Subsection "writeflex"
Write a binary file with flexible format specification
.PP
.Vb 1
\&    Usage:
\&
\&    $hdr = writeflex($file, $pdl1, $pdl2,...) # or
\&    $hdr = writeflex(FILEHANDLE, $pdl1, $pdl2,...)
\&    # now you must call writeflexhdr()
\&    writeflexhdr($file, $hdr)
.Ve
.PP
or
.PP
.Vb 1
\&    $PDL::IO::FlexRaw::writeflexhdr = 1;  # set so we don\*(Aqt have to call writeflexhdr
\&
\&    $hdr = writeflex($file, $pdl1, $pdl2,...)  # remember, $file must be filename
\&    writeflex($file, $pdl1, $pdl2,...)         # remember, $file must be filename
.Ve
.SS "writeflexhdr"
.IX Subsection "writeflexhdr"
Write the header file corresponding to a previous writeflex call
.PP
.Vb 1
\&    Usage:
\&
\&    writeflexhdr($file, $hdr)
\&
\&    $file or "filename" is the filename used in a previous writeflex
\&    If $file is actually a "filename" then writeflexhdr() will be
\&    called automatically if $PDL::IO::FlexRaw::writeflexhdr is true.
\&    If writeflex() was to a FILEHANDLE, you will need to call
\&    writeflexhdr() yourself since the filename cannot be determined
\&    (at least easily).
.Ve
.SH "BAD VALUE SUPPORT"
.IX Header "BAD VALUE SUPPORT"
As of \s-1PDL\-2.4.8,\s0 PDL::IO::FlexRaw has support for reading and writing
pdls with bad values in them.
.PP
On \f(CW\*(C`writeflex\*(C'\fR, an ndarray
argument with \f(CW\*(C`$pdl\->badflag == 1\*(C'\fR will have the keyword/token \*(L"badvalue\*(R"
added to the header file after the dimension list and an additional token
with the bad value for that pdl if \f(CW\*(C`$pdl\->badvalue != $pdl\->orig_badvalue\*(C'\fR.
.PP
On \f(CW\*(C`readflex\*(C'\fR, a pdl with the \*(L"badvalue\*(R" token in the header will
automatically have its badflag set and its
badvalue as well if it is not the standard default for that type.
.PP
The new badvalue support required some additions to the header
structure.  However, the interface is still being finalized.  For
reference the current \f(CW$hdr\fR looks like this:
.PP
.Vb 7
\&    $hdr = {
\&             Type => \*(Aqbyte\*(Aq,    # data type
\&             NDims => 2,        # number of dimensions
\&             Dims => [640,480], # dims
\&             BadFlag => 1,      # is set/set badflag
\&             BadValue => undef, # undef==default
\&           };
\&
\&    $badpdl = readflex(\*(Aqbadpdl\*(Aq, [$hdr]);
.Ve
.PP
If you use bad values and try the new PDL::IO::FlexRaw bad value
support, please let us know via the perldl mailing list.
Suggestions and feedback are also welcome.
.SH "BUGS"
.IX Header "BUGS"
The test on two dimensional byte arrays fail using g77 2.7.2, but not
Sun f77.  I hope this isn't my problem!
.PP
Assumes gzip is on the \s-1PATH.\s0
.PP
Can't auto-swap compressed files, because it can't seek on them.
.PP
The header format may not agree with that used elsewhere.
.PP
Should it handle handles?
.PP
Mapflex should warn and fallback to reading on \s-1SEGV\s0?  Would have to
make sure that the data was written back after it was `destroyed'.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Robin Williams <rjrw@ast.leeds.ac.uk> 1997.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution,
the copyright notice should be included in the file.
.PP
Documentation contributions copyright (C) David Mertens, 2010.
