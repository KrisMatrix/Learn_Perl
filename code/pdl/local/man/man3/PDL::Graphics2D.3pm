.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Graphics2D 3"
.TH Graphics2D 3 "2022-02-14" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Graphics2D \- An object oriented interface to PDL graphics
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use PDL::Graphics2D;
\& $win = PDL::Graphics2D\->new(<Interface>, <Options>);
\&
\& $w = imag2d( $image, \*(AqTitle Here\*(Aq, ... );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an umbrella class allowing for a simple interface to all plotting
routines in \s-1PDL.\s0 On its own it does not do any work it merely passes
information to the appropriate class. Ideally this should probably offer
a uniform interface to a variety of packages.
.PP
This requires a lot more work before it is useful I feel, but it can be
used already.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "new"
.IX Subsection "new"
Create a 2\-D graphics object with the requested interface type
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "imag2d"
.IX Subsection "imag2d"
Display a 2\-D image in a figure window
.PP
\&\fBimag2d()\fR creates a plain FreeGLUT OpenGL window and displays
the input image with 1:1 aspect ratio for pixels.  The window
resize is constrained to the actual ratio of the image
dimensions.  The initial display size is currently a 200x200
window to prevent things from being too small by default.
.PP
The image to display can have dimensions ($c,$M,$N) where for
\&\f(CW$c\fR==4 the display is in \s-1GL_RGBA,\s0 for \f(CW$c\fR==3 the display is \s-1GL_RGB,\s0
for \f(CW$c\fR==2 the display is \s-1GL_LUMINANCE_ALPHA,\s0 and for \f(CW$c\fR==1 or for
for dimensions ($M,$N) then the display is \s-1GL_LUMINANCE.\s0
.PP
This routine does not yet broadcast but multiple images may be
viewed at the same time in separate windows by multiple
calls to \fBimag2d()\fR.  TriD graphics visualization windows and the
\&\fBimag2d()\fR windows may be created and used independently.
.PP
\&\s-1NOTE:\s0 If you are twiddling a TriD window, the \fBimag2d()\fR
windows are active as well.  If you call \fBtwiddle()\fR
the sub, only the \fBimag2d()\fR windows will update correctly.
.PP
.Vb 1
\&  $window_id = imag2d($image, $name, $zoom, $x_off, $y_off);
\&    
\&    creates a new image figure window from the input ndarray
\&    with the given title, zoom factor, and position (if possible)
\&    
\&    $window_id \- may be used to refer to the figure window
\&    
\&    $image \- 2D image ndarray with at least 2 or 3 dimensions
\&             e.g. [M,N], [1,M,N], [2,M,N], [3,M,N], [4,M,N]
\&    
\&    $name \- the name to use for the figure window (optional)
\&    
\&    $zoom \- desired (float) pixel zoom factor     (optional)
\&    
\&    ($x_off, $y_off) \- desired window pixel position (optional)
\&                       with (0,0) as the top left pixel of the
\&                       display
.Ve
.PP
.Vb 1
\&  use PDL::Graphics2D;     # imports imag2d() and twiddle()
\&
\&  $x = sequence(64,48,3);  # make test RGB image
\&  $x = $x\->mv(2,0);        # color must be dim(0) with size [0..4]
\&  $x /= $x\->max;           # pixel values in [0.0,1.0]
\&  $x = sin(10*$x);
\&  $w1 = imag2d($x);        # with parens...
\&  $w2 = imag2d $x\->sqrt;   # or without
\&  $w3 = imag2d $x**2;
.Ve
.SS "imag2d_update"
.IX Subsection "imag2d_update"
Update an existing imag2d window with new ndarray data
.PP
.Vb 2
\&  $image = random(3,64,48)/2 + 0.25;  # random pixel image
\&  $win = imag2d($image);              # create original image display
\&
\&  imag2d_update($win, $image\->sequence/$image\->nelem);  # update data
.Ve
.PP
\&\f(CW\*(C`imag2d_update\*(C'\fR allows one to update an \f(CW\*(C`imag2d\*(C'\fR display window
by replacing the associated image data with new contents.  The
new image data must be the same type and shape as the previous.
.PP
Eventually, we would like to implement this via some sort of
dataflow that would be transparent to the user.
.SS "twiddle"
.IX Subsection "twiddle"
Enable \s-1GUI\s0 interaction with a FreeGLUT display window.  With an argument, it sets
the default value for the auto-twiddling state. \f(CW 0 \fR will disable the automatic
twiddling and \f(CW 1 \fR, or true, will enable twiddling.
.PP
.Vb 1
\&  twiddle();     # same as twiddle(undef)
\&
\&    Runs the FreeGLUT event loop so window GUI operations
\&    such as resize, expose, mouse click,.. work
\&
\&  twiddle(0);  # disables twiddle looping for next twiddle() call
\&  twiddle(1);  # re\-enables default twiddle looping for next twiddle() call
.Ve
