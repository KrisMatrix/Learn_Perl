.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "FFT 3"
.TH FFT 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::FFT \- FFTs for PDL
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
!!!!!!!!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
As of \s-1PDL\-2.006_04,\s0 the direction of the \s-1FFT/IFFT\s0 has been
reversed to match the usage in the \s-1FFTW\s0 library and the convention
in use generally.
!!!!!!!!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
.PP
FFTs for \s-1PDL.\s0  These work for arrays of any dimension, although ones
with small prime factors are likely to be the quickest.  The forward
\&\s-1FFT\s0 is unnormalized while the inverse \s-1FFT\s0 is normalized so that the
\&\s-1IFFT\s0 of the \s-1FFT\s0 returns the original values.
.PP
For historical reasons, these routines work in-place and do not recognize
the in-place flag.  That should be fixed.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use PDL::FFT qw/:Func/;
\&
\&        fft($real, $imag);
\&        ifft($real, $imag);
\&        realfft($real);
\&        realifft($real);
\&
\&        fftnd($real,$imag);
\&        ifftnd($real,$imag);
\&
\&        $kernel = kernctr($image,$smallk);
\&        fftconvolve($image,$kernel);
.Ve
.SH "DATA TYPES"
.IX Header "DATA TYPES"
The underlying C library upon which this module is based performs FFTs
on both single precision and double precision floating point ndarrays.
The \s-1PP\s0 functions are defined to only take those data types.
Therefore, if you pass in an ndarray of integer datatype (byte, short,
ushort, long) to any of the routines in \s-1PDL::FFT,\s0 your data will be
promoted to a double-precision ndarray.  If you pass in a float, the
single-precision \s-1FFT\s0 will be performed.
.SH "FREQUENCIES"
.IX Header "FREQUENCIES"
For even-sized input arrays, the frequencies are packed like normal
for FFTs (where N is the size of the array and D is the physical step
size between elements):
.PP
.Vb 1
\& 0, 1/ND, 2/ND, ..., (N/2\-1)/ND, 1/2D, \-(N/2\-1)/ND, ..., \-1/ND.
.Ve
.PP
which can easily be obtained (taking the Nyquist frequency to be
positive) using
.PP
\&\f(CW\*(C`$kx = $real\->xlinvals(\-($N/2\-1)/$N/$D,1/2/$D)\->rotate(\-($N/2 \-1));\*(C'\fR
.PP
For odd-sized input arrays the Nyquist frequency is not directly
acessible, and the frequencies are
.PP
.Vb 1
\& 0, 1/ND, 2/ND, ..., (N/2\-0.5)/ND, \-(N/2\-0.5)/ND, ..., \-1/ND.
.Ve
.PP
which can easily be obtained using
.PP
\&\f(CW\*(C`$kx = $real\->xlinvals(\-($N/2\-0.5)/$N/$D,($N/2\-0.5)/$N/$D)\->rotate(\-($N\-1)/2);\*(C'\fR
.SH "ALTERNATIVE FFT PACKAGES"
.IX Header "ALTERNATIVE FFT PACKAGES"
Various other modules \- such as \s-1PDL::FFTW3\s0 and PDL::Slatec \-
contain \s-1FFT\s0 routines.
However, unlike \s-1PDL::FFT,\s0 these modules are optional,
and so may not be installed.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "fft"
.IX Subsection "fft"
.Vb 1
\&  Signature: ([io]real(n); [io]imag(n))
.Ve
.PP
Complex 1\-D \s-1FFT\s0 of the \*(L"real\*(R" and \*(L"imag\*(R" arrays [inplace]. A single
cfloat/cdouble input ndarray can also be used.
.PP
.Vb 2
\&  fft($real,$imag);
\&  fft($complex);
.Ve
.PP
fft does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "ifft"
.IX Subsection "ifft"
.Vb 1
\&  Signature: ([io]real(n); [io]imag(n))
.Ve
.PP
Complex inverse 1\-D \s-1FFT\s0 of the \*(L"real\*(R" and \*(L"imag\*(R" arrays [inplace]. A single
cfloat/cdouble input ndarray can also be used.
.PP
.Vb 2
\&  ifft($real,$imag);
\&  ifft($complex);
.Ve
.PP
ifft does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "\fBrealfft()\fP"
.IX Subsection "realfft()"
One-dimensional \s-1FFT\s0 of real function [inplace].
.PP
The real part of the transform ends up in the first half of the array
and the imaginary part of the transform ends up in the second half of
the array.
.PP
.Vb 1
\&        realfft($real);
.Ve
.SS "\fBrealifft()\fP"
.IX Subsection "realifft()"
Inverse of one-dimensional realfft routine [inplace].
.PP
.Vb 1
\&        realifft($real);
.Ve
.SS "\fBfftnd()\fP"
.IX Subsection "fftnd()"
N\-dimensional \s-1FFT\s0 over all pdl dims of input (inplace)
.PP
.Vb 1
\&        fftnd($real,$imag);
.Ve
.SS "\fBifftnd()\fP"
.IX Subsection "ifftnd()"
N\-dimensional inverse \s-1FFT\s0 over all pdl dims of input (inplace)
.PP
.Vb 1
\&        ifftnd($real,$imag);
.Ve
.SS "\fBfftconvolve()\fP"
.IX Subsection "fftconvolve()"
N\-dimensional convolution with periodic boundaries (\s-1FFT\s0 method)
.PP
.Vb 2
\&        $kernel = kernctr($image,$smallk);
\&        fftconvolve($image,$kernel);
.Ve
.PP
fftconvolve works inplace, and returns an error array in kernel as an
accuracy check \*(-- all the values in it should be negligible.
.PP
See also PDL::ImageND::convolveND, which 
performs speed-optimized convolution with a variety of boundary conditions.
.PP
The sizes of the image and the kernel must be the same.
kernctr centres a small kernel to emulate the
behaviour of the direct convolution routines.
.PP
The speed cross-over between using straight convolution 
(\fBPDL::Image2D::conv2d()\fR) and
these fft routines is for kernel sizes roughly 7x7.
.SH "BUGS"
.IX Header "BUGS"
Where the source is marked `\s-1FIX\s0', could re-implement using phase-shift
factors on the transforms and some real-space bookkeeping, to save
some temporary space and redundant transforms.
.SH "AUTHOR"
.IX Header "AUTHOR"
This file copyright (C) 1997, 1998 R.J.R. Williams
(rjrw@ast.leeds.ac.uk), Karl Glazebrook (kgb@aaoepp.aao.gov.au),
Tuomas J. Lukka, (lukka@husc.harvard.edu).  All rights reserved. There
is no warranty. You are allowed to redistribute this software /
documentation under certain conditions. For details, see the file
\&\s-1COPYING\s0 in the \s-1PDL\s0 distribution. If this file is separated from the
\&\s-1PDL\s0 distribution, the copyright notice should be included in the file.
