.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Matrix 3"
.TH Matrix 3 "2022-02-14" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Matrix \-\- a convenience matrix class for column\-major access
.SH "VERSION"
.IX Header "VERSION"
This document refers to version PDL::Matrix 0.5 of PDL::Matrix
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use PDL::Matrix;
\&
\&  $m = mpdl [[1,2,3],[4,5,6]];
\&  $m = PDL::Matrix\->pdl([[1,2,3],[4,5,6]]);
\&  $m = msequence(4,3);
\&  @dimsa = $x\->mdims; # \*(Aqdims\*(Aq is not overloaded
\&
\&  $v = vpdl [0,1,2,3]
\&  $v = vzeroes(4);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
This package tries to help people who want to use \s-1PDL\s0 for 2D matrix
computation with lots of indexing involved. It provides a \s-1PDL\s0
subclass so one\- and two-dimensional ndarrays that are used as
vectors resp and matrices can be typed in using traditional matrix
convention.
.PP
If you want to know more about matrix operation support in \s-1PDL,\s0 you 
want to read PDL::MatrixOps or PDL::Slatec.
.PP
The original pdl class refers to the first index as the first row,
the second index as the first column of a matrix. Consider
.PP
.Vb 5
\&  print $B = sequence(3,2)
\&  [
\&   [0 1 2]
\&   [3 4 5]
\&  ]
.Ve
.PP
which gives a 2x3 matrix in terms of the matrix convention, but the
constructor used (3,2). This might get more confusing when using
slices like sequence(3,2)\->slice(\*(L"1:2,(0)\*(R") : with traditional
matrix convention one would expect [2 4] instead of [1 2].
.PP
This subclass PDL::Matrix overloads the constructors and indexing
functions of pdls so that they are compatible with the usual matrix
convention, where the first dimension refers to the row of a
matrix. So now, the above example would be written as
.PP
.Vb 6
\&  print $B = PDL::Matrix\->sequence(3,2) # or $B = msequence(3,2)
\&  [
\&   [0 1]
\&   [2 3]
\&   [4 5]
\&  ]
.Ve
.PP
Routines like eigens or
inv can be used without any changes.
.PP
Furthermore one can construct and use vectors as n x 1 matrices
without mentioning the second index '1'.
.SS "Implementation"
.IX Subsection "Implementation"
\&\f(CW\*(C`PDL::Matrix\*(C'\fR works by overloading a number of \s-1PDL\s0 constructors
and methods such that first and second args (corresponding to
first and second dims of corresponding matrices) are effectively swapped.
It is not yet clear if PDL::Matrix achieves a consistent column-major 
look-and-feel in this way.
.SH "NOTES"
.IX Header "NOTES"
As of version 0.5 (rewrite by \s-1CED\s0) the matrices are stored in the usual
way, just constructed and stringified differently.  That way indexing 
and everything else works the way you think it should.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "mpdl, PDL::Matrix::pdl"
.IX Subsection "mpdl, PDL::Matrix::pdl"
constructs an object of class PDL::Matrix which is an ndarray child class.
.PP
.Vb 2
\&    $m = mpdl [[1,2,3],[4,5,6]];
\&    $m = PDL::Matrix\->pdl([[1,2,3],[4,5,6]]);
.Ve
.SS "mzeroes, mones, msequence"
.IX Subsection "mzeroes, mones, msequence"
constructs a PDL::Matrix object similar to the ndarray constructors
zeroes, ones, sequence.
.SS "vpdl"
.IX Subsection "vpdl"
constructs an object of class PDL::Matrix which is of matrix
dimensions (n x 1)
.PP
.Vb 5
\&    print $v = vpdl [0,1];
\&    [
\&     [0]
\&     [1]
\&    ]
.Ve
.SS "vzeroes, vones, vsequence"
.IX Subsection "vzeroes, vones, vsequence"
constructs a PDL::Matrix object with matrix dimensions (n x 1),
therefore only the first scalar argument is used.
.PP
.Vb 5
\&    print $v = vsequence(2);
\&    [
\&     [0]
\&     [1]
\&    ]
.Ve
.SS "kroneckerproduct"
.IX Subsection "kroneckerproduct"
returns kroneckerproduct of two matrices. This is not efficiently
implemented.
.SS "det_general"
.IX Subsection "det_general"
returns a generalized determinant of a matrix. If the matrix is not
regular, one can specify the rank of the matrix and the corresponding
subdeterminant is returned. This is implemented using the \f(CW\*(C`eigens\*(C'\fR
function.
.SS "trace"
.IX Subsection "trace"
returns the trace of a matrix (sum of diagonals)
.SH "BUGS AND PROBLEMS"
.IX Header "BUGS AND PROBLEMS"
Because we change the way ndarrays are constructed, not all pdl
operators may be applied to ndarray-matrices. The inner product is not
redefined. We might have missed some functions/methods. Internal
consistency of our approach needs yet to be established.
.PP
Because PDL::Matrix changes the way slicing behaves, it breaks many
operators, notably those in MatrixOps.
.SH "TODO"
.IX Header "TODO"
check all \s-1PDL\s0 functions, benchmarks, optimization, lots of other things ...
.SH "AUTHOR(S)"
.IX Header "AUTHOR(S)"
Stephan Heuel (stephan@heuel.org), Christian Soeller
(c.soeller@auckland.ac.nz).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
All rights reserved. There is no warranty. You are allowed to
redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution, the
copyright notice should be included in the file.
