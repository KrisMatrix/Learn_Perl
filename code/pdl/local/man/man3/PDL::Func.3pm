.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Func 3"
.TH Func 3 "2022-02-14" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Func \- interpolation, integration, & gradient estimation (differentiation) of functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use PDL::Func;
\& use PDL::Math;
\&
\& # somewhat pointless way to estimate cos and sin,
\& # but is shows that you can broadcast if you want to
\& # (and the library lets you)
\& #
\& my $obj = PDL::Func\->init( Interpolate => "Hermite" );
\& # 
\& my $x = pdl( 0 .. 45 ) * 4 * 3.14159 / 180;
\& my $y = cat( sin($x), cos($x) );
\& $obj\->set( x => $x, y => $y, bc => "simple" );
\& #
\& my $xi = pdl( 0.5, 1.5, 2.5 );
\& my $yi = $obj\->interpolate( $xi );
\& #
\& print "sin( $xi ) equals ", $yi\->slice(\*(Aq:,(0)\*(Aq), "\en";
\& sin( [0.5 1.5 2.5] ) equals  [0.87759844 0.070737667 \-0.80115622]
\& #
\& print "cos( $xi ) equals ", $yi\->slice(\*(Aq:,(1)\*(Aq), "\en";
\& cos( [0.5 1.5 2.5] ) equals  [ 0.4794191 0.99768655 0.59846449]
\& #
\& print sin($xi), "\en", cos($xi), "\en";
\& [0.47942554 0.99749499 0.59847214]
\& [0.87758256 0.070737202 \-0.80114362]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module aims to contain useful functions. Honest.
.SH "INTERPOLATION AND MORE"
.IX Header "INTERPOLATION AND MORE"
This module aims to provide a relatively-uniform interface
to the various interpolation methods available to \s-1PDL.\s0
The idea is that a different interpolation scheme
can be used just by changing an attribute of a \f(CW\*(C`PDL::Func\*(C'\fR
object.
Some interpolation schemes (as exemplified by the \s-1SLATEC\s0
library) also provide additional functionality, such as 
integration and gradient estimation.
.PP
Throughout this documentation, \f(CW$x\fR and \f(CW$y\fR refer to the function
to be interpolated whilst \f(CW$xi\fR and \f(CW$yi\fR are the interpolated values.
.PP
The available types, or \fIschemes\fR, of interpolation are listed below.
Also given are the valid attributes for each scheme: the flag value
indicates whether it can be set (s), got (g), and if it is
required (r) for the method to work.
.IP "Interpolate => Linear" 4
.IX Item "Interpolate => Linear"
An extravagent way of calling the linear interpolation routine
PDL::Primitive::interpolate.
.Sp
The valid attributes are:
.Sp
.Vb 4
\& Attribute    Flag  Description
\& x            sgr   x positions of data
\& y            sgr   function values at x positions
\& err          g     error flag
.Ve
.IP "Interpolate => Hermite" 4
.IX Item "Interpolate => Hermite"
Use the piecewice cubic Hermite interpolation routines
from the \s-1SLATEC\s0 library.
Only available if PDL::Slatec is installed.
.Sp
The valid attributes are:
.Sp
.Vb 6
\& Attribute    Flag  Description
\& x            sgr   x positions of data
\& y            sgr   function values at x positions
\& bc           sgr   boundary conditions
\& g            g     estimated gradient at x positions
\& err          g     error flag
.Ve
.Sp
Given the initial set of points \f(CW\*(C`(x,y)\*(C'\fR, an estimate of the
gradient is made at these points, using the given boundary 
conditions. The gradients are stored in the \f(CW\*(C`g\*(C'\fR attribute,
accessible via:
.Sp
.Vb 1
\& $gradient = $obj\->get( \*(Aqg\*(Aq );
.Ve
.Sp
However, as this gradient is only calculated 'at the last moment',
\&\f(CW\*(C`g\*(C'\fR will only contain data \fIafter\fR one of 
\&\f(CW\*(C`interpolate\*(C'\fR, \f(CW\*(C`gradient\*(C'\fR, or \f(CW\*(C`integrate\*(C'\fR is used.
.SS "Boundary conditions for the Hermite routines"
.IX Subsection "Boundary conditions for the Hermite routines"
If your data is monotonic, and you are not too bothered about
edge effects, then the default value of \f(CW\*(C`bc\*(C'\fR of \f(CW\*(C`simple\*(C'\fR is for you.
Otherwise, take a look at the description of
PDL::Slatec::chic and use a hash reference
for the \f(CW\*(C`bc\*(C'\fR attribute, with the following keys:
.IP "monotonic" 3
.IX Item "monotonic"
0 if the interpolant is to be monotonic in each interval (so
the gradient will be 0 at each switch point), 
otherwise the gradient is calculated using a 3\-point difference
formula at switch points. 
If > 0 then the interpolant is forced to lie close to the 
data, if < 0 no such control is imposed.
Default = \fB0\fR.
.IP "start" 3
.IX Item "start"
A perl list of one or two elements. The first element defines how the
boundary condition for the start of the array is to be calculated;
it has a range of \f(CW\*(C`\-5 .. 5\*(C'\fR, as given for the \f(CW\*(C`ic\*(C'\fR parameter
of chic. 
The second element, only used if options 2, 1, \-1, or 2
are chosen, contains the value of the \f(CW\*(C`vc\*(C'\fR parameter.
Default = \fB[ 0 ]\fR.
.IP "end" 3
.IX Item "end"
As for \f(CW\*(C`start\*(C'\fR, but for the end of the data.
.PP
An example would be
.PP
.Vb 1
\& $obj\->set( bc => { start => [ 1, 0 ], end => [ 1, \-1 ] } )
.Ve
.PP
which sets the first derivative at the first point to 0, 
and at the last point to \-1.
.SS "Errors"
.IX Subsection "Errors"
The \f(CW\*(C`status\*(C'\fR method provides a simple mechanism to check if
the previous method was successful. 
If the function returns an error flag, then it is stored
in the \f(CW\*(C`err\*(C'\fR attribute.
To find out which routine was used, use the
\&\f(CW\*(C`routine\*(C'\fR method.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "init"
.IX Subsection "init"
.Vb 2
\& $obj = PDL::Func\->init( Interpolate => "Hermite", x => $x, y => $y );
\& $obj = PDL::Func\->init( { x => $x, y => $y } );
.Ve
.PP
Create a PDL::Func object, which can interpolate, and possibly
integrate and calculate gradients of a dataset.
.PP
If not specified, the value of Interpolate is taken to be 
\&\f(CW\*(C`Linear\*(C'\fR, which means the interpolation is performed by
PDL::Primitive::interpolate.
A value of \f(CW\*(C`Hermite\*(C'\fR uses piecewise cubic Hermite functions,
which also allows the integral and gradient of the data
to be estimated.
.PP
Options can either be provided directly to the method, as in the
first example, or within a hash reference, as shown in the second
example.
.SS "set"
.IX Subsection "set"
.Vb 2
\& my $nset = $obj\->set( x => $newx, y => $newy );
\& my $nset = $obj\->set( { x => $newx, y => $newy } );
.Ve
.PP
Set attributes for a PDL::Func object.
.PP
The return value gives the number of the supplied attributes
which were actually set.
.SS "get"
.IX Subsection "get"
.Vb 2
\& my $x         = $obj\->get( x );
\& my ( $x, $y ) = $obj\->get( qw( x y ) );
.Ve
.PP
Get attributes from a PDL::Func object.
.PP
Given a list of attribute names, return a list of
their values; in scalar mode return a scalar value.
If the supplied list contains an unknown attribute,
\&\f(CW\*(C`get\*(C'\fR returns a value of \f(CW\*(C`undef\*(C'\fR for that
attribute.
.SS "scheme"
.IX Subsection "scheme"
.Vb 1
\& my $scheme = $obj\->scheme;
.Ve
.PP
Return the type of interpolation of a PDL::Func object.
.PP
Returns either \f(CW\*(C`Linear\*(C'\fR or \f(CW\*(C`Hermite\*(C'\fR.
.SS "status"
.IX Subsection "status"
.Vb 1
\& my $status = $obj\->status;
.Ve
.PP
Returns the status of a PDL::Func object.
.PP
This method provides a high-level indication of 
the success of the last method called
(except for \f(CW\*(C`get\*(C'\fR which is ignored).
Returns \fB1\fR if everything is okay, \fB0\fR if 
there has been a serious error,
and \fB\-1\fR if there
was a problem which was not serious.
In the latter case, \f(CW\*(C`$obj\->get("err")\*(C'\fR may
provide more information, depending on the
particular scheme in use.
.SS "routine"
.IX Subsection "routine"
.Vb 1
\& my $name = $obj\->routine;
.Ve
.PP
Returns the name of the last routine called by a PDL::Func object.
.PP
This is mainly useful for decoding the value stored in the
\&\f(CW\*(C`err\*(C'\fR attribute.
.SS "attributes"
.IX Subsection "attributes"
.Vb 2
\& $obj\->attributes;
\& PDL::Func\->attributes;
.Ve
.PP
Print out the flags for the attributes of a PDL::Func object.
.PP
Useful in case the documentation is just too opaque!
.PP
.Vb 5
\& PDL::Func\->attributes;
\& Flags  Attribute
\&  SGR    x
\&  SGR    y
\&  G      err
.Ve
.SS "interpolate"
.IX Subsection "interpolate"
.Vb 1
\& my $yi = $obj\->interpolate( $xi );
.Ve
.PP
Returns the interpolated function at a given set of points
(PDL::Func).
.PP
A status value of \-1, as returned by the \f(CW\*(C`status\*(C'\fR method, 
means that some of the \f(CW$xi\fR points lay outside the 
range of the data. The values for these points
were calculated by extrapolation (the details depend on the
scheme being used).
.SS "gradient"
.IX Subsection "gradient"
.Vb 2
\& my $gi          = $obj\->gradient( $xi );
\& my ( $yi, $gi ) = $obj\->gradient( $xi );
.Ve
.PP
Returns the derivative and, optionally,
the interpolated function for the \f(CW\*(C`Hermite\*(C'\fR
scheme (PDL::Func).
.SS "integrate"
.IX Subsection "integrate"
.Vb 2
\& my $ans = $obj\->integrate( index => pdl( 2, 5 ) );
\& my $ans = $obj\->integrate( x => pdl( 2.3, 4.5 ) );
.Ve
.PP
Integrate the function stored in the PDL::Func
object, if the scheme is \f(CW\*(C`Hermite\*(C'\fR.
.PP
The integration can either be between points of
the original \f(CW\*(C`x\*(C'\fR array (\f(CW\*(C`index\*(C'\fR), or arbitrary x values
(\f(CW\*(C`x\*(C'\fR). For both cases, a two element ndarray
should be given,
to specify the start and end points of the integration.
.IP "index" 7
.IX Item "index"
The values given refer to the indices of the points
in the \f(CW\*(C`x\*(C'\fR array.
.IP "x" 7
.IX Item "x"
The array contains the actual values to integrate between.
.PP
If the \f(CW\*(C`status\*(C'\fR method returns a value of \-1, then
one or both of the integration limits did not
lie inside the \f(CW\*(C`x\*(C'\fR array. \fICaveat emptor\fR with the
result in such a case.
.SH "TODO"
.IX Header "TODO"
It should be relatively easy to provide an interface to other
interpolation routines, such as those provided by the
Gnu Scientific Library (\s-1GSL\s0), or the B\-spline routines
in the \s-1SLATEC\s0 library.
.PP
In the documentation, the methods are preceded by \f(CW\*(C`PDL::Func::\*(C'\fR
to avoid clashes with functions such as \f(CW\*(C`set\*(C'\fR when using
the \f(CW\*(C`help\*(C'\fR or \f(CW\*(C`apropos\*(C'\fR commands within \fIperldl\fR or \fIpdl2\fR.
.SH "HISTORY"
.IX Header "HISTORY"
Amalgamated \f(CW\*(C`PDL::Interpolate\*(C'\fR and \f(CW\*(C`PDL::Interpolate::Slatec\*(C'\fR
to form \f(CW\*(C`PDL::Func\*(C'\fR. Comments greatly appreciated on the
current implementation, as it is not too sensible.
.PP
Thanks to Robin Williams, Halldór Olafsson, and Vince McIntyre.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2000,2001 Doug Burke (dburke@cfa.harvard.edu).
All rights reserved. There is no warranty. 
You are allowed to redistribute this software / documentation as 
described in the file \s-1COPYING\s0 in the \s-1PDL\s0 distribution.
