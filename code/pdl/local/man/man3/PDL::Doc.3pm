.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Doc 3"
.TH Doc 3 "2022-03-13" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Doc \- support for PDL online documentation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use PDL::Doc;
\&  $onlinedc = new PDL::Doc ($docfile);
\&  @match = $onlinedc\->search(\*(Aqm/slice|clump/\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An implementation of online docs for \s-1PDL.\s0
.SH "Using PDL documentation"
.IX Header "Using PDL documentation"
PDL::Doc's main use is in the \*(L"help\*(R" (synonym \*(L"?\*(R") and \*(L"apropos\*(R"
(synonym \*(L"??\*(R") commands in the perldl shell.  PDL::Doc provides the
infrastrucure to index and access \s-1PDL\s0's documentation through these
commands.  There is also an \s-1API\s0 for direct access to the documentation 
database (see below).
.PP
The \s-1PDL\s0 doc system is built on Perl's pod (Plain Old Documentation),
included inline with each module. The \s-1PDL\s0 core modules are
automatically indexed when \s-1PDL\s0 is built and installed, and there is
provision for indexing external modules as well.
.PP
To include your module's pod into the Perl::Doc index, you should
follow the documentation conventions below.
.SH "PDL documentation conventions"
.IX Header "PDL documentation conventions"
For a package like \s-1PDL\s0 that has \fIa lot\fR of functions it
is very desirable to have some form of online help to
make it easy for users to remind themselves of names,
calling conventions and typical usage of the multitude
of functions at their disposal. To make it straightforward
to extract the relevant information from the \s-1POD\s0 documentation
in source files that make up the \s-1PDL\s0 distribution
certain conventions have been adopted in formatting this
documentation.
.PP
The first convention says that all documentation for
\&\s-1PDL\s0 functions appears in the \s-1POD\s0 section introduced
by one of the following:
.PP
.Vb 4
\&  =head1 FUNCTIONS
\&  =head1 OPERATORS
\&  =head1 METHODS
\&  =head1 CONSTRUCTORS
.Ve
.PP
If you're documenting an object-oriented interface to a class
that your module defines, you should use \s-1METHODS\s0 and \s-1CONSTRUCTORS\s0
as appropriate.  If you are simply adding functions to \s-1PDL,\s0
use \s-1FUNCTIONS\s0 and \s-1OPERATORS\s0 as appropriate.
.PP
Individual functions or methods in these section are introduced by
.PP
.Vb 1
\&  =head2 funcname
.Ve
.PP
where signature is the argumentlist for a \s-1PP\s0 defined function as
explained in \s-1PDL::PP\s0. Generally, \s-1PDL\s0 documentation is in valid \s-1POD\s0
format (see perlpod) but uses the \f(CW\*(C`=for\*(C'\fR directive in a
special way. The \f(CW\*(C`=for\*(C'\fR directive is used to flag to the \s-1PDL\s0 Pod
parser that information is following that will be used to generate
online help.
.PP
The \s-1PDL\s0 Pod parser recognises the following \f(CW\*(C`=for\*(C'\fR directives:
.IP "Ref" 5
.IX Item "Ref"
indicates that the one line reference for this function follows,
e.g.,
.Sp
.Vb 1
\&   =for ref
\&
\&   Returns an ndarray of lags to parent.
.Ve
.IP "Sig" 5
.IX Item "Sig"
the signature for the current function follows, e.g.,
.Sp
.Vb 1
\&   =for sig
\&
\&      Signature: (a(n), [o]b(), [t]tmp(n))
.Ve
.IP "Usage" 5
.IX Item "Usage"
an indication of the possible calling conventions for the current
function, e.g.,
.Sp
.Vb 1
\&   =for usage
\&
\&      wpic($pdl,$filename[,{ options... }])
.Ve
.IP "Opt" 5
.IX Item "Opt"
lists options for the current function, e.g.,
.Sp
.Vb 1
\&   =for options
\&
\&      CONVERTER  => \*(Aqppmtogif\*(Aq,   # explicitly specify pbm converter
\&      FLAGS      => \*(Aq\-interlaced \-transparent 0\*(Aq,  # flags for converter
\&      IFORM      => \*(AqPGM\*(Aq,        # explicitly specify intermediate format
\&      XTRAFLAGS  => \*(Aq\-imagename iris\*(Aq, # additional flags to defaultflags
\&      FORMAT     => \*(AqPCX\*(Aq,        # explicitly specify output image format
\&      COLOR      => \*(Aqbw\*(Aq,         # specify color conversion
\&      LUT        => $lut,         # use color table information
.Ve
.IP "Example" 5
.IX Item "Example"
gives examples of typical usage for the current function:
.Sp
.Vb 1
\&   =for example
\&
\&       wpic $pdl, $file;
\&       $im\->wpic(\*(Aqweb.gif\*(Aq,{LUT => $lut});
\&       for (@images) {
\&         $_\->wpic($name[0],{CONVERTER => \*(Aqppmtogif\*(Aq})
\&       }
.Ve
.IP "Bad" 5
.IX Item "Bad"
provides information on how the function handles bad values. The
documentation under this directive should indicate if this function
accepts ndarrays with bad values and under what circumstances this function
might return ndarrays with bad values.
.PP
The \s-1PDL\s0 podparser is implemented as a simple state machine. Any of
the above \f(CW\*(C`=for\*(C'\fR statements switches the podparser into a state
where the following paragraph is accepted as information for the
respective field (\f(CW\*(C`Ref\*(C'\fR, \f(CW\*(C`Usage\*(C'\fR, \f(CW\*(C`Opt\*(C'\fR, \f(CW\*(C`Example\*(C'\fR or \f(CW\*(C`Bad\*(C'\fR). 
Only the text up to
the end of the current paragraph is accepted, for example:
.PP
.Vb 1
\&  =for example
\&
\&         ($x,$y) = $z\->func(1,3);  # this is part of the accepted info
\&         $x = func($z,0,1);        # this as well
\&
\&         $x = func($c,$d);         # but this isn\*(Aqt
.Ve
.PP
To make the resulting pod documentation also easily digestible for the
existing pod filters (pod2man, pod2text, pod2html, etc) the actual
textblock of information must be separated from the \f(CW\*(C`=for\*(C'\fR directive
by at least one blank line. Otherwise, the textblock will be lost in
the translation process when the \*(L"normal\*(R" podformatters are used. The
general idea behind this format is that it should be easy to extract
the information for online documentation, automatic generation of a
reference card, etc but at the same time the documentation should be
translated by the standard podformatters without loss of contents
(and without requiring any changes in the existing \s-1POD\s0 format).
.PP
The preceding explanations should be further explained by the
following example (extracted from PDL/IO/Misc/misc.pd):
.PP
.Vb 1
\&   =head2 rcols()
\&
\&   =for ref
\&
\&   Read ASCII whitespaced cols from file into ndarrays efficiently.
\&
\&   If no columns are specified all are assumed
\&   Will optionally only process lines matching a pattern.
\&   Can take file name or *HANDLE.
\&
\&   =for usage
\&
\&    Usage: ($x,$y,...) = rcols(*HANDLE|"filename", ["/pattern/",$col1, $col2,] ...)
\&
\&   e.g.,
\&
\&   =for example
\&
\&     ($x,$y)    = rcols \*(Aqfile1\*(Aq
\&     ($x,$y,$z) = rcols \*(Aqfile2\*(Aq, "/foo/",3,4
\&     $x = PDL\->rcols \*(Aqfile1\*(Aq;
\&
\&   Note: currently quotes are required on the pattern.
.Ve
.PP
which is translated by, e.g, the standard \f(CW\*(C`pod2text\*(C'\fR converter into:
.PP
.Vb 1
\&  rcols()
\&
\&    Read ASCII whitespaced cols from file into ndarrays efficiently.
\&
\&    If no columns are specified all are assumed Will optionally only
\&    process lines matching a pattern. Can take file name or *HANDLE.
\&
\&      Usage: ($x,$y,...) = rcols(*HANDLE|"filename", ["/pattern/",$col1, $col2,] ...)
\&
\&    e.g.,
\&
\&      ($x,$y)    = rcols \*(Aqfile1\*(Aq
\&      ($x,$y,$z) = rcols \*(Aqfile2\*(Aq, "/foo/",3,4
\&      $x = PDL\->rcols \*(Aqfile1\*(Aq;
\&
\&    Note: currently quotes are required on the pattern.
.Ve
.PP
It should be clear from the preceding example that readable output
can be obtained from this format using the standard converters and
the reader will hopefully get a feeling how they can easily intersperse
the special \f(CW\*(C`=for\*(C'\fR directives with the normal \s-1POD\s0 documentation.
.SS "Which directives should be contained in the documentation"
.IX Subsection "Which directives should be contained in the documentation"
The module documentation should
start with the
.PP
.Vb 1
\&  =head1 NAME
\&
\&  PDL::Modulename \-\- do something with ndarrays
.Ve
.PP
section (as anyway required by \f(CW\*(C`pod2man\*(C'\fR) since the \s-1PDL\s0 podparser
extracts the name of the module this function belongs to from
that section.
.PP
Each function that is \fInot\fR only for internal use by the module
should be documented, introduced with the \f(CW\*(C`=head2\*(C'\fR directive
in the \f(CW\*(C`=head1 FUNCTIONS\*(C'\fR section. The only field that every function
documented along these lines should have is the \fIRef\fR field preceding
a one line description of its intended functionality (suitable for
inclusion in a concise reference card). \s-1PP\s0 defined functions (see \s-1PDL::PP\s0)
should have a \fISig\fR field stating their signature. To facilitate
maintenance of this documentation for such functions the 'Doc' field
has been introduced into the definition of \f(CW\*(C`pp_def\*(C'\fR (see again \s-1PDL::PP\s0)
which will take care that name and signature of the so defined function
are documented in this way (for examples of this usage see, for example,
the PDL::Slices module, especially \fIslices.pd\fR and the resulting
\&\fISlices.pm\fR). Similarly, the 'BadDoc' field provides a means of
specifying information on how the routine handles the presence of
bad values: this will be autpmatically created if 
\&\f(CW\*(C`BadDoc\*(C'\fR is not supplied, or set to \f(CW\*(C`undef\*(C'\fR.
.PP
Furthermore, the documentation for each function should contain
at least one of the \fIUsage\fR or \fIExamples\fR fields. Depending on the
calling conventions for the function under consideration presence
of both fields may be warranted.
.PP
If a function has options that should be given as a hash reference in
the form
.PP
.Vb 1
\&   {Option => Value, ...}
.Ve
.PP
then the possible options (and aproppriate values) should be explained
in the textblock following the \f(CW\*(C`=for Opt\*(C'\fR directive (see example above
and, e.g., PDL::IO::Pic).
.PP
It is well possible that some of these conventions appear to be clumsy
at times and the author is keen to hear of any suggestions for better
alternatives.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $onlinedc = new PDL::Doc (\*(Aqfile.pdl\*(Aq,[more files]);
.Ve
.SS "addfiles"
.IX Subsection "addfiles"
add another file to the online database associated with this object.
.SS "outfile"
.IX Subsection "outfile"
set the name of the output file for this online db
.SS "ensuredb"
.IX Subsection "ensuredb"
Make sure that the database is slurped in
.SS "savedb"
.IX Subsection "savedb"
save the database (i.e., the hash of \s-1PDL\s0 symbols) to the file associated
with this object.
.SS "gethash"
.IX Subsection "gethash"
Return the \s-1PDL\s0 symhash (e.g. for custom search operations)
.PP
The symhash is a multiply nested hash ref with the following structure:
.PP
.Vb 10
\& $symhash = {
\&     function_name => {
\&             module::name => {
\&                  Module => \*(Aqmodule::name\*(Aq,
\&                  Sig    => \*(Aqsignature string\*(Aq,
\&                  Bad    => \*(Aqbad documentation string\*(Aq,
\&                  ...
\&                  },
\&             },
\&     function_name => {
\&             module::name => {
\&                  Module => \*(Aqmodule::name\*(Aq,
\&                  Sig    => \*(Aqsignature string\*(Aq,
\&                  Bad    => \*(Aqbad documentation string\*(Aq,
\&                  ...
\&                  },
\&             },
\& }
.Ve
.PP
The three-layer structure is designed to allow the symhash (and the
underlying database) to handle functions that have the same name but
reside in different module namespaces.
.PP
The possible keys for each function/module entry include:
.PP
.Vb 10
\& Module   \- module name
\& Sig      \- signature
\& Crossref \- the function name for the documentation, if it has multiple
\&            names (ex: the documentation for zeros is under zeroes)
\& Names    \- a comma\-separated string of all the function\*(Aqs names
\& Example  \- example text (optional)
\& Ref      \- one\-line reference string
\& Opt      \- options
\& Usage    \- short usage explanation
\& Bad      \- explanation of behavior when it encounters bad values
.Ve
.SS "search"
.IX Subsection "search"
Search a \s-1PDL\s0 symhash
.PP
.Vb 1
\&  $onldc\->search($regex, $fields [, $sort])
.Ve
.PP
Searching is by default case insensitive. Other flags can be
given by specifying the regexp in the form \f(CW\*(C`m/regex/ismx\*(C'\fR
where \f(CW\*(C`/\*(C'\fR can be replaced with any other non-alphanumeric
character. \f(CW$fields\fR is an array reference for all hash fields
(or simply a string if you only want to search one field)
that should be matched against the regex. Valid fields are
.PP
.Vb 6
\&  Name,    # name of the function
\&  Module,  # module the function belongs to
\&  Ref,     # the one\-line reference description
\&  Example, # the example for this function
\&  Opt,     # options
\&  File,    # the path to the source file these docs have been extracted from
.Ve
.PP
If you wish to have your results sorted by function name, pass a true
value for \f(CW$sort\fR.
.PP
The results will be returned as an array of triplets in the form
.PP
.Vb 5
\& @results = (
\&  [funcname, module, {SYMHASH_ENTRY}],
\&  [funcname, module, {SYMHASH_ENTRY}],
\&  ...
\& );
.Ve
.PP
See the example at the end of the documentation to see how you might
use this.
.SS "scan"
.IX Subsection "scan"
Scan a source file using the \s-1PDL\s0 podparser to extract information
for online documentation
.SS "scantree"
.IX Subsection "scantree"
Scan whole directory trees for online documentation in
\&\f(CW\*(C`.pm\*(C'\fR (module definition) and \f(CW\*(C`*.pod\*(C'\fR (general
documentation) files (using the File::Find module).
.SS "funcdocs"
.IX Subsection "funcdocs"
extract the complete documentation about a function from its
source file using the PDL::PodParser filter.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "add_module"
.IX Subsection "add_module"
.Vb 1
\& use PDL::Doc; PDL::Doc::add_module("my::module");
.Ve
.PP
The \f(CW\*(C`add_module\*(C'\fR function allows you to add \s-1POD\s0 from a particular Perl
module that you've installed somewhere in \f(CW@INC\fR.  It searches for the
active \s-1PDL\s0 document database and the module's .pod and .pm files, and
scans and indexes the module into the database.
.PP
\&\f(CW\*(C`add_module\*(C'\fR is meant to be added to your module's Makefile as part of the
installation script.
.SH "PDL::DOC EXAMPLE"
.IX Header "PDL::DOC EXAMPLE"
Here's an example of how you might use the \s-1PDL\s0 Doc database in your
own code.
.PP
.Vb 11
\& use PDL::Doc;
\& # Find the pdl documentation
\& my ($dir,$file,$pdldoc);
\& DIRECTORY: for $dir (@INC) {
\&     $file = $dir."/PDL/pdldoc.db";
\&     if (\-f $file) {
\&         print "Found docs database $file\en";
\&         $pdldoc = new PDL::Doc ($file);
\&         last DIRECTORY;
\&     }
\& }
\&
\& die ("Unable to find docs database!\en") unless $pdldoc;
\&
\& # Print the reference line for zeroes:
\& print map{$_\->{Ref}} values %{$pdldoc\->gethash\->{zeroes}};
\& # Or, if you remember that zeroes is in PDL::Core:
\& print $pdldoc\->gethash\->{zeroes}\->{PDL::Core}\->{Ref};
\&
\& # Get info for all the functions whose examples use zeroes
\& my @entries = $pdldoc\->search(\*(Aqzeroes\*(Aq,\*(AqExample\*(Aq,1);
\&
\& # All the functions that use zeroes in their example:
\& print "Functions that use \*(Aqzeroes\*(Aq in their examples include:\en";
\& foreach my $entry (@entries) {
\&     # Unpack the entry
\&     my ($func_name, $module, $sym_hash) = @$entry;
\&     print "$func_name\en";
\& }
\& print "\en";
\&
\& #Or, more concisely:
\& print join("\en",map{$_\->[0]}@entries);
\&
\& # Let\*(Aqs look at the function \*(Aqmpdl\*(Aq
\& @entries = $pdldoc\->search(\*(Aqmpdl\*(Aq, \*(AqName\*(Aq);
\& # I know there\*(Aqs only one:
\& my $entry = $entries[0];
\& my ($func_name, undef, $sym_hash) = @$entry;
\& print "mpdl info:\en";
\& foreach my $key (sort keys %$sym_hash) {
\&     # Unpack the entry
\&     print "\-\-\-$key\-\-\-\en$sym_hash\->{$key}\en";
\& }
.Ve
.SS "Finding Modules"
.IX Subsection "Finding Modules"
How can you tell if you've gotten a module for one of your entries?
The Ref entry will begin with 'Module:' if it's a module. In code:
.PP
.Vb 3
\& # Prints:
\& #  Module: fundamental PDL functionality and vectorization/broadcasting
\& print $pdldoc\->gethash\->{\*(AqPDL::Core\*(Aq}\->{\*(AqPDL::Core\*(Aq}\->{Ref}, "\en"
.Ve
.SH "BUGS"
.IX Header "BUGS"
Quite a few shortcomings which will hopefully be fixed following
discussions on the pdl-devel mailing list.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 1997 Christian Soeller <c.soeller@auckland.ac.nz>
and Karl Glazebrook <kgb@aaoepp.aao.gov.au>
.PP
Further contributions copyright 2010 David Mertens
<dcmertens.perl@gmail.com>
.PP
Documentation database restructuring 2019 Derek Lamb
.PP
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution,
the copyright notice should be included in the file.
