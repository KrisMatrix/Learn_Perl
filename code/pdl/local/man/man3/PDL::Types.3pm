.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Types 3"
.TH Types 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Types \- define fundamental PDL Datatypes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use PDL::Types;
\&
\& $pdl = ushort( 2.0, 3.0 );
\& print "The actual c type used to store ushort\*(Aqs is \*(Aq" .
\&    $pdl\->type\->realctype() . "\*(Aq\en";
\& The actual c type used to store ushort\*(Aqs is \*(Aqunsigned short\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Internal module \- holds all the \s-1PDL\s0 Type info.  The type info can be
accessed easily using the \f(CW\*(C`PDL::Type\*(C'\fR object returned by
the type method as shown in the synopsis.
.PP
Skip to the end of this document to find out how to change
the set of types supported by \s-1PDL.\s0
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
A number of functions are available for module writers
to get/process type information. These are used in various
places (e.g. \f(CW\*(C`PDL::PP\*(C'\fR, \f(CW\*(C`PDL::Core\*(C'\fR) to generate the
appropriate type loops, etc.
.SS "typesrtkeys"
.IX Subsection "typesrtkeys"
Returns an array of keys of typehash sorted in order of type complexity
.PP
.Vb 3
\& pdl> @typelist = PDL::Types::typesrtkeys;
\& pdl> print @typelist;
\& PDL_B PDL_S PDL_US PDL_L PDL_IND PDL_LL PDL_F PDL_D
.Ve
.SS "ppdefs"
.IX Subsection "ppdefs"
Returns an array of pp symbols for all real types. This informs the
default \f(CW\*(C`GenericTypes\*(C'\fR for \f(CW\*(C`pp_def\*(C'\fR functions, making support for
complex types require an \*(L"opt-in\*(R".
.PP
.Vb 2
\& pdl> print PDL::Types::ppdefs
\& B S U L N Q F D
.Ve
.SS "ppdefs_complex"
.IX Subsection "ppdefs_complex"
Returns an array of pp symbols for all complex types.
.PP
.Vb 2
\& pdl> print PDL::Types::ppdefs_complex
\& G C
.Ve
.SS "ppdefs_all"
.IX Subsection "ppdefs_all"
Returns an array of pp symbols for all types including complex.
.PP
.Vb 2
\& pdl> print PDL::Types::ppdefs_all
\& B S U L N Q F D G C
.Ve
.SS "typesynonyms"
.IX Subsection "typesynonyms"
return type related synonym definitions to be included in pdl.h .
This routine must be updated to include new types as required.
Mostly the automatic updating should take care of the vital
things.
.SH "PDL TYPES OVERVIEW"
.IX Header "PDL TYPES OVERVIEW"
As of 2.065, \s-1PDL\s0 supports these types:
.IP "SByte" 4
.IX Item "SByte"
Signed 8\-bit value.
.IP "Byte" 4
.IX Item "Byte"
Unsigned 8\-bit value.
.IP "Short" 4
.IX Item "Short"
Signed 16\-bit value.
.IP "UShort" 4
.IX Item "UShort"
Unsigned 16\-bit value.
.IP "Long" 4
.IX Item "Long"
Signed 32\-bit value.
.IP "ULong" 4
.IX Item "ULong"
Unsigned 32\-bit value.
.IP "Indx" 4
.IX Item "Indx"
Signed value, same size as a pointer on the system in use.
.IP "LongLong" 4
.IX Item "LongLong"
Signed 64\-bit value.
.IP "ULongLong" 4
.IX Item "ULongLong"
Unsigned 64\-bit value.
.IP "Float" 4
.IX Item "Float"
\&\s-1IEEE 754\s0 <https://en.wikipedia.org/wiki/IEEE_754> single-precision real
floating-point value.
.IP "Double" 4
.IX Item "Double"
\&\s-1IEEE 754\s0 double-precision real value.
.IP "LDouble" 4
.IX Item "LDouble"
A C99 \*(L"long double\*(R", defined as \*(L"at least as precise as a double\*(R",
but often more precise.
.IP "CFloat" 4
.IX Item "CFloat"
A C99 complex single-precision floating-point value.
.IP "CDouble" 4
.IX Item "CDouble"
A C99 complex double-precision floating-point value.
.IP "CLDouble" 4
.IX Item "CLDouble"
A C99 complex \*(L"long double\*(R" \- see above for description.
.SH "PDL::Type OBJECTS"
.IX Header "PDL::Type OBJECTS"
This module declares one class \- \f(CW\*(C`PDL::Type\*(C'\fR \- objects of this class
are returned by the type method of an ndarray.  It has
several methods, listed below, which provide an easy way to access
type information:
.PP
Additionally, comparison and stringification are overloaded so that
you can compare and print type objects, e.g.
.PP
.Vb 2
\&  $nofloat = 1 if $pdl\->type < float;
\&  die "must be double" if $type != double;
.Ve
.PP
For further examples check again the
type method.
.IP "enum" 4
.IX Item "enum"
Returns the number representing this datatype (see get_datatype).
.IP "symbol" 4
.IX Item "symbol"
Returns one of '\s-1PDL_B\s0', '\s-1PDL_S\s0', '\s-1PDL_US\s0', '\s-1PDL_L\s0', '\s-1PDL_IND\s0', '\s-1PDL_LL\s0',
\&'\s-1PDL_F\s0' or '\s-1PDL_D\s0'.
.IP "ctype" 4
.IX Item "ctype"
Returns the macro used to represent this type in C code (eg 'PDL_Long').
.IP "ppsym" 4
.IX Item "ppsym"
The letter used to represent this type in \s-1PP\s0 code (eg 'U' for ushort).
.IP "realctype" 4
.IX Item "realctype"
The actual C type used to store this type.
.IP "shortctype" 4
.IX Item "shortctype"
The value returned by \f(CW\*(C`ctype\*(C'\fR without the '\s-1PDL_\s0' prefix.
.IP "badvalue" 4
.IX Item "badvalue"
The special numerical value used to represent bad values for this type.
See \*(L"badvalue\*(R" in PDL::Bad for more details.
.IP "isnan" 4
.IX Item "isnan"
Given a string representing a C value, will return a C expression for
this type that indicates whether that value is NaN (for complex values,
if \fIeither\fR is NaN).
.IP "isfinite" 4
.IX Item "isfinite"
Given a string representing a C value, will return a C expression for
this type that indicates whether that value is finite (for complex values,
if \fIboth\fR are finite).
.IP "floatsuffix" 4
.IX Item "floatsuffix"
The string appended to floating-point functions for this floating-point
type. Dies if called on non-floating-point type.
.IP "orig_badvalue" 4
.IX Item "orig_badvalue"
The default special numerical value used to represent bad values for this
type. (You can change the value that represents bad values for each type
during runtime.) See the
orig_badvalue routine in PDL::Bad for more details.
.IP "bswap" 4
.IX Item "bswap"
Returns the appropriate \f(CW\*(C`bswap*\*(C'\fR from PDL::IO::Misc for the size of
this type, including a no-op for types of size 1. Note this means a
one-line construction means you must call the return value:
.Sp
.Vb 1
\&  $pdl\->type\->bswap\->($pdl);
.Ve
.SH "DEVELOPER NOTES ON ADDING/REMOVING TYPEs"
.IX Header "DEVELOPER NOTES ON ADDING/REMOVING TYPEs"
You can change the types that \s-1PDL\s0 knows about by editing entries in
the definition of the variable \f(CW@types\fR that appears close to the
top of the file \fITypes.pm.PL\fR (i.e. the file from which this module
was generated).
.SS "Format of a type entry"
.IX Subsection "Format of a type entry"
Each entry in the \f(CW@types\fR array is a hash reference. Here is an example
taken from the actual code that defines the \f(CW\*(C`ushort\*(C'\fR type:
.PP
.Vb 10
\&             {
\&              identifier => \*(AqUS\*(Aq,
\&              onecharident => \*(AqU\*(Aq,   # only needed if different from identifier
\&              pdlctype => \*(AqPDL_Ushort\*(Aq,
\&              realctype => \*(Aqunsigned short\*(Aq,
\&              ppforcetype => \*(Aqushort\*(Aq,
\&              usenan => 0,
\&              packtype => \*(AqS*\*(Aq,
\&              defaultbadval => \*(AqUSHRT_MAX\*(Aq,
\&              real=>1,
\&              integer=>1,
\&              unsigned=>1,
\&             },
.Ve
.PP
Before we start to explain the fields please take this important
message on board:
\&\fIentries must be listed in order of increasing complexity\fR. This
is critical to ensure that \s-1PDL\s0's type conversion works correctly.
Basically, a less complex type will be converted to a more complex
type as required.
.SS "Fields in a type entry"
.IX Subsection "Fields in a type entry"
Each type entry has a number of required and optional entry.
.PP
A list of all the entries:
.IP "\(bu" 4
identifier
.Sp
\&\fIRequired\fR. A short sequence of upercase letters that identifies this
type uniquely. More than three characters is probably overkill.
.IP "\(bu" 4
onecharident
.Sp
\&\fIOptional\fR. Only required if the \f(CW\*(C`identifier\*(C'\fR has more than one character.
This should be a unique uppercase character that will be used to reference
this type in \s-1PP\s0 macro expressions of the \f(CW\*(C`TBSULFD\*(C'\fR type \- see \*(L"$T\*(R" in \s-1PDL::PP\s0.
.IP "\(bu" 4
pdlctype
.Sp
\&\fIRequired\fR. The \f(CW\*(C`typedef\*(C'\fRed name that will be used to access this type
from C code.
.IP "\(bu" 4
realctype
.Sp
\&\fIRequired\fR. The C compiler type that is used to implement this type.
For portability reasons this one might be platform dependent.
.IP "\(bu" 4
ppforcetype
.Sp
\&\fIRequired\fR. The type name used in \s-1PP\s0 signatures to refer to this type.
.IP "\(bu" 4
usenan
.Sp
\&\fIRequired\fR. Flag that signals if this type has to deal with NaN issues.
Generally only required for floating point types.
.IP "\(bu" 4
packtype
.Sp
\&\fIRequired\fR. The Perl pack type used to pack Perl values into the machine representation for this type. For details see \f(CW\*(C`perldoc \-f pack\*(C'\fR.
.IP "\(bu" 4
integer
.Sp
\&\fIRequired\fR. Boolean \- is this an integer type?
.IP "\(bu" 4
unsigned
.Sp
\&\fIRequired\fR. Boolean \- is this an unsigned type?
.IP "\(bu" 4
real
.Sp
\&\fIRequired\fR. Boolean \- is this a real (not complex) type?
.IP "\(bu" 4
realversion
.Sp
String \- the real version of this type (e.g. cdouble \-> 'D').
.IP "\(bu" 4
complexversion
.Sp
String \- the complex version of this type (e.g. double \-> 'C').
.PP
Also have a look at the entries at the top of \fITypes.pm.PL\fR.
.PP
The syntax is not written into stone yet and might change as the
concept matures.
.SS "Other things you need to do"
.IX Subsection "Other things you need to do"
You need to check modules that do I/O (generally in the \fI\s-1IO\s0\fR
part of the directory tree). In the future we might add fields to
type entries to automate this. This requires changes to those \s-1IO\s0
modules first though.
.PP
You should also make sure that any type macros in \s-1PP\s0 files
(i.e. \f(CW\*(C`$TBSULFD...\*(C'\fR) are updated to reflect the new type. PDL::PP::Dump
has a mode to check for type macros requiring updating. Do something like
.PP
.Vb 1
\&    find . \-name \e*.pd \-exec perl \-Mblib=. \-M\*(AqPDL::PP::Dump=typecheck\*(Aq {} \e;
.Ve
.PP
from the \s-1PDL\s0 root directory \fIafter\fR updating \fITypes.pm.PL\fR to check
for such places.
