.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Math 3"
.TH Math 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Math \- extended mathematical operations and special functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use PDL::Math;
\&
\& use PDL::Graphics::TriD;
\& imag3d [SURF2D,bessj0(rvals(zeroes(50,50))/2)];
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module extends \s-1PDL\s0 with more advanced mathematical functions than
provided by standard Perl.
.PP
All the functions have one input pdl, and one output, unless otherwise
stated.
.PP
Many of the functions are linked from the system maths library or the
Cephes maths library (determined when \s-1PDL\s0 is compiled); a few are implemented
entirely in \s-1PDL.\s0
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "acos"
.IX Subsection "acos"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The usual trigonometric function.
 Works inplace.
.PP
acos processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "asin"
.IX Subsection "asin"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The usual trigonometric function.
 Works inplace.
.PP
asin processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "atan"
.IX Subsection "atan"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The usual trigonometric function.
 Works inplace.
.PP
atan processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "cosh"
.IX Subsection "cosh"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The standard hyperbolic function.
 Works inplace.
.PP
cosh processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "sinh"
.IX Subsection "sinh"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The standard hyperbolic function.
 Works inplace.
.PP
sinh processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "tan"
.IX Subsection "tan"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The usual trigonometric function.
 Works inplace.
.PP
tan processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "tanh"
.IX Subsection "tanh"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The standard hyperbolic function.
 Works inplace.
.PP
tanh processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "ceil"
.IX Subsection "ceil"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
Round to integer values in floating-point format. Works inplace.
.PP
ceil processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "floor"
.IX Subsection "floor"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
Round to integer values in floating-point format. Works inplace.
.PP
floor processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rint"
.IX Subsection "rint"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
Round to integer values in floating-point format.
.PP
rint uses the 'round half to even' rounding method (also known as
banker's rounding).  Half-integers are rounded to the nearest even
number. This avoids a slight statistical bias inherent in always
rounding half-integers up or away from zero.
.PP
If you are looking to round half-integers up (regardless of sign), try
\&\f(CW\*(C`floor($x+0.5)\*(C'\fR.  If you want to round half-integers away from zero,
try \f(CW\*(C`ceil(abs($x)+0.5)*($x<=>0)\*(C'\fR. Works inplace.
.PP
rint processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "pow"
.IX Subsection "pow"
.Vb 1
\&  Signature: (a(); b(); [o]c())
.Ve
.PP
Synonym for `**'. Works inplace.
.PP
pow processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "acosh"
.IX Subsection "acosh"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The standard hyperbolic function.
 Works inplace.
.PP
acosh processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "asinh"
.IX Subsection "asinh"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The standard hyperbolic function.
 Works inplace.
.PP
asinh processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "atanh"
.IX Subsection "atanh"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The standard hyperbolic function.
 Works inplace.
.PP
atanh processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "erf"
.IX Subsection "erf"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The error function. Works inplace.
.PP
erf processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "erfc"
.IX Subsection "erfc"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The complement of the error function. Works inplace.
.PP
erfc processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bessj0"
.IX Subsection "bessj0"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The regular Bessel function of the first kind, J_n Works inplace.
.PP
bessj0 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bessj1"
.IX Subsection "bessj1"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The regular Bessel function of the first kind, J_n Works inplace.
.PP
bessj1 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bessy0"
.IX Subsection "bessy0"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The regular Bessel function of the second kind, Y_n. Works inplace.
.PP
bessy0 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bessy1"
.IX Subsection "bessy1"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The regular Bessel function of the second kind, Y_n. Works inplace.
.PP
bessy1 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bessjn"
.IX Subsection "bessjn"
.Vb 1
\&  Signature: (a(); int n(); [o]b())
.Ve
.PP
The regular Bessel function of the first kind, J_n
\&.
This takes a second int argument which gives the order
of the function required.
 Works inplace.
.PP
bessjn processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bessyn"
.IX Subsection "bessyn"
.Vb 1
\&  Signature: (a(); int n(); [o]b())
.Ve
.PP
The regular Bessel function of the first kind, Y_n
\&.
This takes a second int argument which gives the order
of the function required.
 Works inplace.
.PP
bessyn processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "lgamma"
.IX Subsection "lgamma"
.Vb 1
\&  Signature: (a(); [o]b(); int[o]s())
.Ve
.PP
log gamma function
.PP
This returns 2 ndarrays \*(-- the first set gives the log(gamma) values,
while the second set, of integer values, gives the sign of the gamma
function.  This is useful for determining factorials, amongst other
things.
.PP
lgamma processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "isfinite"
.IX Subsection "isfinite"
.Vb 1
\&  Signature: (a(); int [o]mask())
.Ve
.PP
Sets \f(CW$mask\fR true if \f(CW$a\fR is not a \f(CW\*(C`NaN\*(C'\fR or \f(CW\*(C`inf\*(C'\fR (either positive or negative). Works inplace.
.PP
Bad values are treated as \f(CW\*(C`NaN\*(C'\fR or \f(CW\*(C`inf\*(C'\fR.
.SS "erfi"
.IX Subsection "erfi"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The inverse of the error function. Works inplace.
.PP
erfi processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "ndtri"
.IX Subsection "ndtri"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
The value for which the area under the
Gaussian probability density function (integrated from
minus infinity) is equal to the argument (cf \*(L"erfi\*(R"). Works inplace.
.PP
ndtri processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "polyroots"
.IX Subsection "polyroots"
.Vb 1
\&  Signature: (cr(n); ci(n); [o]rr(m); [o]ri(m))
.Ve
.PP
Complex roots of a complex polynomial, given coefficients in order
of decreasing powers.
.PP
.Vb 1
\& ($rr, $ri) = polyroots($cr, $ci);
.Ve
.PP
polyroots does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SH "BUGS"
.IX Header "BUGS"
Hasn't been tested on all platforms to ensure Cephes
versions are picked up automatically and used correctly.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) R.J.R. Williams 1997 (rjrw@ast.leeds.ac.uk), Karl Glazebrook
(kgb@aaoepp.aao.gov.au) and Tuomas J. Lukka (Tuomas.Lukka@helsinki.fi).
Portions (C) Craig DeForest 2002 (deforest@boulder.swri.edu).
.PP
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution,
the \s-1PDL\s0 copyright notice should be included in the file.
