.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Primitive 3"
.TH Primitive 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Primitive \- primitive operations for pdl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides some primitive and useful functions defined
using \s-1PDL::PP\s0 and able to use the new indexing tricks.
.PP
See PDL::Indexing for how to use indices creatively.
For explanation of the signature format, see \s-1PDL::PP\s0.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # Pulls in PDL::Primitive, among other modules.
\& use PDL;
\&
\& # Only pull in PDL::Primitive:
\& use PDL::Primitive;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "inner"
.IX Subsection "inner"
.Vb 1
\&  Signature: (a(n); b(n); [o]c())
.Ve
.PP
Inner product over one dimension
.PP
.Vb 1
\& c = sum_i a_i * b_i
.Ve
.PP
If \f(CW\*(C`a() * b()\*(C'\fR contains only bad data,
\&\f(CW\*(C`c()\*(C'\fR is set bad. Otherwise \f(CW\*(C`c()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "outer"
.IX Subsection "outer"
.Vb 1
\&  Signature: (a(n); b(m); [o]c(n,m))
.Ve
.PP
outer product over one dimension
.PP
Naturally, it is possible to achieve the effects of outer
product simply by broadcasting over the "\f(CW\*(C`*\*(C'\fR"
operator but this function is provided for convenience.
.PP
outer processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "x"
.IX Subsection "x"
.Vb 1
\& Signature: (a(i,z), b(x,i),[o]c(x,z))
.Ve
.PP
Matrix multiplication
.PP
\&\s-1PDL\s0 overloads the \f(CW\*(C`x\*(C'\fR operator (normally the repeat operator) for
matrix multiplication.  The number of columns (size of the 0
dimension) in the left-hand argument must normally equal the number of
rows (size of the 1 dimension) in the right-hand argument.
.PP
Row vectors are represented as (N x 1) two-dimensional PDLs, or you
may be sloppy and use a one-dimensional \s-1PDL.\s0  Column vectors are
represented as (1 x N) two-dimensional PDLs.
.PP
Broadcasting occurs in the usual way, but as both the 0 and 1 dimension
(if present) are included in the operation, you must be sure that
you don't try to broadcast over either of those dims.
.PP
Of note, due to how Perl v5.14.0 and above implement operator overloading of
the \f(CW\*(C`x\*(C'\fR operator, the use of parentheses for the left operand creates a list
context, that is
.PP
.Vb 2
\& pdl> ( $x * $y ) x $z
\& ERROR: Argument "..." isn\*(Aqt numeric in repeat (x) ...
.Ve
.PP
treats \f(CW$z\fR as a numeric count for the list repeat operation and does not call
the scalar form of the overloaded operator. To use the operator in this case,
use a scalar context:
.PP
.Vb 1
\& pdl> scalar( $x * $y ) x $z
.Ve
.PP
or by calling \*(L"matmult\*(R" directly:
.PP
.Vb 1
\& pdl> ( $x * $y )\->matmult( $z )
.Ve
.PP
\&\s-1EXAMPLES\s0
.PP
Here are some simple ways to define vectors and matrices:
.PP
.Vb 4
\& pdl> $r = pdl(1,2);                # A row vector
\& pdl> $c = pdl([[3],[4]]);          # A column vector
\& pdl> $c = pdl(3,4)\->(*1);          # A column vector, using NiceSlice
\& pdl> $m = pdl([[1,2],[3,4]]);      # A 2x2 matrix
.Ve
.PP
Now that we have a few objects prepared, here is how to
matrix-multiply them:
.PP
.Vb 4
\& pdl> print $r x $m                 # row x matrix = row
\& [
\&  [ 7 10]
\& ]
\&
\& pdl> print $m x $r                 # matrix x row = ERROR
\& PDL: Dim mismatch in matmult of [2x2] x [2x1]: 2 != 1
\&
\& pdl> print $m x $c                 # matrix x column = column
\& [
\&  [ 5]
\&  [11]
\& ]
\&
\& pdl> print $m x 2                  # Trivial case: scalar mult.
\& [
\&  [2 4]
\&  [6 8]
\& ]
\&
\& pdl> print $r x $c                 # row x column = scalar
\& [
\&  [11]
\& ]
\&
\& pdl> print $c x $r                 # column x row = matrix
\& [
\&  [3 6]
\&  [4 8]
\& ]
.Ve
.PP
\&\s-1INTERNALS\s0
.PP
The mechanics of the multiplication are carried out by the
\&\*(L"matmult\*(R" method.
.SS "matmult"
.IX Subsection "matmult"
.Vb 1
\&  Signature: (a(t,h); b(w,t); [o]c(w,h))
.Ve
.PP
Matrix multiplication
.PP
Notionally, matrix multiplication \f(CW$x\fR x \f(CW$y\fR is equivalent to the
broadcasting expression
.PP
.Vb 1
\&    $x\->dummy(1)\->inner($y\->xchg(0,1)\->dummy(2),$c);
.Ve
.PP
but for large matrices that breaks \s-1CPU\s0 cache and is slow.  Instead,
matmult calculates its result in 32x32x32 tiles, to keep the memory
footprint within cache as long as possible on most modern CPUs.
.PP
For usage, see \*(L"x\*(R", a description of the overloaded 'x' operator
.PP
matmult ignores the bad-value flag of the input ndarrays.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "innerwt"
.IX Subsection "innerwt"
.Vb 1
\&  Signature: (a(n); b(n); c(n); [o]d())
.Ve
.PP
Weighted (i.e. triple) inner product
.PP
.Vb 1
\& d = sum_i a(i) b(i) c(i)
.Ve
.PP
innerwt processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "inner2"
.IX Subsection "inner2"
.Vb 1
\&  Signature: (a(n); b(n,m); c(m); [o]d())
.Ve
.PP
Inner product of two vectors and a matrix
.PP
.Vb 1
\& d = sum_ij a(i) b(i,j) c(j)
.Ve
.PP
Note that you should probably not broadcast over \f(CW\*(C`a\*(C'\fR and \f(CW\*(C`c\*(C'\fR since that would be
very wasteful. Instead, you should use a temporary for \f(CW\*(C`b*c\*(C'\fR.
.PP
inner2 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "inner2d"
.IX Subsection "inner2d"
.Vb 1
\&  Signature: (a(n,m); b(n,m); [o]c())
.Ve
.PP
Inner product over 2 dimensions.
.PP
Equivalent to
.PP
.Vb 1
\& $c = inner($x\->clump(2), $y\->clump(2))
.Ve
.PP
inner2d processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "inner2t"
.IX Subsection "inner2t"
.Vb 1
\&  Signature: (a(j,n); b(n,m); c(m,k); [t]tmp(n,k); [o]d(j,k)))
.Ve
.PP
Efficient Triple matrix product \f(CW\*(C`a*b*c\*(C'\fR
.PP
Efficiency comes from by using the temporary \f(CW\*(C`tmp\*(C'\fR. This operation only
scales as \f(CW\*(C`N**3\*(C'\fR whereas broadcasting using \*(L"inner2\*(R" would scale
as \f(CW\*(C`N**4\*(C'\fR.
.PP
The reason for having this routine is that you do not need to
have the same broadcast-dimensions for \f(CW\*(C`tmp\*(C'\fR as for the other arguments,
which in case of large numbers of matrices makes this much more
memory-efficient.
.PP
It is hoped that things like this could be taken care of as a kind of
closures at some point.
.PP
inner2t processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "crossp"
.IX Subsection "crossp"
.Vb 1
\&  Signature: (a(tri=3); b(tri); [o] c(tri))
.Ve
.PP
Cross product of two 3D vectors
.PP
After
.PP
.Vb 1
\& $c = crossp $x, $y
.Ve
.PP
the inner product \f(CW\*(C`$c*$x\*(C'\fR and \f(CW\*(C`$c*$y\*(C'\fR will be zero, i.e. \f(CW$c\fR is
orthogonal to \f(CW$x\fR and \f(CW$y\fR
.PP
crossp does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "norm"
.IX Subsection "norm"
.Vb 1
\&  Signature: (vec(n); [o] norm(n))
.Ve
.PP
Normalises a vector to unit Euclidean length
.PP
norm processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "indadd"
.IX Subsection "indadd"
.Vb 1
\&  Signature: (input(n); indx ind(n); [io] sum(m))
.Ve
.PP
Broadcasting index add: add \f(CW\*(C`input\*(C'\fR to the \f(CW\*(C`ind\*(C'\fR element of \f(CW\*(C`sum\*(C'\fR, i.e:
.PP
.Vb 1
\& sum(ind) += input
.Ve
.PP
Simple example:
.PP
.Vb 7
\&  $x = 2;
\&  $ind = 3;
\&  $sum = zeroes(10);
\&  indadd($x,$ind, $sum);
\&  print $sum
\&  #Result: ( 2 added to element 3 of $sum)
\&  # [0 0 0 2 0 0 0 0 0 0]
.Ve
.PP
Broadcasting example:
.PP
.Vb 7
\&  $x = pdl( 1,2,3);
\&  $ind = pdl( 1,4,6);
\&  $sum = zeroes(10);
\&  indadd($x,$ind, $sum);
\&  print $sum."\en";
\&  #Result: ( 1, 2, and 3 added to elements 1,4,6 $sum)
\&  # [0 1 0 0 2 0 3 0 0 0]
.Ve
.PP
The routine barfs on bad indices, and bad inputs set target outputs bad.
.SS "conv1d"
.IX Subsection "conv1d"
.Vb 1
\&  Signature: (a(m); kern(p); [o]b(m); int reflect)
.Ve
.PP
1D convolution along first dimension
.PP
The m\-th element of the discrete convolution of an input ndarray
\&\f(CW$a\fR of size \f(CW$M\fR, and a kernel ndarray \f(CW$kern\fR of size \f(CW$P\fR, is
calculated as
.PP
.Vb 7
\&                              n = ($P\-1)/2
\&                              ====
\&                              \e
\&  ($a conv1d $kern)[m]   =     >      $a_ext[m \- n] * $kern[n]
\&                              /
\&                              ====
\&                              n = \-($P\-1)/2
.Ve
.PP
where \f(CW$a_ext\fR is either the periodic (or reflected) extension of
\&\f(CW$a\fR so it is equal to \f(CW$a\fR on \f(CW\*(C` 0..$M\-1 \*(C'\fR and equal to the
corresponding periodic/reflected image of \f(CW$a\fR outside that range.
.PP
.Vb 1
\&  $con = conv1d sequence(10), pdl(\-1,0,1);
\&
\&  $con = conv1d sequence(10), pdl(\-1,0,1), {Boundary => \*(Aqreflect\*(Aq};
.Ve
.PP
By default, periodic boundary conditions are assumed (i.e. wrap around).
Alternatively, you can request reflective boundary conditions using
the \f(CW\*(C`Boundary\*(C'\fR option:
.PP
.Vb 1
\&  {Boundary => \*(Aqreflect\*(Aq} # case in \*(Aqreflect\*(Aq doesn\*(Aqt matter
.Ve
.PP
The convolution is performed along the first dimension. To apply it across
another dimension use the slicing routines, e.g.
.PP
.Vb 1
\&  $y = $x\->mv(2,0)\->conv1d($kernel)\->mv(0,2); # along third dim
.Ve
.PP
This function is useful for broadcasted filtering of 1D signals.
.PP
Compare also conv2d, convolve,
fftconvolve, fftwconv,
rfftwconv
.PP
\&\s-1WARNING:\s0 \f(CW\*(C`conv1d\*(C'\fR processes bad values in its inputs as
the numeric value of \f(CW\*(C`$pdl\->badvalue\*(C'\fR so it is not
recommended for processing pdls with bad values in them
unless special care is taken.
.PP
conv1d ignores the bad-value flag of the input ndarrays.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "in"
.IX Subsection "in"
.Vb 1
\&  Signature: (a(); b(n); [o] c())
.Ve
.PP
test if a is in the set of values b
.PP
.Vb 3
\&   $goodmsk = $labels\->in($goodlabels);
\&   print pdl(3,1,4,6,2)\->in(pdl(2,3,3));
\&  [1 0 0 0 1]
.Ve
.PP
\&\f(CW\*(C`in\*(C'\fR is akin to the \fIis an element of\fR of set theory. In principle,
\&\s-1PDL\s0 broadcasting could be used to achieve its functionality by using a
construct like
.PP
.Vb 1
\&   $msk = ($labels\->dummy(0) == $goodlabels)\->orover;
.Ve
.PP
However, \f(CW\*(C`in\*(C'\fR doesn't create a (potentially large) intermediate
and is generally faster.
.PP
in does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "uniq"
.IX Subsection "uniq"
return all unique elements of an ndarray
.PP
The unique elements are returned in ascending order.
.PP
.Vb 2
\&  PDL> p pdl(2,2,2,4,0,\-1,6,6)\->uniq
\&  [\-1 0 2 4 6]     # 0 is returned 2nd (sorted order)
\&
\&  PDL> p pdl(2,2,2,4,nan,\-1,6,6)\->uniq
\&  [\-1 2 4 6 nan]   # NaN value is returned at end
.Ve
.PP
Note: The returned pdl is 1D; any structure of the input
ndarray is lost.  \f(CW\*(C`NaN\*(C'\fR values are never compare equal to
any other values, even themselves.  As a result, they are
always unique. \f(CW\*(C`uniq\*(C'\fR returns the NaN values at the end
of the result ndarray.  This follows the Matlab usage.
.PP
See \*(L"uniqind\*(R" if you need the indices of the unique
elements rather than the values.
.PP
Bad values are not considered unique by uniq and are ignored.
.PP
.Vb 4
\& $x=sequence(10);
\& $x=$x\->setbadif($x%3);
\& print $x\->uniq;
\& [0 3 6 9]
.Ve
.SS "uniqind"
.IX Subsection "uniqind"
Return the indices of all unique elements of an ndarray
The order is in the order of the values to be consistent
with uniq. \f(CW\*(C`NaN\*(C'\fR values never compare equal with any
other value and so are always unique.  This follows the
Matlab usage.
.PP
.Vb 2
\&  PDL> p pdl(2,2,2,4,0,\-1,6,6)\->uniqind
\&  [5 4 1 3 6]     # the 0 at index 4 is returned 2nd, but...
\&
\&  PDL> p pdl(2,2,2,4,nan,\-1,6,6)\->uniqind
\&  [5 1 3 6 4]     # ...the NaN at index 4 is returned at end
.Ve
.PP
Note: The returned pdl is 1D; any structure of the input
ndarray is lost.
.PP
See \*(L"uniq\*(R" if you want the unique values instead of the
indices.
.PP
Bad values are not considered unique by uniqind and are ignored.
.SS "uniqvec"
.IX Subsection "uniqvec"
Return all unique vectors out of a collection
.PP
.Vb 4
\&  NOTE: If any vectors in the input ndarray have NaN values
\&  they are returned at the end of the non\-NaN ones.  This is
\&  because, by definition, NaN values never compare equal with
\&  any other value.
\&
\&  NOTE: The current implementation does not sort the vectors
\&  containing NaN values.
.Ve
.PP
The unique vectors are returned in lexicographically sorted
ascending order. The 0th dimension of the input \s-1PDL\s0 is treated
as a dimensional index within each vector, and the 1st and any
higher dimensions are taken to run across vectors. The return
value is always 2D; any structure of the input \s-1PDL\s0 (beyond using
the 0th dimension for vector index) is lost.
.PP
See also \*(L"uniq\*(R" for a unique list of scalars; and
qsortvec for sorting a list of vectors
lexicographcally.
.PP
If a vector contains all bad values, it is ignored as in \*(L"uniq\*(R".
If some of the values are good, it is treated as a normal vector. For
example, [1 2 \s-1BAD\s0] and [\s-1BAD 2 3\s0] could be returned, but [\s-1BAD BAD BAD\s0]
could not.  Vectors containing \s-1BAD\s0 values will be returned after any
non-NaN and non-BAD containing vectors, followed by the NaN vectors.
.SS "hclip"
.IX Subsection "hclip"
.Vb 1
\&  Signature: (a(); b(); [o] c())
.Ve
.PP
clip (threshold) \f(CW$a\fR by \f(CW$b\fR (\f(CW$b\fR is upper bound)
.PP
hclip processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "lclip"
.IX Subsection "lclip"
.Vb 1
\&  Signature: (a(); b(); [o] c())
.Ve
.PP
clip (threshold) \f(CW$a\fR by \f(CW$b\fR (\f(CW$b\fR is lower bound)
.PP
lclip processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "clip"
.IX Subsection "clip"
Clip (threshold) an ndarray by (optional) upper or lower bounds.
.PP
.Vb 2
\& $y = $x\->clip(0,3);
\& $c = $x\->clip(undef, $x);
.Ve
.PP
clip handles bad values since it is just a
wrapper around \*(L"hclip\*(R" and
\&\*(L"lclip\*(R".
.SS "clip"
.IX Subsection "clip"
.Vb 1
\&  Signature: (a(); l(); h(); [o] c())
.Ve
.PP
info not available
.PP
clip processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "wtstat"
.IX Subsection "wtstat"
.Vb 1
\&  Signature: (a(n); wt(n); avg(); [o]b(); int deg)
.Ve
.PP
Weighted statistical moment of given degree
.PP
This calculates a weighted statistic over the vector \f(CW\*(C`a\*(C'\fR.
The formula is
.PP
.Vb 1
\& b() = (sum_i wt_i * (a_i ** degree \- avg)) / (sum_i wt_i)
.Ve
.PP
Bad values are ignored in any calculation; \f(CW$b\fR will only
have its bad flag set if the output contains any bad data.
.SS "statsover"
.IX Subsection "statsover"
.Vb 1
\&  Signature: (a(n); w(n); float+ [o]avg(); float+ [o]prms(); int+ [o]median(); int+ [o]min(); int+ [o]max(); float+ [o]adev(); float+ [o]rms())
.Ve
.PP
Calculate useful statistics over a dimension of an ndarray
.PP
.Vb 1
\&  ($mean,$prms,$median,$min,$max,$adev,$rms) = statsover($ndarray, $weights);
.Ve
.PP
This utility function calculates various useful
quantities of an ndarray. These are:
.IP "\(bu" 3
the mean:
.Sp
.Vb 1
\&  MEAN = sum (x)/ N
.Ve
.Sp
with \f(CW\*(C`N\*(C'\fR being the number of elements in x
.IP "\(bu" 3
the population \s-1RMS\s0 deviation from the mean:
.Sp
.Vb 1
\&  PRMS = sqrt( sum( (x\-mean(x))^2 )/(N\-1)
.Ve
.Sp
The population deviation is the best-estimate of the deviation
of the population from which a sample is drawn.
.IP "\(bu" 3
the median
.Sp
The median is the 50th percentile data value.  Median is found by
medover, so \s-1WEIGHTING IS IGNORED FOR THE MEDIAN CALCULATION.\s0
.IP "\(bu" 3
the minimum
.IP "\(bu" 3
the maximum
.IP "\(bu" 3
the average absolute deviation:
.Sp
.Vb 1
\&  AADEV = sum( abs(x\-mean(x)) )/N
.Ve
.IP "\(bu" 3
\&\s-1RMS\s0 deviation from the mean:
.Sp
.Vb 1
\&  RMS = sqrt(sum( (x\-mean(x))^2 )/N)
.Ve
.Sp
(also known as the root-mean-square deviation, or the square root of the
variance)
.PP
This operator is a projection operator so the calculation
will take place over the final dimension. Thus if the input
is N\-dimensional each returned value will be N\-1 dimensional,
to calculate the statistics for the entire ndarray either
use \f(CW\*(C`clump(\-1)\*(C'\fR directly on the ndarray or call \f(CW\*(C`stats\*(C'\fR.
.PP
Bad values are simply ignored in the calculation, effectively reducing
the sample size.  If all data are bad then the output data are marked bad.
.SS "stats"
.IX Subsection "stats"
Calculates useful statistics on an ndarray
.PP
.Vb 1
\& ($mean,$prms,$median,$min,$max,$adev,$rms) = stats($ndarray,[$weights]);
.Ve
.PP
This utility calculates all the most useful quantities in one call.
It works the same way as \*(L"statsover\*(R", except that the quantities are
calculated considering the entire input \s-1PDL\s0 as a single sample, rather
than as a collection of rows. See \*(L"statsover\*(R" for definitions of the
returned quantities.
.PP
Bad values are handled; if all input values are bad, then all of the output
values are flagged bad.
.SS "histogram"
.IX Subsection "histogram"
.Vb 1
\&  Signature: (in(n); int+[o] hist(m); double step; double min; int msize => m)
.Ve
.PP
Calculates a histogram for given stepsize and minimum.
.PP
.Vb 3
\& $h = histogram($data, $step, $min, $numbins);
\& $hist = zeroes $numbins;  # Put histogram in existing ndarray.
\& histogram($data, $hist, $step, $min, $numbins);
.Ve
.PP
The histogram will contain \f(CW$numbins\fR bins starting from \f(CW$min\fR, each
\&\f(CW$step\fR wide. The value in each bin is the number of
values in \f(CW$data\fR that lie within the bin limits.
.PP
Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.
.PP
The output is reset in a different broadcastloop so that you
can take a histogram of \f(CW\*(C`$a(10,12)\*(C'\fR into \f(CW\*(C`$b(15)\*(C'\fR and get the result
you want.
.PP
For a higher-level interface, see hist.
.PP
.Vb 2
\& pdl> p histogram(pdl(1,1,2),1,0,3)
\& [0 2 1]
.Ve
.PP
histogram processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "whistogram"
.IX Subsection "whistogram"
.Vb 1
\&  Signature: (in(n); float+ wt(n);float+[o] hist(m); double step; double min; int msize => m)
.Ve
.PP
Calculates a histogram from weighted data for given stepsize and minimum.
.PP
.Vb 3
\& $h = whistogram($data, $weights, $step, $min, $numbins);
\& $hist = zeroes $numbins;  # Put histogram in existing ndarray.
\& whistogram($data, $weights, $hist, $step, $min, $numbins);
.Ve
.PP
The histogram will contain \f(CW$numbins\fR bins starting from \f(CW$min\fR, each
\&\f(CW$step\fR wide. The value in each bin is the sum of the values in \f(CW$weights\fR
that correspond to values in \f(CW$data\fR that lie within the bin limits.
.PP
Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.
.PP
The output is reset in a different broadcastloop so that you
can take a histogram of \f(CW\*(C`$a(10,12)\*(C'\fR into \f(CW\*(C`$b(15)\*(C'\fR and get the result
you want.
.PP
.Vb 2
\& pdl> p whistogram(pdl(1,1,2), pdl(0.1,0.1,0.5), 1, 0, 4)
\& [0 0.2 0.5 0]
.Ve
.PP
whistogram processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "histogram2d"
.IX Subsection "histogram2d"
.Vb 2
\&  Signature: (ina(n); inb(n); int+[o] hist(ma,mb); double stepa; double mina; int masize => ma;
\&                     double stepb; double minb; int mbsize => mb;)
.Ve
.PP
Calculates a 2d histogram.
.PP
.Vb 5
\& $h = histogram2d($datax, $datay, $stepx, $minx,
\&       $nbinx, $stepy, $miny, $nbiny);
\& $hist = zeroes $nbinx, $nbiny;  # Put histogram in existing ndarray.
\& histogram2d($datax, $datay, $hist, $stepx, $minx,
\&       $nbinx, $stepy, $miny, $nbiny);
.Ve
.PP
The histogram will contain \f(CW$nbinx\fR x \f(CW$nbiny\fR bins, with the lower
limits of the first one at \f(CW\*(C`($minx, $miny)\*(C'\fR, and with bin size
\&\f(CW\*(C`($stepx, $stepy)\*(C'\fR.
The value in each bin is the number of
values in \f(CW$datax\fR and \f(CW$datay\fR that lie within the bin limits.
.PP
Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.
.PP
.Vb 6
\& pdl> p histogram2d(pdl(1,1,1,2,2),pdl(2,1,1,1,1),1,0,3,1,0,3)
\& [
\&  [0 0 0]
\&  [0 2 2]
\&  [0 1 0]
\& ]
.Ve
.PP
histogram2d processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "whistogram2d"
.IX Subsection "whistogram2d"
.Vb 2
\&  Signature: (ina(n); inb(n); float+ wt(n);float+[o] hist(ma,mb); double stepa; double mina; int masize => ma;
\&                     double stepb; double minb; int mbsize => mb;)
.Ve
.PP
Calculates a 2d histogram from weighted data.
.PP
.Vb 5
\& $h = whistogram2d($datax, $datay, $weights,
\&       $stepx, $minx, $nbinx, $stepy, $miny, $nbiny);
\& $hist = zeroes $nbinx, $nbiny;  # Put histogram in existing ndarray.
\& whistogram2d($datax, $datay, $weights, $hist,
\&       $stepx, $minx, $nbinx, $stepy, $miny, $nbiny);
.Ve
.PP
The histogram will contain \f(CW$nbinx\fR x \f(CW$nbiny\fR bins, with the lower
limits of the first one at \f(CW\*(C`($minx, $miny)\*(C'\fR, and with bin size
\&\f(CW\*(C`($stepx, $stepy)\*(C'\fR.
The value in each bin is the sum of the values in
\&\f(CW$weights\fR that correspond to values in \f(CW$datax\fR and \f(CW$datay\fR that lie within the bin limits.
.PP
Data below the lower limit is put in the first bin, and data above the
upper limit is put in the last bin.
.PP
.Vb 6
\& pdl> p whistogram2d(pdl(1,1,1,2,2),pdl(2,1,1,1,1),pdl(0.1,0.2,0.3,0.4,0.5),1,0,3,1,0,3)
\& [
\&  [  0   0   0]
\&  [  0 0.5 0.9]
\&  [  0 0.1   0]
\& ]
.Ve
.PP
whistogram2d processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "fibonacci"
.IX Subsection "fibonacci"
.Vb 1
\&  Signature: (i(n); indx [o]x(n))
.Ve
.PP
Constructor \- a vector with Fibonacci's sequence
.PP
fibonacci does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "append"
.IX Subsection "append"
.Vb 1
\&  Signature: (a(n); b(m); [o] c(mn))
.Ve
.PP
append two ndarrays by concatenating along their first dimensions
.PP
.Vb 3
\& $x = ones(2,4,7);
\& $y = sequence 5;
\& $c = $x\->append($y);  # size of $c is now (7,4,7) (a jumbo\-ndarray ;)
.Ve
.PP
\&\f(CW\*(C`append\*(C'\fR appends two ndarrays along their first dimensions. The rest of the
dimensions must be compatible in the broadcasting sense. The resulting
size of the first dimension is the sum of the sizes of the first dimensions
of the two argument ndarrays \- i.e. \f(CW\*(C`n + m\*(C'\fR.
.PP
Similar functions include \*(L"glue\*(R" (below), which can append more
than two ndarrays along an arbitrary dimension, and
cat, which can append more than two ndarrays that all
have the same sized dimensions.
.PP
append does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "glue"
.IX Subsection "glue"
.Vb 1
\&  $c = $x\->glue(<dim>,$y,...)
.Ve
.PP
Glue two or more PDLs together along an arbitrary dimension
(N\-D \*(L"append\*(R").
.PP
Sticks \f(CW$x\fR, \f(CW$y\fR, and all following arguments together along the
specified dimension.  All other dimensions must be compatible in the
broadcasting sense.
.PP
Glue is permissive, in the sense that every \s-1PDL\s0 is treated as having an
infinite number of trivial dimensions of order 1 \*(-- so \f(CW\*(C`$x\->glue(3,$y)\*(C'\fR
works, even if \f(CW$x\fR and \f(CW$y\fR are only one dimensional.
.PP
If one of the PDLs has no elements, it is ignored.  Likewise, if one
of them is actually the undefined value, it is treated as if it had no
elements.
.PP
If the first parameter is a defined perl scalar rather than a pdl,
then it is taken as a dimension along which to glue everything else,
so you can say \f(CW\*(C`$cube = PDL::glue(3,@image_list);\*(C'\fR if you like.
.PP
\&\f(CW\*(C`glue\*(C'\fR is implemented in pdl, using a combination of xchg and
\&\*(L"append\*(R".  It should probably be updated (one day) to a pure \s-1PP\s0
function.
.PP
Similar functions include \*(L"append\*(R" (above), which appends
only two ndarrays along their first dimension, and
cat, which can append more than two ndarrays that all
have the same sized dimensions.
.SS "cmpvec"
.IX Subsection "cmpvec"
.Vb 1
\&  Signature: (a(n); b(n); sbyte [o]c())
.Ve
.PP
Compare two vectors lexicographically.
.PP
Returns \-1 if a is less, 1 if greater, 0 if equal.
.PP
The output is bad if any input values up to the point of inequality are
bad \- any after are ignored.
.SS "eqvec"
.IX Subsection "eqvec"
.Vb 1
\&  Signature: (a(n); b(n); sbyte [o]c())
.Ve
.PP
Compare two vectors, returning 1 if equal, 0 if not equal.
.PP
The output is bad if any input values are bad.
.SS "enumvec"
.IX Subsection "enumvec"
.Vb 1
\&  Signature: (v(M,N); indx [o]k(N))
.Ve
.PP
Enumerate a list of vectors with locally unique keys.
.PP
Given a sorted list of vectors \f(CW$v\fR, generate a vector \f(CW$k\fR containing locally unique keys for the elements of \f(CW$v\fR
(where an \*(L"element\*(R" is a vector of length \f(CW$M\fR ocurring in \f(CW$v\fR).
.PP
Note that the keys returned in \f(CW$k\fR are only unique over a run of a single vector in \f(CW$v\fR,
so that each unique vector in \f(CW$v\fR has at least one 0 (zero) index in \f(CW$k\fR associated with it.
If you need global keys, see \fBenumvecg()\fR.
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
enumvec does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "enumvecg"
.IX Subsection "enumvecg"
.Vb 1
\&  Signature: (v(M,N); indx [o]k(N))
.Ve
.PP
Enumerate a list of vectors with globally unique keys.
.PP
Given a sorted list of vectors \f(CW$v\fR, generate a vector \f(CW$k\fR containing globally unique keys for the elements of \f(CW$v\fR
(where an \*(L"element\*(R" is a vector of length \f(CW$M\fR ocurring in \f(CW$v\fR).
Basically does the same thing as:
.PP
.Vb 1
\& $k = $v\->vsearchvec($v\->uniqvec);
.Ve
.PP
\&... but somewhat more efficiently.
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
enumvecg does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "vsearchvec"
.IX Subsection "vsearchvec"
.Vb 1
\&  Signature: (find(M); which(M,N); indx [o]found())
.Ve
.PP
Routine for searching N\-dimensional values \- akin to \fBvsearch()\fR for vectors.
.PP
.Vb 2
\& $found   = vsearchvec($find, $which);
\& $nearest = $which\->dice_axis(1,$found);
.Ve
.PP
Returns for each row-vector in \f(CW$find\fR the index along dimension N
of the least row vector of \f(CW$which\fR
greater or equal to it.
\&\f(CW$which\fR should be sorted in increasing order.
If the value of \f(CW$find\fR is larger
than any member of \f(CW$which\fR, the index to the last element of \f(CW$which\fR is
returned.
.PP
See also: \*(L"vsearch\*(R".
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
vsearchvec does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "unionvec"
.IX Subsection "unionvec"
.Vb 1
\&  Signature: (a(M,NA); b(M,NB); [o]c(M,NC); indx [o]nc())
.Ve
.PP
Union of two vector-valued PDLs.
.PP
Input PDLs $a() and $b() \fB\s-1MUST\s0\fR be sorted in lexicographic order.
On return, $\fBnc()\fR holds the actual number of vector-values in the union.
.PP
In scalar context, slices $c() to the actual number of elements in the union
and returns the sliced \s-1PDL.\s0
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
unionvec does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "intersectvec"
.IX Subsection "intersectvec"
.Vb 1
\&  Signature: (a(M,NA); b(M,NB); [o]c(M,NC); indx [o]nc())
.Ve
.PP
Intersection of two vector-valued PDLs.
Input PDLs $a() and $b() \fB\s-1MUST\s0\fR be sorted in lexicographic order.
On return, $\fBnc()\fR holds the actual number of vector-values in the intersection.
.PP
In scalar context, slices $c() to the actual number of elements in the intersection
and returns the sliced \s-1PDL.\s0
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
intersectvec does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "setdiffvec"
.IX Subsection "setdiffvec"
.Vb 1
\&  Signature: (a(M,NA); b(M,NB); [o]c(M,NC); indx [o]nc())
.Ve
.PP
Set-difference ($a() \e $b()) of two vector-valued PDLs.
.PP
Input PDLs $a() and $b() \fB\s-1MUST\s0\fR be sorted in lexicographic order.
On return, $\fBnc()\fR holds the actual number of vector-values in the computed vector set.
.PP
In scalar context, slices $c() to the actual number of elements in the output vector set
and returns the sliced \s-1PDL.\s0
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
setdiffvec does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "union_sorted"
.IX Subsection "union_sorted"
.Vb 1
\&  Signature: (a(NA); b(NB); [o]c(NC); indx [o]nc())
.Ve
.PP
Union of two flat sorted unique-valued PDLs.
Input PDLs $a() and $b() \fB\s-1MUST\s0\fR be sorted in lexicographic order and contain no duplicates.
On return, $\fBnc()\fR holds the actual number of values in the union.
.PP
In scalar context, reshapes $c() to the actual number of elements in the union and returns it.
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
union_sorted does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "intersect_sorted"
.IX Subsection "intersect_sorted"
.Vb 1
\&  Signature: (a(NA); b(NB); [o]c(NC); indx [o]nc())
.Ve
.PP
Intersection of two flat sorted unique-valued PDLs.
Input PDLs $a() and $b() \fB\s-1MUST\s0\fR be sorted in lexicographic order and contain no duplicates.
On return, $\fBnc()\fR holds the actual number of values in the intersection.
.PP
In scalar context, reshapes $c() to the actual number of elements in the intersection and returns it.
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
intersect_sorted does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "setdiff_sorted"
.IX Subsection "setdiff_sorted"
.Vb 1
\&  Signature: (a(NA); b(NB); [o]c(NC); indx [o]nc())
.Ve
.PP
Set-difference ($a() \e $b()) of two flat sorted unique-valued PDLs.
.PP
Input PDLs $a() and $b() \fB\s-1MUST\s0\fR be sorted in lexicographic order and contain no duplicate values.
On return, $\fBnc()\fR holds the actual number of values in the computed vector set.
.PP
In scalar context, reshapes $c() to the actual number of elements in the difference set and returns it.
.PP
Contributed by Bryan Jurish <moocow@cpan.org>.
.PP
setdiff_sorted does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "srand"
.IX Subsection "srand"
.Vb 1
\&  Signature: (a())
.Ve
.PP
Seed random-number generator with a 64\-bit int. Will generate seed data
for a number of threads equal to the return-value of
\&\*(L"online_cpus\*(R" in PDL::Core.
.PP
.Vb 2
\& srand(); # uses current time
\& srand(5); # fixed number e.g. for testing
.Ve
.PP
srand does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "random"
.IX Subsection "random"
.Vb 1
\&  Signature: (a())
.Ve
.PP
Constructor which returns ndarray of random numbers
.PP
.Vb 2
\& $x = random([type], $nx, $ny, $nz,...);
\& $x = random $y;
.Ve
.PP
etc (see zeroes).
.PP
This is the uniform distribution between 0 and 1 (assumedly
excluding 1 itself). The arguments are the same as \f(CW\*(C`zeroes\*(C'\fR
(q.v.) \- i.e. one can specify dimensions, types or give
a template.
.PP
You can use the \s-1PDL\s0 function \*(L"srand\*(R" to seed the random generator.
If it has not been called yet, it will be with the current time.
.PP
random does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "randsym"
.IX Subsection "randsym"
.Vb 1
\&  Signature: (a())
.Ve
.PP
Constructor which returns ndarray of random numbers
.PP
.Vb 2
\& $x = randsym([type], $nx, $ny, $nz,...);
\& $x = randsym $y;
.Ve
.PP
etc (see zeroes).
.PP
This is the uniform distribution between 0 and 1 (excluding both 0 and
1, cf \*(L"random\*(R"). The arguments are the same as \f(CW\*(C`zeroes\*(C'\fR (q.v.) \-
i.e. one can specify dimensions, types or give a template.
.PP
You can use the \s-1PDL\s0 function \*(L"srand\*(R" to seed the random generator.
If it has not been called yet, it will be with the current time.
.PP
randsym does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "grandom"
.IX Subsection "grandom"
Constructor which returns ndarray of Gaussian random numbers
.PP
.Vb 2
\& $x = grandom([type], $nx, $ny, $nz,...);
\& $x = grandom $y;
.Ve
.PP
etc (see zeroes).
.PP
This is generated using the math library routine \f(CW\*(C`ndtri\*(C'\fR.
.PP
Mean = 0, Stddev = 1
.PP
You can use the \s-1PDL\s0 function \*(L"srand\*(R" to seed the random generator.
If it has not been called yet, it will be with the current time.
.SS "vsearch"
.IX Subsection "vsearch"
.Vb 1
\&  Signature: ( vals(); xs(n); [o] indx(); [\e%options] )
.Ve
.PP
Efficiently search for values in a sorted ndarray, returning indices.
.PP
.Vb 2
\&  $idx = vsearch( $vals, $x, [\e%options] );
\&  vsearch( $vals, $x, $idx, [\e%options ] );
.Ve
.PP
\&\fBvsearch\fR performs a binary search in the ordered ndarray \f(CW$x\fR,
for the values from \f(CW$vals\fR ndarray, returning indices into \f(CW$x\fR.
What is a \*(L"match\*(R", and the meaning of the returned indices, are determined
by the options.
.PP
The \f(CW\*(C`mode\*(C'\fR option indicates which method of searching to use, and may
be one of:
.ie n .IP """sample""" 4
.el .IP "\f(CWsample\fR" 4
.IX Item "sample"
invoke \fBvsearch_sample\fR, returning indices appropriate for sampling
within a distribution.
.ie n .IP """insert_leftmost""" 4
.el .IP "\f(CWinsert_leftmost\fR" 4
.IX Item "insert_leftmost"
invoke \fBvsearch_insert_leftmost\fR, returning the left-most possible
insertion point which still leaves the ndarray sorted.
.ie n .IP """insert_rightmost""" 4
.el .IP "\f(CWinsert_rightmost\fR" 4
.IX Item "insert_rightmost"
invoke \fBvsearch_insert_rightmost\fR, returning the right-most possible
insertion point which still leaves the ndarray sorted.
.ie n .IP """match""" 4
.el .IP "\f(CWmatch\fR" 4
.IX Item "match"
invoke \fBvsearch_match\fR, returning the index of a matching element,
else \-(insertion point + 1)
.ie n .IP """bin_inclusive""" 4
.el .IP "\f(CWbin_inclusive\fR" 4
.IX Item "bin_inclusive"
invoke \fBvsearch_bin_inclusive\fR, returning an index appropriate for binning
on a grid where the left bin edges are \fIinclusive\fR of the bin. See
below for further explanation of the bin.
.ie n .IP """bin_exclusive""" 4
.el .IP "\f(CWbin_exclusive\fR" 4
.IX Item "bin_exclusive"
invoke \fBvsearch_bin_exclusive\fR, returning an index appropriate for binning
on a grid where the left bin edges are \fIexclusive\fR of the bin. See
below for further explanation of the bin.
.PP
The default value of \f(CW\*(C`mode\*(C'\fR is \f(CW\*(C`sample\*(C'\fR.
.PP
.Vb 1
\&  use PDL;
\&  
\&  my @modes = qw( sample insert_leftmost insert_rightmost match
\&                  bin_inclusive bin_exclusive );
\&  
\&  # Generate a sequence of 3 zeros, 3 ones, ..., 3 fours.
\&  my $x = zeroes(3,5)\->yvals\->flat;
\&  
\&  for my $mode ( @modes ) {
\&    # if the value is in $x
\&    my $contained = 2;
\&    my $idx_contained = vsearch( $contained, $x, { mode => $mode } );
\&    my $x_contained = $x\->copy;
\&    $x_contained\->slice( $idx_contained ) .= 9;
\&    
\&    # if the value is not in $x
\&    my $not_contained = 1.5;
\&    my $idx_not_contained = vsearch( $not_contained, $x, { mode => $mode } );
\&    my $x_not_contained = $x\->copy;
\&    $x_not_contained\->slice( $idx_not_contained ) .= 9;
\&    
\&    print sprintf("%\-23s%30s\en", \*(Aq$x\*(Aq, $x);
\&    print sprintf("%\-23s%30s\en",   "$mode ($contained)", $x_contained);
\&    print sprintf("%\-23s%30s\en\en", "$mode ($not_contained)", $x_not_contained);
\&  }
\&  
\&  # $x                     [0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]
\&  # sample (2)             [0 0 0 1 1 1 9 2 2 3 3 3 4 4 4]
\&  # sample (1.5)           [0 0 0 1 1 1 9 2 2 3 3 3 4 4 4]
\&  # 
\&  # $x                     [0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]
\&  # insert_leftmost (2)    [0 0 0 1 1 1 9 2 2 3 3 3 4 4 4]
\&  # insert_leftmost (1.5)  [0 0 0 1 1 1 9 2 2 3 3 3 4 4 4]
\&  # 
\&  # $x                     [0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]
\&  # insert_rightmost (2)   [0 0 0 1 1 1 2 2 2 9 3 3 4 4 4]
\&  # insert_rightmost (1.5) [0 0 0 1 1 1 9 2 2 3 3 3 4 4 4]
\&  # 
\&  # $x                     [0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]
\&  # match (2)              [0 0 0 1 1 1 2 9 2 3 3 3 4 4 4]
\&  # match (1.5)            [0 0 0 1 1 1 2 2 9 3 3 3 4 4 4]
\&  # 
\&  # $x                     [0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]
\&  # bin_inclusive (2)      [0 0 0 1 1 1 2 2 9 3 3 3 4 4 4]
\&  # bin_inclusive (1.5)    [0 0 0 1 1 9 2 2 2 3 3 3 4 4 4]
\&  # 
\&  # $x                     [0 0 0 1 1 1 2 2 2 3 3 3 4 4 4]
\&  # bin_exclusive (2)      [0 0 0 1 1 9 2 2 2 3 3 3 4 4 4]
\&  # bin_exclusive (1.5)    [0 0 0 1 1 9 2 2 2 3 3 3 4 4 4]
.Ve
.PP
Also see
\&\fBvsearch_sample\fR,
\&\fBvsearch_insert_leftmost\fR,
\&\fBvsearch_insert_rightmost\fR,
\&\fBvsearch_match\fR,
\&\fBvsearch_bin_inclusive\fR, and
\&\fBvsearch_bin_exclusive\fR
.SS "vsearch_sample"
.IX Subsection "vsearch_sample"
.Vb 1
\&  Signature: (vals(); x(n); indx [o]idx())
.Ve
.PP
Search for values in a sorted array, return index appropriate for sampling from a distribution
.PP
.Vb 1
\&  $idx = vsearch_sample($vals, $x);
.Ve
.PP
\&\f(CW$x\fR must be sorted, but may be in decreasing or increasing
order.
.PP
\&\fBvsearch_sample\fR returns an index \fII\fR for each value \fIV\fR of \f(CW$vals\fR appropriate
for sampling \f(CW$vals\fR
.PP
\&\fII\fR has the following properties:
.IP "\(bu" 4
if \f(CW$x\fR is sorted in increasing order
.Sp
.Vb 3
\&          V <= x[0]  : I = 0
\&  x[0]  < V <= x[\-1] : I s.t. x[I\-1] < V <= x[I]
\&  x[\-1] < V          : I = $x\->nelem \-1
.Ve
.IP "\(bu" 4
if \f(CW$x\fR is sorted in decreasing order
.Sp
.Vb 3
\&           V > x[0]  : I = 0
\&  x[0]  >= V > x[\-1] : I s.t. x[I] >= V > x[I+1]
\&  x[\-1] >= V         : I = $x\->nelem \- 1
.Ve
.PP
If all elements of \f(CW$x\fR are equal, \fII = \f(CI$x\fI\->nelem \- 1\fR.
.PP
If \f(CW$x\fR contains duplicated elements, \fII\fR is the index of the
leftmost (by position in array) duplicate if \fIV\fR matches.
.PP
This function is useful e.g. when you have a list of probabilities
for events and want to generate indices to events:
.PP
.Vb 3
\& $x = pdl(.01,.86,.93,1); # Barnsley IFS probabilities cumulatively
\& $y = random 20;
\& $c = vsearch_sample($y, $x); # Now, $c will have the appropriate distr.
.Ve
.PP
It is possible to use the cumusumover
function to obtain cumulative probabilities from absolute probabilities.
.PP
needs major (?) work to handles bad values
.SS "vsearch_insert_leftmost"
.IX Subsection "vsearch_insert_leftmost"
.Vb 1
\&  Signature: (vals(); x(n); indx [o]idx())
.Ve
.PP
Determine the insertion point for values in a sorted array, inserting before duplicates.
.PP
.Vb 1
\&  $idx = vsearch_insert_leftmost($vals, $x);
.Ve
.PP
\&\f(CW$x\fR must be sorted, but may be in decreasing or increasing
order.
.PP
\&\fBvsearch_insert_leftmost\fR returns an index \fII\fR for each value \fIV\fR of
\&\f(CW$vals\fR equal to the leftmost position (by index in array) within
\&\f(CW$x\fR that \fIV\fR may be inserted and still maintain the order in
\&\f(CW$x\fR.
.PP
Insertion at index \fII\fR involves shifting elements \fII\fR and higher of
\&\f(CW$x\fR to the right by one and setting the now empty element at index
\&\fII\fR to \fIV\fR.
.PP
\&\fII\fR has the following properties:
.IP "\(bu" 4
if \f(CW$x\fR is sorted in increasing order
.Sp
.Vb 3
\&          V <= x[0]  : I = 0
\&  x[0]  < V <= x[\-1] : I s.t. x[I\-1] < V <= x[I]
\&  x[\-1] < V          : I = $x\->nelem
.Ve
.IP "\(bu" 4
if \f(CW$x\fR is sorted in decreasing order
.Sp
.Vb 3
\&           V >  x[0]  : I = \-1
\&  x[0]  >= V >= x[\-1] : I s.t. x[I] >= V > x[I+1]
\&  x[\-1] >= V          : I = $x\->nelem \-1
.Ve
.PP
If all elements of \f(CW$x\fR are equal,
.PP
.Vb 1
\&    i = 0
.Ve
.PP
If \f(CW$x\fR contains duplicated elements, \fII\fR is the index of the
leftmost (by index in array) duplicate if \fIV\fR matches.
.PP
needs major (?) work to handles bad values
.SS "vsearch_insert_rightmost"
.IX Subsection "vsearch_insert_rightmost"
.Vb 1
\&  Signature: (vals(); x(n); indx [o]idx())
.Ve
.PP
Determine the insertion point for values in a sorted array, inserting after duplicates.
.PP
.Vb 1
\&  $idx = vsearch_insert_rightmost($vals, $x);
.Ve
.PP
\&\f(CW$x\fR must be sorted, but may be in decreasing or increasing
order.
.PP
\&\fBvsearch_insert_rightmost\fR returns an index \fII\fR for each value \fIV\fR of
\&\f(CW$vals\fR equal to the rightmost position (by index in array) within
\&\f(CW$x\fR that \fIV\fR may be inserted and still maintain the order in
\&\f(CW$x\fR.
.PP
Insertion at index \fII\fR involves shifting elements \fII\fR and higher of
\&\f(CW$x\fR to the right by one and setting the now empty element at index
\&\fII\fR to \fIV\fR.
.PP
\&\fII\fR has the following properties:
.IP "\(bu" 4
if \f(CW$x\fR is sorted in increasing order
.Sp
.Vb 3
\&           V < x[0]  : I = 0
\&  x[0]  <= V < x[\-1] : I s.t. x[I\-1] <= V < x[I]
\&  x[\-1] <= V         : I = $x\->nelem
.Ve
.IP "\(bu" 4
if \f(CW$x\fR is sorted in decreasing order
.Sp
.Vb 3
\&          V >= x[0]  : I = \-1
\&  x[0]  > V >= x[\-1] : I s.t. x[I] >= V > x[I+1]
\&  x[\-1] > V          : I = $x\->nelem \-1
.Ve
.PP
If all elements of \f(CW$x\fR are equal,
.PP
.Vb 1
\&    i = $x\->nelem \- 1
.Ve
.PP
If \f(CW$x\fR contains duplicated elements, \fII\fR is the index of the
leftmost (by index in array) duplicate if \fIV\fR matches.
.PP
needs major (?) work to handles bad values
.SS "vsearch_match"
.IX Subsection "vsearch_match"
.Vb 1
\&  Signature: (vals(); x(n); indx [o]idx())
.Ve
.PP
Match values against a sorted array.
.PP
.Vb 1
\&  $idx = vsearch_match($vals, $x);
.Ve
.PP
\&\f(CW$x\fR must be sorted, but may be in decreasing or increasing
order.
.PP
\&\fBvsearch_match\fR returns an index \fII\fR for each value \fIV\fR of
\&\f(CW$vals\fR.  If \fIV\fR matches an element in \f(CW$x\fR, \fII\fR is the
index of that element, otherwise it is \fI\-( insertion_point + 1 )\fR,
where \fIinsertion_point\fR is an index in \f(CW$x\fR where \fIV\fR may be
inserted while maintaining the order in \f(CW$x\fR.  If \f(CW$x\fR has
duplicated values, \fII\fR may refer to any of them.
.PP
needs major (?) work to handles bad values
.SS "vsearch_bin_inclusive"
.IX Subsection "vsearch_bin_inclusive"
.Vb 1
\&  Signature: (vals(); x(n); indx [o]idx())
.Ve
.PP
Determine the index for values in a sorted array of bins, lower bound inclusive.
.PP
.Vb 1
\&  $idx = vsearch_bin_inclusive($vals, $x);
.Ve
.PP
\&\f(CW$x\fR must be sorted, but may be in decreasing or increasing
order.
.PP
\&\f(CW$x\fR represents the edges of contiguous bins, with the first and
last elements representing the outer edges of the outer bins, and the
inner elements the shared bin edges.
.PP
The lower bound of a bin is inclusive to the bin, its outer bound is exclusive to it.
\&\fBvsearch_bin_inclusive\fR returns an index \fII\fR for each value \fIV\fR of \f(CW$vals\fR
.PP
\&\fII\fR has the following properties:
.IP "\(bu" 4
if \f(CW$x\fR is sorted in increasing order
.Sp
.Vb 3
\&           V < x[0]  : I = \-1
\&  x[0]  <= V < x[\-1] : I s.t. x[I] <= V < x[I+1]
\&  x[\-1] <= V         : I = $x\->nelem \- 1
.Ve
.IP "\(bu" 4
if \f(CW$x\fR is sorted in decreasing order
.Sp
.Vb 3
\&           V >= x[0]  : I = 0
\&  x[0]  >  V >= x[\-1] : I s.t. x[I+1] > V >= x[I]
\&  x[\-1] >  V          : I = $x\->nelem
.Ve
.PP
If all elements of \f(CW$x\fR are equal,
.PP
.Vb 1
\&    i = $x\->nelem \- 1
.Ve
.PP
If \f(CW$x\fR contains duplicated elements, \fII\fR is the index of the
righmost (by index in array) duplicate if \fIV\fR matches.
.PP
needs major (?) work to handles bad values
.SS "vsearch_bin_exclusive"
.IX Subsection "vsearch_bin_exclusive"
.Vb 1
\&  Signature: (vals(); x(n); indx [o]idx())
.Ve
.PP
Determine the index for values in a sorted array of bins, lower bound exclusive.
.PP
.Vb 1
\&  $idx = vsearch_bin_exclusive($vals, $x);
.Ve
.PP
\&\f(CW$x\fR must be sorted, but may be in decreasing or increasing
order.
.PP
\&\f(CW$x\fR represents the edges of contiguous bins, with the first and
last elements representing the outer edges of the outer bins, and the
inner elements the shared bin edges.
.PP
The lower bound of a bin is exclusive to the bin, its upper bound is inclusive to it.
\&\fBvsearch_bin_exclusive\fR returns an index \fII\fR for each value \fIV\fR of \f(CW$vals\fR.
.PP
\&\fII\fR has the following properties:
.IP "\(bu" 4
if \f(CW$x\fR is sorted in increasing order
.Sp
.Vb 3
\&           V <= x[0]  : I = \-1
\&  x[0]  <  V <= x[\-1] : I s.t. x[I] < V <= x[I+1]
\&  x[\-1] <  V          : I = $x\->nelem \- 1
.Ve
.IP "\(bu" 4
if \f(CW$x\fR is sorted in decreasing order
.Sp
.Vb 3
\&           V >  x[0]  : I = 0
\&  x[0]  >= V >  x[\-1] : I s.t. x[I\-1] >= V > x[I]
\&  x[\-1] >= V          : I = $x\->nelem
.Ve
.PP
If all elements of \f(CW$x\fR are equal,
.PP
.Vb 1
\&    i = $x\->nelem \- 1
.Ve
.PP
If \f(CW$x\fR contains duplicated elements, \fII\fR is the index of the
righmost (by index in array) duplicate if \fIV\fR matches.
.PP
needs major (?) work to handles bad values
.SS "interpolate"
.IX Subsection "interpolate"
.Vb 1
\&  Signature: (xi(); x(n); y(n); [o] yi(); int [o] err())
.Ve
.PP
routine for 1D linear interpolation
.PP
.Vb 1
\& ( $yi, $err ) = interpolate($xi, $x, $y)
.Ve
.PP
Given a set of points \f(CW\*(C`($x,$y)\*(C'\fR, use linear interpolation
to find the values \f(CW$yi\fR at a set of points \f(CW$xi\fR.
.PP
\&\f(CW\*(C`interpolate\*(C'\fR uses a binary search to find the suspects, er...,
interpolation indices and therefore abscissas (ie \f(CW$x\fR)
have to be \fIstrictly\fR ordered (increasing or decreasing).
For interpolation at lots of
closely spaced abscissas an approach that uses the last index found as
a start for the next search can be faster (compare Numerical Recipes
\&\f(CW\*(C`hunt\*(C'\fR routine). Feel free to implement that on top of the binary
search if you like. For out of bounds values it just does a linear
extrapolation and sets the corresponding element of \f(CW$err\fR to 1,
which is otherwise 0.
.PP
See also \*(L"interpol\*(R", which uses the same routine,
differing only in the handling of extrapolation \- an error message
is printed rather than returning an error ndarray.
.PP
needs major (?) work to handles bad values
.SS "interpol"
.IX Subsection "interpol"
.Vb 1
\& Signature: (xi(); x(n); y(n); [o] yi())
.Ve
.PP
routine for 1D linear interpolation
.PP
.Vb 1
\& $yi = interpol($xi, $x, $y)
.Ve
.PP
\&\f(CW\*(C`interpol\*(C'\fR uses the same search method as \*(L"interpolate\*(R",
hence \f(CW$x\fR must be \fIstrictly\fR ordered (either increasing or decreasing).
The difference occurs in the handling of out-of-bounds values; here
an error message is printed.
.SS "interpND"
.IX Subsection "interpND"
Interpolate values from an N\-D ndarray, with switchable method
.PP
.Vb 3
\&  $source = 10*xvals(10,10) + yvals(10,10);
\&  $index = pdl([[2.2,3.5],[4.1,5.0]],[[6.0,7.4],[8,9]]);
\&  print $source\->interpND( $index );
.Ve
.PP
InterpND acts like indexND,
collapsing \f(CW$index\fR by lookup
into \f(CW$source\fR; but it does interpolation rather than direct sampling.
The interpolation method and boundary condition are switchable via
an options hash.
.PP
By default, linear or sample interpolation is used, with constant
value outside the boundaries of the source pdl.  No dataflow occurs,
because in general the output is computed rather than indexed.
.PP
All the interpolation methods treat the pixels as value-centered, so
the \f(CW\*(C`sample\*(C'\fR method will return \f(CW\*(C`$a\->(0)\*(C'\fR for coordinate values on
the set [\-0.5,0.5), and all methods will return \f(CW\*(C`$a\->(1)\*(C'\fR for
a coordinate value of exactly 1.
.PP
Recognized options:
.IP "method" 3
.IX Item "method"
Values can be:
.RS 3
.IP "\(bu" 3
0, s, sample, Sample (default for integer source types)
.Sp
The nearest value is taken. Pixels are regarded as centered on their
respective integer coordinates (no offset from the linear case).
.IP "\(bu" 3
1, l, linear, Linear (default for floating point source types)
.Sp
The values are N\-linearly interpolated from an N\-dimensional cube of size 2.
.IP "\(bu" 3
3, c, cube, cubic, Cubic
.Sp
The values are interpolated using a local cubic fit to the data.  The
fit is constrained to match the original data and its derivative at the
data points.  The second derivative of the fit is not continuous at the
data points.  Multidimensional datasets are interpolated by the
successive-collapse method.
.Sp
(Note that the constraint on the first derivative causes a small amount
of ringing around sudden features such as step functions).
.IP "\(bu" 3
f, fft, fourier, Fourier
.Sp
The source is Fourier transformed, and the interpolated values are
explicitly calculated from the coefficients.  The boundary condition
option is ignored \*(-- periodic boundaries are imposed.
.Sp
If you pass in the option \*(L"fft\*(R", and it is a list (\s-1ARRAY\s0) ref, then it
is a stash for the magnitude and phase of the source \s-1FFT.\s0  If the list
has two elements then they are taken as already computed; otherwise
they are calculated and put in the stash.
.RE
.RS 3
.RE
.IP "b, bound, boundary, Boundary" 3
.IX Item "b, bound, boundary, Boundary"
This option is passed unmodified into indexND,
which is used as the indexing engine for the interpolation.
Some current allowed values are 'extend', 'periodic', 'truncate', and 'mirror'
(default is 'truncate').
.IP "bad" 3
.IX Item "bad"
contains the fill value used for 'truncate' boundary.  (default 0)
.IP "fft" 3
.IX Item "fft"
An array ref whose associated list is used to stash the \s-1FFT\s0 of the source
data, for the \s-1FFT\s0 method.
.SS "one2nd"
.IX Subsection "one2nd"
Converts a one dimensional index ndarray to a set of \s-1ND\s0 coordinates
.PP
.Vb 1
\& @coords=one2nd($x, $indices)
.Ve
.PP
returns an array of ndarrays containing the \s-1ND\s0 indexes corresponding to
the one dimensional list indices. The indices are assumed to
correspond to array \f(CW$x\fR clumped using \f(CW\*(C`clump(\-1)\*(C'\fR. This routine is
used in the old vector form of \*(L"whichND\*(R", but is useful on
its own occasionally.
.PP
Returned ndarrays have the indx datatype.  \f(CW$indices\fR can have
values larger than \f(CW\*(C`$x\->nelem\*(C'\fR but negative values in \f(CW$indices\fR
will not give the answer you expect.
.PP
.Vb 7
\& pdl> $x=pdl [[[1,2],[\-1,1]], [[0,\-3],[3,2]]]; $c=$x\->clump(\-1)
\& pdl> $maxind=maximum_ind($c); p $maxind;
\& 6
\& pdl> print one2nd($x, maximum_ind($c))
\& 0 1 1
\& pdl> p $x\->at(0,1,1)
\& 3
.Ve
.SS "which"
.IX Subsection "which"
.Vb 1
\&  Signature: (mask(n); indx [o] inds(n); indx [o]lastout())
.Ve
.PP
Returns indices of non-zero values from a 1\-D \s-1PDL\s0
.PP
.Vb 1
\& $i = which($mask);
.Ve
.PP
returns a pdl with indices for all those elements that are nonzero in
the mask. Note that the returned indices will be 1D. If you feed in a
multidimensional mask, it will be flattened before the indices are
calculated.  See also \*(L"whichND\*(R" for multidimensional masks.
.PP
If you want to index into the original mask or a similar ndarray
with output from \f(CW\*(C`which\*(C'\fR, remember to flatten it before calling index:
.PP
.Vb 3
\&  $data = random 5, 5;
\&  $idx = which $data > 0.5; # $idx is now 1D
\&  $bigsum = $data\->flat\->index($idx)\->sum;  # flatten before indexing
.Ve
.PP
Compare also \*(L"where\*(R" for similar functionality.
.PP
\&\s-1SEE ALSO:\s0
.PP
\&\*(L"which_both\*(R" returns separately the indices of both nonzero and zero
values in the mask.
.PP
\&\*(L"where_both\*(R" returns separately slices of both nonzero and zero
values in the mask.
.PP
\&\*(L"where\*(R" returns associated values from a data \s-1PDL,\s0 rather than
indices into the mask \s-1PDL.\s0
.PP
\&\*(L"whichND\*(R" returns N\-D indices into a multidimensional \s-1PDL.\s0
.PP
.Vb 4
\& pdl> $x = sequence(10); p $x
\& [0 1 2 3 4 5 6 7 8 9]
\& pdl> $indx = which($x>6); p $indx
\& [7 8 9]
.Ve
.PP
which processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "which_both"
.IX Subsection "which_both"
.Vb 1
\&  Signature: (mask(n); indx [o] inds(n); indx [o]notinds(n); indx [o]lastout(); indx [o]lastoutn())
.Ve
.PP
Returns indices of nonzero and zero values in a mask \s-1PDL\s0
.PP
.Vb 1
\& ($i, $c_i) = which_both($mask);
.Ve
.PP
This works just as \*(L"which\*(R", but the complement of \f(CW$i\fR will be in
\&\f(CW$c_i\fR.
.PP
.Vb 5
\& pdl> p $x = sequence(10)
\& [0 1 2 3 4 5 6 7 8 9]
\& pdl> ($big, $small) = which_both($x >= 5); p "$big\en$small"
\& [5 6 7 8 9]
\& [0 1 2 3 4]
.Ve
.PP
which_both processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "where"
.IX Subsection "where"
Use a mask to select values from one or more data PDLs
.PP
\&\f(CW\*(C`where\*(C'\fR accepts one or more data ndarrays and a mask ndarray.  It
returns a list of output ndarrays, corresponding to the input data
ndarrays.  Each output ndarray is a 1\-dimensional list of values in its
corresponding data ndarray. The values are drawn from locations where
the mask is nonzero.
.PP
The output PDLs are still connected to the original data PDLs, for the
purpose of dataflow.
.PP
\&\f(CW\*(C`where\*(C'\fR combines the functionality of \*(L"which\*(R" and index
into a single operation.
.PP
\&\s-1BUGS:\s0
.PP
While \f(CW\*(C`where\*(C'\fR works \s-1OK\s0 for most N\-dimensional cases, it does not
broadcast properly over (for example) the (N+1)th dimension in data
that is compared to an N\-dimensional mask.  Use \f(CW\*(C`whereND\*(C'\fR for that.
.PP
.Vb 4
\& $i = $x\->where($x+5 > 0); # $i contains those elements of $x
\&                           # where mask ($x+5 > 0) is 1
\& $i .= \-5;  # Set those elements (of $x) to \-5. Together, these
\&            # commands clamp $x to a maximum of \-5.
.Ve
.PP
It is also possible to use the same mask for several ndarrays with
the same call:
.PP
.Vb 1
\& ($i,$j,$k) = where($x,$y,$z, $x+5>0);
.Ve
.PP
Note: \f(CW$i\fR is always 1\-D, even if \f(CW$x\fR is >1\-D.
.PP
\&\s-1WARNING:\s0 The first argument
(the values) and the second argument (the mask) currently have to have
the exact same dimensions (or horrible things happen). You *cannot*
broadcast over a smaller mask, for example.
.SS "where_both"
.IX Subsection "where_both"
Returns slices (non-zero in mask, zero) of an ndarray according to a mask
.PP
.Vb 1
\& ($match_vals, $non_match_vals) = where_both($pdl, $mask);
.Ve
.PP
This works like \*(L"which_both\*(R", but (flattened) data-flowing slices
rather than index-sets are returned.
.PP
.Vb 9
\& pdl> p $x = sequence(10) + 2
\& [2 3 4 5 6 7 8 9 10 11]
\& pdl> ($big, $small) = where_both($x, $x > 5); p "$big\en$small"
\& [6 7 8 9 10 11]
\& [2 3 4 5]
\& pdl> p $big += 2, $small \-= 1
\& [8 9 10 11 12 13] [1 2 3 4]
\& pdl> p $x
\& [1 2 3 4 8 9 10 11 12 13]
.Ve
.SS "whereND"
.IX Subsection "whereND"
\&\f(CW\*(C`where\*(C'\fR with support for \s-1ND\s0 masks and broadcasting
.PP
\&\f(CW\*(C`whereND\*(C'\fR accepts one or more data ndarrays and a
mask ndarray.  It returns a list of output ndarrays,
corresponding to the input data ndarrays.  The values
are drawn from locations where the mask is nonzero.
.PP
\&\f(CW\*(C`whereND\*(C'\fR differs from \f(CW\*(C`where\*(C'\fR in that the mask
dimensionality is preserved which allows for
proper broadcasting of the selection operation over
higher dimensions.
.PP
As with \f(CW\*(C`where\*(C'\fR the output PDLs are still connected
to the original data PDLs, for the purpose of dataflow.
.PP
.Vb 2
\&  $sdata = whereND $data, $mask
\&  ($s1, $s2, ..., $sn) = whereND $d1, $d2, ..., $dn, $mask
\&
\&  where
\&
\&    $data is M dimensional
\&    $mask is N < M dimensional
\&    dims($data) 1..N == dims($mask) 1..N
\&    with broadcasting over N+1 to M dimensions
.Ve
.PP
.Vb 5
\&  $data   = sequence(4,3,2);   # example data array
\&  $mask4  = (random(4)>0.5);   # example 1\-D mask array, has $n4 true values
\&  $mask43 = (random(4,3)>0.5); # example 2\-D mask array, has $n43 true values
\&  $sdat4  = whereND $data, $mask4;   # $sdat4 is a [$n4,3,2] pdl
\&  $sdat43 = whereND $data, $mask43;  # $sdat43 is a [$n43,2] pdl
.Ve
.PP
Just as with \f(CW\*(C`where\*(C'\fR, you can use the returned value in an
assignment. That means that both of these examples are valid:
.PP
.Vb 5
\&  # Used to create a new slice stored in $sdat4:
\&  $sdat4 = $data\->whereND($mask4);
\&  $sdat4 .= 0;
\&  # Used in lvalue context:
\&  $data\->whereND($mask4) .= 0;
.Ve
.PP
\&\s-1SEE ALSO:\s0
.PP
\&\*(L"whichND\*(R" returns N\-D indices into a multidimensional \s-1PDL,\s0 from a mask.
.SS "whichND"
.IX Subsection "whichND"
Return the coordinates of non-zero values in a mask.
.PP
WhichND returns the N\-dimensional coordinates of each nonzero value in
a mask \s-1PDL\s0 with any number of dimensions.  The returned values arrive
as an array-of-vectors suitable for use in
indexND or range.
.PP
.Vb 1
\& $coords = whichND($mask);
.Ve
.PP
returns a \s-1PDL\s0 containing the coordinates of the elements that are non-zero
in \f(CW$mask\fR, suitable for use in \*(L"indexND\*(R" in PDL::Slices. The 0th dimension contains the
full coordinate listing of each point; the 1st dimension lists all the points.
For example, if \f(CW$mask\fR has rank 4 and 100 matching elements, then \f(CW$coords\fR has
dimension 4x100.
.PP
If no such elements exist, then whichND returns a structured empty \s-1PDL:\s0
an Nx0 \s-1PDL\s0 that contains no values (but matches, broadcasting-wise, with
the vectors that would be produced if such elements existed).
.PP
\&\s-1DEPRECATED BEHAVIOR IN LIST CONTEXT:\s0
.PP
whichND once delivered different values in list context than in scalar
context, for historical reasons.  In list context, it returned the
coordinates transposed, as a collection of 1\-PDLs (one per dimension)
in a list.  This usage is deprecated in \s-1PDL 2.4.10,\s0 and will cause a
warning to be issued every time it is encountered.  To avoid the
warning, you can set the global variable \*(L"$PDL::whichND\*(R" to 's' to
get scalar behavior in all contexts, or to 'l' to get list behavior in
list context.
.PP
In later versions of \s-1PDL,\s0 the deprecated behavior will disappear.  Deprecated
list context whichND expressions can be replaced with:
.PP
.Vb 1
\&    @list = $x\->whichND\->mv(0,\-1)\->dog;
.Ve
.PP
\&\s-1SEE ALSO:\s0
.PP
\&\*(L"which\*(R" finds coordinates of nonzero values in a 1\-D mask.
.PP
\&\*(L"where\*(R" extracts values from a data \s-1PDL\s0 that are associated
with nonzero values in a mask \s-1PDL.\s0
.PP
\&\*(L"indexND\*(R" in PDL::Slices can be fed the coordinates to return the values.
.PP
.Vb 5
\& pdl> $s=sequence(10,10,3,4)
\& pdl> ($x, $y, $z, $w)=whichND($s == 203); p $x, $y, $z, $w
\& [3] [0] [2] [0]
\& pdl> print $s\->at(list(cat($x,$y,$z,$w)))
\& 203
.Ve
.SS "setops"
.IX Subsection "setops"
Implements simple set operations like union and intersection
.PP
.Vb 1
\&   Usage: $set = setops($x, <OPERATOR>, $y);
.Ve
.PP
The operator can be \f(CW\*(C`OR\*(C'\fR, \f(CW\*(C`XOR\*(C'\fR or \f(CW\*(C`AND\*(C'\fR. This is then applied
to \f(CW$x\fR viewed as a set and \f(CW$y\fR viewed as a set. Set theory says
that a set may not have two or more identical elements, but setops
takes care of this for you, so \f(CW\*(C`$x=pdl(1,1,2)\*(C'\fR is \s-1OK.\s0 The functioning
is as follows:
.ie n .IP """OR""" 4
.el .IP "\f(CWOR\fR" 4
.IX Item "OR"
The resulting vector will contain the elements that are either in \f(CW$x\fR
\&\fIor\fR in \f(CW$y\fR or both. This is the union in set operation terms
.ie n .IP """XOR""" 4
.el .IP "\f(CWXOR\fR" 4
.IX Item "XOR"
The resulting vector will contain the elements that are either in \f(CW$x\fR
or \f(CW$y\fR, but not in both. This is
.Sp
.Vb 1
\&     Union($x, $y) \- Intersection($x, $y)
.Ve
.Sp
in set operation terms.
.ie n .IP """AND""" 4
.el .IP "\f(CWAND\fR" 4
.IX Item "AND"
The resulting vector will contain the intersection of \f(CW$x\fR and \f(CW$y\fR, so
the elements that are in both \f(CW$x\fR and \f(CW$y\fR. Note that for convenience
this operation is also aliased to \*(L"intersect\*(R".
.PP
It should be emphasized that these routines are used when one or both of
the sets \f(CW$x\fR, \f(CW$y\fR are hard to calculate or that you get from a separate
subroutine.
.PP
Finally \s-1IDL\s0 users might be familiar with Craig Markwardt's \f(CW\*(C`cmset_op.pro\*(C'\fR
routine which has inspired this routine although it was written independently
However the present routine has a few less options (but see the examples)
.PP
You will very often use these functions on an index vector, so that is
what we will show here. We will in fact something slightly silly. First
we will find all squares that are also cubes below 10000.
.PP
Create a sequence vector:
.PP
.Vb 1
\&  pdl> $x = sequence(10000)
.Ve
.PP
Find all odd and even elements:
.PP
.Vb 1
\&  pdl> ($even, $odd) = which_both( ($x % 2) == 0)
.Ve
.PP
Find all squares
.PP
.Vb 1
\&  pdl> $squares= which(ceil(sqrt($x)) == floor(sqrt($x)))
.Ve
.PP
Find all cubes (being careful with roundoff error!)
.PP
.Vb 1
\&  pdl> $cubes= which(ceil($x**(1.0/3.0)) == floor($x**(1.0/3.0)+1e\-6))
.Ve
.PP
Then find all squares that are cubes:
.PP
.Vb 1
\&  pdl> $both = setops($squares, \*(AqAND\*(Aq, $cubes)
.Ve
.PP
And print these (assumes that \f(CW\*(C`PDL::NiceSlice\*(C'\fR is loaded!)
.PP
.Vb 2
\&  pdl> p $x($both)
\&   [0 1 64 729 4096]
.Ve
.PP
Then find all numbers that are either cubes or squares, but not both:
.PP
.Vb 1
\&  pdl> $cube_xor_square = setops($squares, \*(AqXOR\*(Aq, $cubes)
\&
\&  pdl> p $cube_xor_square\->nelem()
\&   112
.Ve
.PP
So there are a total of 112 of these!
.PP
Finally find all odd squares:
.PP
.Vb 1
\&  pdl> $odd_squares = setops($squares, \*(AqAND\*(Aq, $odd)
.Ve
.PP
Another common occurrence is to want to get all objects that are
in \f(CW$x\fR and in the complement of \f(CW$y\fR. But it is almost always best
to create the complement explicitly since the universe that both are
taken from is not known. Thus use \*(L"which_both\*(R" if possible
to keep track of complements.
.PP
If this is impossible the best approach is to make a temporary:
.PP
This creates an index vector the size of the universe of the sets and
set all elements in \f(CW$y\fR to 0
.PP
.Vb 1
\&  pdl> $tmp = ones($n_universe); $tmp($y) .= 0;
.Ve
.PP
This then finds the complement of \f(CW$y\fR
.PP
.Vb 1
\&  pdl> $C_b = which($tmp == 1);
.Ve
.PP
and this does the final selection:
.PP
.Vb 1
\&  pdl> $set = setops($x, \*(AqAND\*(Aq, $C_b)
.Ve
.SS "intersect"
.IX Subsection "intersect"
Calculate the intersection of two ndarrays
.PP
.Vb 1
\&   Usage: $set = intersect($x, $y);
.Ve
.PP
This routine is merely a simple interface to \*(L"setops\*(R". See
that for more information
.PP
Find all numbers less that 100 that are of the form 2*y and 3*x
.PP
.Vb 6
\& pdl> $x=sequence(100)
\& pdl> $factor2 = which( ($x % 2) == 0)
\& pdl> $factor3 = which( ($x % 3) == 0)
\& pdl> $ii=intersect($factor2, $factor3)
\& pdl> p $x($ii)
\& [0 6 12 18 24 30 36 42 48 54 60 66 72 78 84 90 96]
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Tuomas J. Lukka 1997 (lukka@husc.harvard.edu). Contributions
by Christian Soeller (c.soeller@auckland.ac.nz), Karl Glazebrook
(kgb@aaoepp.aao.gov.au), Craig DeForest (deforest@boulder.swri.edu)
and Jarle Brinchmann (jarle@astro.up.pt)
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution,
the copyright notice should be included in the file.
.PP
Updated for \s-1CPAN\s0 viewing compatibility by David Mertens.
