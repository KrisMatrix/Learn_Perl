.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Ops 3"
.TH Ops 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Ops \- Fundamental mathematical operators
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the functions used by \s-1PDL\s0 to
overload the basic mathematical operators (\f(CW\*(C`+ \- / *\*(C'\fR
etc.) and functions (\f(CW\*(C`sin sqrt\*(C'\fR etc.)
.PP
It also includes the function \f(CW\*(C`log10\*(C'\fR, which should
be a perl function so that we can overload it!
.PP
Matrix multiplication (the operator \f(CW\*(C`x\*(C'\fR) is handled
by the module PDL::Primitive.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
none
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "plus"
.IX Subsection "plus"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
add two ndarrays
.PP
.Vb 4
\&   $c = $x + $y;        # overloaded call
\&   $c = plus $x, $y;     # explicit call with default swap of 0
\&   $c = plus $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->plus($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`+\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
plus processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "mult"
.IX Subsection "mult"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
multiply two ndarrays
.PP
.Vb 4
\&   $c = $x * $y;        # overloaded call
\&   $c = mult $x, $y;     # explicit call with default swap of 0
\&   $c = mult $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->mult($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`*\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
mult processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "minus"
.IX Subsection "minus"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
subtract two ndarrays
.PP
.Vb 4
\&   $c = $x \- $y;        # overloaded call
\&   $c = minus $x, $y;     # explicit call with default swap of 0
\&   $c = minus $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->minus($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`\-\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
minus processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "divide"
.IX Subsection "divide"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
divide two ndarrays
.PP
.Vb 4
\&   $c = $x / $y;        # overloaded call
\&   $c = divide $x, $y;     # explicit call with default swap of 0
\&   $c = divide $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->divide($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`/\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
divide processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "gt"
.IX Subsection "gt"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary > (greater than) operation
.PP
.Vb 4
\&   $c = $x > $y;        # overloaded call
\&   $c = gt $x, $y;     # explicit call with default swap of 0
\&   $c = gt $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->gt($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`>\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
gt processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "lt"
.IX Subsection "lt"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary < (less than) operation
.PP
.Vb 4
\&   $c = $x < $y;        # overloaded call
\&   $c = lt $x, $y;     # explicit call with default swap of 0
\&   $c = lt $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->lt($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
lt processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "le"
.IX Subsection "le"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary <= (less equal) operation
.PP
.Vb 4
\&   $c = $x <= $y;        # overloaded call
\&   $c = le $x, $y;     # explicit call with default swap of 0
\&   $c = le $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->le($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<=\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
le processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "ge"
.IX Subsection "ge"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
the binary >= (greater equal) operation
.PP
.Vb 4
\&   $c = $x >= $y;        # overloaded call
\&   $c = ge $x, $y;     # explicit call with default swap of 0
\&   $c = ge $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->ge($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`>=\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
ge processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "eq"
.IX Subsection "eq"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIequal to\fR operation (\f(CW\*(C`==\*(C'\fR)
.PP
.Vb 4
\&   $c = $x == $y;        # overloaded call
\&   $c = eq $x, $y;     # explicit call with default swap of 0
\&   $c = eq $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->eq($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`==\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
eq processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "ne"
.IX Subsection "ne"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fInot equal to\fR operation (\f(CW\*(C`!=\*(C'\fR)
.PP
.Vb 4
\&   $c = $x != $y;        # overloaded call
\&   $c = ne $x, $y;     # explicit call with default swap of 0
\&   $c = ne $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->ne($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`!=\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
ne processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "shiftleft"
.IX Subsection "shiftleft"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
leftshift \f(CW$a\fR by \f(CW$b\fR
.PP
.Vb 4
\&   $c = $x << $y;        # overloaded call
\&   $c = shiftleft $x, $y;     # explicit call with default swap of 0
\&   $c = shiftleft $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->shiftleft($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<<\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
shiftleft processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "shiftright"
.IX Subsection "shiftright"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
rightshift \f(CW$a\fR by \f(CW$b\fR
.PP
.Vb 4
\&   $c = $x >> $y;        # overloaded call
\&   $c = shiftright $x, $y;     # explicit call with default swap of 0
\&   $c = shiftright $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->shiftright($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`>>\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
shiftright processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "or2"
.IX Subsection "or2"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIor\fR of two ndarrays
.PP
.Vb 4
\&   $c = $x | $y;        # overloaded call
\&   $c = or2 $x, $y;     # explicit call with default swap of 0
\&   $c = or2 $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->or2($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`|\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
or2 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "and2"
.IX Subsection "and2"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIand\fR of two ndarrays
.PP
.Vb 4
\&   $c = $x & $y;        # overloaded call
\&   $c = and2 $x, $y;     # explicit call with default swap of 0
\&   $c = and2 $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->and2($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`&\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
and2 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "xor"
.IX Subsection "xor"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
binary \fIexclusive or\fR of two ndarrays
.PP
.Vb 4
\&   $c = $x ^ $y;        # overloaded call
\&   $c = xor $x, $y;     # explicit call with default swap of 0
\&   $c = xor $x, $y, 1;  # explicit call with trailing 1 to swap args
\&   $x\->inplace\->xor($y); # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`^\*(C'\fR operator.
As of 2.065, when calling this function explicitly you can omit
the third argument (see second example), or supply it (see third one).
.PP
xor processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "bitnot"
.IX Subsection "bitnot"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
unary bit negation
.PP
.Vb 2
\&   $y = ~ $x;
\&   $x\->inplace\->bitnot;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`~\*(C'\fR operator/function.
.PP
bitnot processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "power"
.IX Subsection "power"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
raise ndarray \f(CW$a\fR to the power \f(CW$b\fR
.PP
.Vb 3
\&   $c = $x\->power($y,0); # explicit function call
\&   $c = $a ** $b;    # overloaded use
\&   $x\->inplace\->power($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`**\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
power processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "atan2"
.IX Subsection "atan2"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
elementwise \f(CW\*(C`atan2\*(C'\fR of two ndarrays
.PP
.Vb 3
\&   $c = $x\->atan2($y,0); # explicit function call
\&   $c = atan2 $a, $b;    # overloaded use
\&   $x\->inplace\->atan2($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`atan2\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
atan2 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "modulo"
.IX Subsection "modulo"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
elementwise \f(CW\*(C`modulo\*(C'\fR operation
.PP
.Vb 3
\&   $c = $x\->modulo($y,0); # explicit function call
\&   $c = $a % $b;    # overloaded use
\&   $x\->inplace\->modulo($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`%\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
modulo processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "spaceship"
.IX Subsection "spaceship"
.Vb 1
\&  Signature: (a(); b(); [o]c(); int swap)
.Ve
.PP
elementwise \*(L"<=>\*(R" operation
.PP
.Vb 3
\&   $c = $x\->spaceship($y,0); # explicit function call
\&   $c = $a <=> $b;    # overloaded use
\&   $x\->inplace\->spaceship($y,0);     # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the binary \f(CW\*(C`<=>\*(C'\fR function.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
spaceship processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "sqrt"
.IX Subsection "sqrt"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
elementwise square root
.PP
.Vb 2
\&   $y = sqrt $x;
\&   $x\->inplace\->sqrt;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`sqrt\*(C'\fR operator/function.
.PP
sqrt processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "sin"
.IX Subsection "sin"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the sin function
.PP
.Vb 2
\&   $y = sin $x;
\&   $x\->inplace\->sin;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`sin\*(C'\fR operator/function.
.PP
sin processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "cos"
.IX Subsection "cos"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the cos function
.PP
.Vb 2
\&   $y = cos $x;
\&   $x\->inplace\->cos;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`cos\*(C'\fR operator/function.
.PP
cos processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "not"
.IX Subsection "not"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the elementwise \fInot\fR operation
.PP
.Vb 2
\&   $y = ! $x;
\&   $x\->inplace\->not;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`!\*(C'\fR operator/function.
.PP
not processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "exp"
.IX Subsection "exp"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the exponential function
.PP
.Vb 2
\&   $y = exp $x;
\&   $x\->inplace\->exp;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`exp\*(C'\fR operator/function.
.PP
exp processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "log"
.IX Subsection "log"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the natural logarithm
.PP
.Vb 2
\&   $y = log $x;
\&   $x\->inplace\->log;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`log\*(C'\fR operator/function.
.PP
log processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "re"
.IX Subsection "re"
.Vb 1
\&  Signature: (complexv(); real [o]b())
.Ve
.PP
Returns the real part of a complex number.
.PP
re processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "im"
.IX Subsection "im"
.Vb 1
\&  Signature: (complexv(); real [o]b())
.Ve
.PP
Returns the imaginary part of a complex number.
.PP
im processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "_cabs"
.IX Subsection "_cabs"
.Vb 1
\&  Signature: (complexv(); real [o]b())
.Ve
.PP
Returns the absolute (length) of a complex number.
.PP
_cabs processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "log10"
.IX Subsection "log10"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
the base 10 logarithm
.PP
.Vb 2
\&   $y = log10 $x;
\&   $x\->inplace\->log10;  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
This function is used to overload the unary \f(CW\*(C`log10\*(C'\fR operator/function.
.PP
log10 processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "assgn"
.IX Subsection "assgn"
.Vb 1
\&  Signature: (a(); [o]b())
.Ve
.PP
Plain numerical assignment. This is used to implement the \*(L".=\*(R" operator
.PP
assgn processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "carg"
.IX Subsection "carg"
.Vb 1
\&  Signature: (complexv(); real [o]b())
.Ve
.PP
Returns the polar angle of a complex number.
.PP
carg processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "conj"
.IX Subsection "conj"
.Vb 1
\&  Signature: (complexv();  [o]b())
.Ve
.PP
complex conjugate.
.PP
conj processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "czip"
.IX Subsection "czip"
.Vb 1
\&  Signature: (r(); i(); complex [o]c())
.Ve
.PP
convert real, imaginary to native complex, (sort of) like \s-1LISP\s0 zip
function. Will add the \f(CW\*(C`r\*(C'\fR ndarray to \*(L"i\*(R" times the \f(CW\*(C`i\*(C'\fR ndarray. Only
takes real ndarrays as input.
.PP
czip does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "ipow"
.IX Subsection "ipow"
.Vb 1
\&  Signature: (a(); indx b(); [o] ans())
.Ve
.PP
raise ndarray \f(CW$a\fR to integer power \f(CW$b\fR
.PP
.Vb 3
\&   $c = $x\->ipow($y,0);     # explicit function call
\&   $c = ipow $x, $y;
\&   $x\->inplace\->ipow($y,0);  # modify $x inplace
.Ve
.PP
It can be made to work inplace with the \f(CW\*(C`$x\->inplace\*(C'\fR syntax.
Note that when calling this function explicitly you need to supply
a third argument that should generally be zero (see first example).
This restriction is expected to go away in future releases.
.PP
Algorithm from Wikipedia <http://en.wikipedia.org/wiki/Exponentiation_by_squaring>
.PP
ipow does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "abs"
.IX Subsection "abs"
Returns the absolute value of a number.
.SS "abs2"
.IX Subsection "abs2"
Returns the square of the absolute value of a number.
.SS "r2C"
.IX Subsection "r2C"
.Vb 1
\&  Signature: (r(); complex [o]c())
.Ve
.PP
convert real to native complex, with an imaginary part of zero
.PP
r2C does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "i2C"
.IX Subsection "i2C"
.Vb 1
\&  Signature: (i(); complex [o]c())
.Ve
.PP
convert imaginary to native complex, with a real part of zero
.PP
i2C does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tuomas J. Lukka (lukka@fas.harvard.edu),
Karl Glazebrook (kgb@aaoepp.aao.gov.au),
Doug Hunt (dhunt@ucar.edu),
Christian Soeller (c.soeller@auckland.ac.nz),
Doug Burke (burke@ifa.hawaii.edu),
and Craig DeForest (deforest@boulder.swri.edu).
