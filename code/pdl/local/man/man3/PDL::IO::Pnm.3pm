.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Pnm 3"
.TH Pnm 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::IO::Pnm \-\- pnm format I/O for PDL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use PDL::IO::Pnm;
\&  $im = wpnm $pdl, $file, $format[, $raw];
\&  rpnm $stack\->slice(\*(Aq:,:,:,(0)\*(Aq),"PDL.ppm";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
pnm I/O for \s-1PDL.\s0
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "pnminraw"
.IX Subsection "pnminraw"
.Vb 2
\&  Signature: (type(); byte+ [o] im(m,n); int ms => m; int ns => n;
\&                        int isbin; PerlIO *fp)
.Ve
.PP
Read in a raw pnm file.
.PP
read a raw pnm file. The \f(CW\*(C`type\*(C'\fR argument is only there to
determine the type of the operation when creating \f(CW\*(C`im\*(C'\fR or trigger
the appropriate type conversion (maybe we want a byte+ here so that
\&\f(CW\*(C`im\*(C'\fR follows \fIstrictly\fR the type of \f(CW\*(C`type\*(C'\fR).
.PP
pnminraw does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "pnminascii"
.IX Subsection "pnminascii"
.Vb 2
\&  Signature: (type(); byte+ [o] im(m,n); int ms => m; int ns => n;
\&                        int format; PerlIO *fp)
.Ve
.PP
Read in an ascii pnm file.
.PP
pnminascii does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "pnmout"
.IX Subsection "pnmout"
.Vb 1
\&  Signature: (a(m); int israw; int isbin; PerlIO *fp)
.Ve
.PP
Write a line of pnm data.
.PP
This function is implemented this way so that broadcasting works
naturally.
.PP
pnmout does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "rpnm"
.IX Subsection "rpnm"
Read a pnm (portable bitmap/pixmap, pbm/ppm) file into an ndarray.
.PP
.Vb 1
\&  Usage:  $im = rpnm $file;
.Ve
.PP
Reads a file (or open file-handle) in pnm format (ascii or raw) into a pdl (magic numbers P1\-P6).
Based on the input format it returns pdls with arrays of size (width,height)
if binary or grey value data (pbm and pgm) or (3,width,height) if rgb
data (ppm). This also means for a palette image that the distinction between
an image and its lookup table is lost which can be a problem in cases (but can
hardly be avoided when using netpbm/pbmplus).  Datatype is dependent
on the maximum grey/color\-component value (for raw and binary formats
always \s-1PDL_B\s0). rpnm tries to read chopped files by zero padding the
missing data (well it currently doesn't, it barfs; I'll probably fix it
when it becomes a problem for me ;). You can also read directly into an
existing pdl that has to have the right size(!). This can come in handy
when you want to read a sequence of images into a datacube.
.PP
For details about the formats see appropriate manpages that come with the
netpbm/pbmplus packages.
.PP
.Vb 2
\&  $stack = zeroes(byte,3,500,300,4);
\&  rpnm $stack\->slice(\*(Aq:,:,:,(0)\*(Aq),"PDL.ppm";
.Ve
.PP
reads an rgb image (that had better be of size (500,300)) into the
first plane of a 3D \s-1RGB\s0 datacube (=4D pdl datacube). You can also do
inplace transpose/inversion that way.
.SS "wpnm"
.IX Subsection "wpnm"
Write a pnm (portable bitmap/pixmap, pbm/ppm) file into a file or open file-handle.
.PP
.Vb 1
\&  Usage:  $im = wpnm $pdl, $file, $format[, $raw];
.Ve
.PP
Writes data in a pdl into pnm format (ascii or raw) (magic numbers P1\-P6).
The \f(CW$format\fR is required (normally produced by \fBwpic\fR) and routine just
checks if data is compatible with that format. All conversions should
already have been done. If possible, usage of \fBwpic\fR is preferred. Currently
\&\s-1RAW\s0 format is chosen if compliant with range of input data. Explicit control
of \s-1ASCII/RAW\s0 is possible through the optional \f(CW$raw\fR argument. If \s-1RAW\s0 is
set to zero it will enforce \s-1ASCII\s0 mode. Enforcing \s-1RAW\s0 is
somewhat meaningless as the routine will always try to write \s-1RAW\s0
format if the data range allows (but maybe it should reduce to a \s-1RAW\s0
supported type when \s-1RAW\s0 == '\s-1RAW\s0'?). For details about the formats
consult appropriate manpages that come with the netpbm/pbmplus
packages.
.SH "BUGS"
.IX Header "BUGS"
\&\f(CW\*(C`rpnm\*(C'\fR currently relies on the fact that the header is separated
from the image data by a newline. This is not required by the p[bgp]m
formats (in fact any whitespace is allowed) but most of the pnm
writers seem to comply with that. Truncated files are currently
treated ungracefully (\f(CW\*(C`rpnm\*(C'\fR just barfs).
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 1996,1997 Christian Soeller <c.soeller@auckland.ac.nz>
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file \s-1COPYING\s0 in the \s-1PDL\s0
distribution. If this file is separated from the \s-1PDL\s0 distribution,
the copyright notice should be included in the file.
