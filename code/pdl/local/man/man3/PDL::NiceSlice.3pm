.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "NiceSlice 3"
.TH NiceSlice 3 "2022-05-23" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::NiceSlice \- toward a nicer slicing syntax for PDL
.SH "SYNOPSYS"
.IX Header "SYNOPSYS"
.Vb 1
\&  use PDL::NiceSlice;
\&
\&  $x(1:4) .= 2;             # concise syntax for ranges
\&  print $y((0),1:$end);     # use variables in the slice expression
\&  $x\->transpose\->(($pos\-1)) .= 0; # default method syntax
\&
\&  $idx = long 1, 7, 3, 0;   # an ndarray of indices
\&  $x(\-3:2:2,$idx) += 3;     # mix explicit indexing and ranges
\&  $x\->clump(1,2)\->(0:30);   # \*(Aqdefault method\*(Aq syntax
\&  $x(myfunc(0,$var),1:4)++; # when using functions in slice expressions
\&                            # use parentheses around args!
\&
\&  $y = $x(*3);              # Add dummy dimension of order 3
\&
\&  # modifiers are specified in a ;\-separated trailing block
\&  $x($x!=3;?)++;            # short for $x\->where($x!=3)++
\&  $x(0:1114;_) .= 0;        # short for $x\->flat\->(0:1114)
\&  $y = $x(0:\-1:3;|);        # short for $x(0:\-1:3)\->sever
\&  $n = sequence 3,1,4,1;
\&  $y = $n(;\-);              # drop all dimensions of size 1 (AKA squeeze)
\&  $y = $n(0,0;\-|);          # squeeze *and* sever
\&  $c = $x(0,3,0;\-);         # more compact way of saying $x((0),(3),(0))
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Slicing is a basic, extremely common operation, and \s-1PDL\s0's
\&\*(L"slice\*(R" in PDL::Slices method would be cumbersome to use in many
cases.  \f(CW\*(C`PDL::NiceSlice\*(C'\fR rectifies that by incorporating new slicing
syntax directly into the language via a perl \fIsource filter\fR (see
perlfilter).  NiceSlice adds no new functionality, only convenient syntax.
.PP
NiceSlice is loaded automatically in the perldl or pdl2 shell, but (to avoid
conflicts with other modules) must be loaded explicitly in standalone
perl/PDL scripts (see below).  If you prefer not to use a prefilter on
your standalone scripts, you can use the \*(L"slice\*(R" in PDL::Slices
method in those scripts,
rather than the more compact NiceSlice constructs.
.ie n .SH "Use in scripts and ""perldl"" or ""pdl2"" shell"
.el .SH "Use in scripts and \f(CWperldl\fP or \f(CWpdl2\fP shell"
.IX Header "Use in scripts and perldl or pdl2 shell"
The new slicing syntax can be switched on and off in scripts
and perl modules by using or unloading \f(CW\*(C`PDL::NiceSlice\*(C'\fR.
.PP
But now back to scripts and modules.
Everything after \f(CW\*(C`use PDL::NiceSlice\*(C'\fR will be translated
and you can use the new slicing syntax. Source filtering
will continue until the end of the file is encountered.
You can stop sourcefiltering before the end of the file
by issuing a \f(CW\*(C`no PDL::NiceSlice\*(C'\fR statement.
.PP
Here is an example:
.PP
.Vb 1
\&  use PDL::NiceSlice;
\&
\&  # this code will be translated
\&  # and you can use the new slicing syntax
\&
\&  no PDL::NiceSlice;
\&
\&  # this code won\*(Aqt
\&  # and the new slicing syntax will raise errors!
.Ve
.PP
See also Filter::Simple and \fIexample\fR in this distribution for
further examples.
.PP
\&\s-1NOTE:\s0 Unlike \*(L"normal\*(R" modules you need to include a
\&\f(CW\*(C`use PDL::NiceSlice\*(C'\fR call in each and every file that
contains code that uses the new slicing syntax. Imagine
the following situation: a file \fItest0.pl\fR
.PP
.Vb 3
\&   # start test0.pl
\&   use PDL;
\&   use PDL::NiceSlice;
\&
\&   $x = sequence 10;
\&   print $x(0:4),"\en";
\&
\&   require \*(Aqtest1.pl\*(Aq;
\&   # end test0.pl
.Ve
.PP
that \f(CW\*(C`require\*(C'\fRs a second file \fItest1.pl\fR
.PP
.Vb 5
\&   # begin test1.pl
\&   $aa = sequence 11;
\&   print $aa(0:7),"\en";
\&   1;
\&   # end test1.pl
.Ve
.PP
Following conventional perl wisdom everything should be alright
since we \f(CW\*(C`use\*(C'\fRd \f(CW\*(C`PDL\*(C'\fR and \f(CW\*(C`PDL::NiceSlice\*(C'\fR already from within
\&\fItest0.pl\fR and by the time \fItest1.pl\fR is \f(CW\*(C`require\*(C'\fRd things should
be defined and imported, etc. A quick test run will, however, produce
something like the following:
.PP
.Vb 4
\&  perl test0.pl
\& [0 1 2 3 4]
\& syntax error at test1.pl line 3, near "0:"
\& Compilation failed in require at test0.pl line 7.
.Ve
.PP
This can be fixed by adding the line
.PP
.Vb 1
\&  use PDL::NiceSlice;
.Ve
.PP
\&\f(CW\*(C`before\*(C'\fR the code in \fItest1.pl\fR that uses the
new slicing syntax (to play safe just include the line
near the top of the file), e.g.
.PP
.Vb 6
\&   # begin corrected test1.pl
\&   use PDL::NiceSlice;
\&   $aa = sequence 11;
\&   print $aa(0:7),"\en";
\&   1;
\&   # end test1.pl
.Ve
.PP
Now things proceed more smoothly
.PP
.Vb 3
\&  perl test0.pl
\& [0 1 2 3 4]
\& [0 1 2 3 4 5 6 7]
.Ve
.PP
Note that we don't need to issue \f(CW\*(C`use PDL\*(C'\fR again.
\&\f(CW\*(C`PDL::NiceSlice\*(C'\fR is a somewhat \fIfunny\fR module in
that respect. It is a consequence of the way source
filtering works in Perl (see also the \s-1IMPLEMENTATION\s0
section below).
.ie n .SS "evals and ""PDL::NiceSlice"""
.el .SS "evals and \f(CWPDL::NiceSlice\fP"
.IX Subsection "evals and PDL::NiceSlice"
Due to \f(CW\*(C`PDL::NiceSlice\*(C'\fR being a source filter it won't work
in the usual way within evals. The following will \fInot\fR do what
you want:
.PP
.Vb 2
\&  $x = sequence 10;
\&  eval << \*(AqEOE\*(Aq;
\&
\&  use PDL::NiceSlice;
\&  $y = $x(0:5);
\&
\&  EOE
\&  print $y;
.Ve
.PP
Instead say:
.PP
.Vb 3
\&  use PDL::NiceSlice;
\&  $x = sequence 10;
\&  eval << \*(AqEOE\*(Aq;
\&
\&  $y = $x(0:5);
\&
\&  EOE
\&  print $y;
.Ve
.PP
Source filters \fImust\fR be executed at compile time to be effective. And
\&\f(CW\*(C`PDL::NiceSlice\*(C'\fR is just a source filter (although it is not
necessarily obvious for the casual user).
.SH "The new slicing syntax"
.IX Header "The new slicing syntax"
Using \f(CW\*(C`PDL::NiceSlice\*(C'\fR slicing ndarrays becomes so much easier since, first of
all, you don't need to make explicit method calls. No
.PP
.Vb 1
\&  $pdl\->slice(....);
.Ve
.PP
calls, etc. Instead, \f(CW\*(C`PDL::NiceSlice\*(C'\fR introduces two ways in which to
slice ndarrays without too much typing:
.IP "\(bu" 2
using parentheses directly following a scalar variable name,
for example
.Sp
.Vb 1
\&   $c = $y(0:\-3:4,(0));
.Ve
.IP "\(bu" 2
using the so called \fIdefault method\fR invocation in which the
ndarray object is treated as if it were a reference to a
subroutine (see also perlref). Take this example that slices
an ndarray that is part of a perl list \f(CW@b\fR:
.Sp
.Vb 1
\&  $c = $b[0]\->(0:\-3:4,(0));
.Ve
.PP
The format of the argument list is the same for both types of
invocation and will be explained in more detail below.
.SS "Parentheses following a scalar variable name"
.IX Subsection "Parentheses following a scalar variable name"
An arglist in parentheses following directly after a scalar variable
name that is \fInot\fR preceded by \f(CW\*(C`&\*(C'\fR will be resolved as a slicing
command, e.g.
.PP
.Vb 2
\&  $x(1:4) .= 2;         # only use this syntax on ndarrays
\&  $sum += $x(,(1));
.Ve
.PP
However, if the variable name is immediately preceded by a \f(CW\*(C`&\*(C'\fR,
for example
.PP
.Vb 1
\&  &$x(4,5);
.Ve
.PP
it will not be interpreted as a slicing expression. Rather, to avoid
interfering with the current subref syntax, it will be treated as an
invocation of the code reference \f(CW$x\fR with argumentlist \f(CW\*(C`(4,5)\*(C'\fR.
.PP
The $x(\s-1ARGS\s0) syntax collides in a minor way with the perl syntax.  In
particular, ``foreach \f(CW$va\fRr(\s-1LIST\s0)'' appears like a \s-1PDL\s0 slicing call.  
NiceSlice avoids translating the ``for \f(CW$va\fRr(\s-1LIST\s0)'' and 
``foreach \f(CW$va\fRr(\s-1LIST\s0)'' constructs for this reason.  Since you
can't use just any old lvalue expression in the 'foreach' 'for'
constructs \*(-- only a real perl scalar will do \*(-- there's no 
functionality lost.  If later versions of perl accept 
``foreach <lvalue\-expr> (\s-1LIST\s0)'', then you can use the code ref
syntax, below, to get what you want.
.SS "The \fIdefault method\fP syntax"
.IX Subsection "The default method syntax"
The second syntax that will be recognized is what I called the
\&\fIdefault method\fR syntax. It is the method arrow \f(CW\*(C`\->\*(C'\fR directly
followed by an open parenthesis, e.g.
.PP
.Vb 1
\&  $x\->transpose\->(($pos)) .= 0;
.Ve
.PP
Note that this conflicts with the use of normal code references, since you
can write in plain Perl
.PP
.Vb 2
\&  $sub = sub { print join \*(Aq,\*(Aq, @_ };
\&  $sub\->(1,\*(Aqa\*(Aq);
.Ve
.PP
\&\s-1NOTE:\s0 Once \f(CW\*(C`use PDL::NiceSlice\*(C'\fR is in effect (you can always switch it off with
a line \f(CW\*(C`no PDL::NiceSlice;\*(C'\fR anywhere in the script) the source filter will incorrectly
replace the above call to \f(CW$sub\fR with an invocation of the slicing method.
This is one of the pitfalls of using a source filter that doesn't know
anything about the runtime type of a variable (cf. the
Implementation section).
.PP
This shouldn't be a major problem in practice; a simple workaround is to use
the \f(CW\*(C`&\*(C'\fR\-way of calling subrefs, e.g.:
.PP
.Vb 2
\&  $sub = sub { print join \*(Aq,\*(Aq, @_ };
\&  &$sub(1,\*(Aqa\*(Aq);
.Ve
.SS "When to use which syntax?"
.IX Subsection "When to use which syntax?"
Why are there two different ways to invoke slicing?
The first syntax \f(CW\*(C`$x(args)\*(C'\fR doesn't work with chained method calls. E.g.
.PP
.Vb 1
\&  $x\->xchg(0,1)(0);
.Ve
.PP
won't work. It can \fIonly\fR be used directly following a valid perl variable
name. Instead, use the \fIdefault method\fR syntax in such cases:
.PP
.Vb 1
\&  $x\->transpose\->(0);
.Ve
.PP
Similarly, if you have a list of ndarrays \f(CW@pdls\fR:
.PP
.Vb 1
\&  $y = $pdls[5]\->(0:\-1);
.Ve
.SS "The argument list"
.IX Subsection "The argument list"
The argument list is a comma separated list. Each argument specifies
how the corresponding dimension in the ndarray is sliced. In contrast
to usage of the \*(L"slice\*(R" in PDL::Slices method the arguments should
\&\fInot\fR be quoted. Rather freely mix literals (1,3,etc), perl
variables and function invocations, e.g.
.PP
.Vb 1
\&  $x($pos\-1:$end,myfunc(1,3)) .= 5;
.Ve
.PP
There can even be other slicing commands in the arglist:
.PP
.Vb 1
\&  $x(0:\-1:$pdl($step)) *= 2;
.Ve
.PP
\&\s-1NOTE:\s0 If you use function calls in the arglist make sure that
you use parentheses around their argument lists. Otherwise the
source filter will get confused since it splits the argument
list on commas that are not protected by parentheses. Take
the following example:
.PP
.Vb 6
\&  sub myfunc { return 5*$_[0]+$_[1] }
\&  $x = sequence 10;
\&  $sl = $x(0:myfunc 1, 2);
\&  print $sl;
\& PDL barfed: Error in slice:Too many dims in slice
\& Caught at file /usr/local/bin/perldl, line 232, pkg main
.Ve
.PP
The simple fix is
.PP
.Vb 3
\&  $sl = $x(0:myfunc(1, 2));
\&  print $sl;
\& [0 1 2 3 4 5 6 7]
.Ve
.PP
Note that using prototypes in the definition of myfunc does not help.
At this stage the source filter is simply not intelligent enough to
make use of this information. So beware of this subtlety.
.PP
Another pitfall to be aware of: currently, you can't use the conditional
operator in slice expressions (i.e., \f(CW\*(C`?:\*(C'\fR, since the parser confuses them
with ranges). For example, the following will cause an error:
.PP
.Vb 4
\&  $x = sequence 10;
\&  $y = rand > 0.5 ? 0 : 1; # this one is ok
\&  print $x($y ? 1 : 2);    # error !
\& syntax error at (eval 59) line 3, near "1,
.Ve
.PP
For the moment, just try to stay clear of the conditional operator
in slice expressions (or provide us with a patch to the parser to
resolve this issue ;).
.SS "Modifiers"
.IX Subsection "Modifiers"
Following a suggestion originally put forward by Karl Glazebrook the
latest versions of \f(CW\*(C`PDL::NiceSlice\*(C'\fR implement \fImodifiers\fR in slice
expressions. Modifiers are convenient shorthands for common variations
on \s-1PDL\s0 slicing. The general syntax is
.PP
.Vb 1
\&    $pdl(<slice>;<modifier>)
.Ve
.PP
Four modifiers are currently implemented:
.IP "\(bu" 4
\&\f(CW\*(C`_\*(C'\fR : \fIflatten\fR the ndarray before applying the slice expression. Here
is an example
.Sp
.Vb 3
\&   $y = sequence 3, 3;
\&   print $y(0:\-2;_); # same as $y\->flat\->(0:\-2)
\& [0 1 2 3 4 5 6 7]
.Ve
.Sp
which is quite different from the same slice expression without the modifier
.Sp
.Vb 6
\&   print $y(0:\-2);
\& [
\&  [0 1]
\&  [3 4]
\&  [6 7]
\& ]
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`|\*(C'\fR : sever the link to the ndarray, e.g.
.Sp
.Vb 6
\&   $x = sequence 10;
\&   $y = $x(0:2;|)++;  # same as $x(0:2)\->sever++
\&   print $y;
\& [1 2 3]
\&   print $x; # check if $x has been modified
\& [0 1 2 3 4 5 6 7 8 9]
.Ve
.IP "\(bu" 4
\&\f(CW\*(C`?\*(C'\fR : short hand to indicate that this is really a
where expression
.Sp
As expressions like
.Sp
.Vb 1
\&  $x\->where($x>5)
.Ve
.Sp
are used very often you can write that shorter as
.Sp
.Vb 1
\&  $x($x>5;?)
.Ve
.Sp
With the \f(CW\*(C`?\*(C'\fR\-modifier the expression preceding the modifier is \fInot\fR
really a slice expression (e.g. ranges are not allowed) but rather an
expression as required by the where method.
For example, the following code will raise an error:
.Sp
.Vb 3
\&  $x = sequence 10;
\&  print $x(0:3;?);
\& syntax error at (eval 70) line 3, near "0:"
.Ve
.Sp
That's about all there is to know about this one.
.IP "\(bu" 4
\&\f(CW\*(C`\-\*(C'\fR : \fIsqueeze\fR out any singleton dimensions. In less technical terms:
reduce the number of dimensions (potentially) by deleting all
dims of size 1. It is equivalent to doing a reshape(\-1).
That can be very handy if you want to simplify
the results of slicing operations:
.Sp
.Vb 4
\&  $x = ones 3, 4, 5;
\&  $y = $x(1,0;\-); # easier to type than $x((1),(0))
\&  print $y\->info;
\& PDL: Double D [5]
.Ve
.Sp
It also provides a unique opportunity to have smileys in your code!
Yes, \s-1PDL\s0 gives new meaning to smileys.
.SS "Combining modifiers"
.IX Subsection "Combining modifiers"
Several modifiers can be used in the same expression, e.g.
.PP
.Vb 1
\&  $c = $x(0;\-|); # squeeze and sever
.Ve
.PP
Other combinations are just as useful, e.g. \f(CW\*(C`;_|\*(C'\fR to flatten and
sever. The sequence in which modifiers are specified is not important.
.PP
A notable exception is the \f(CW\*(C`where\*(C'\fR modifier (\f(CW\*(C`?\*(C'\fR) which must not
be combined with other flags (let me know if you see a good reason
to relax this rule).
.PP
Repeating any modifier will raise an error:
.PP
.Vb 2
\&  $c = $x(\-1:1;|\-|); # will cause error
\& NiceSlice error: modifier | used twice or more
.Ve
.PP
Modifiers are still a new and experimental feature of
\&\f(CW\*(C`PDL::NiceSlice\*(C'\fR. I am not sure how many of you are actively using
them. \fIPlease do so and experiment with the syntax\fR. I think
modifiers are very useful and make life a lot easier.  Feedback is
welcome as usual. The modifier syntax will likely be further tuned in
the future but we will attempt to ensure backwards compatibility
whenever possible.
.SS "Argument formats"
.IX Subsection "Argument formats"
In slice expressions you can use ranges and secondly,
ndarrays as 1D index lists (although compare the description
of the \f(CW\*(C`?\*(C'\fR\-modifier above for an exception).
.IP "\(bu" 2
ranges
.Sp
You can access ranges using the usual \f(CW\*(C`:\*(C'\fR separated format:
.Sp
.Vb 1
\&  $x($start:$stop:$step) *= 4;
.Ve
.Sp
Note that you can omit the trailing step which then defaults to 1.  Double
colons (\f(CW\*(C`::\*(C'\fR) are not allowed to avoid clashes with Perl's namespace
syntax. So if you want to use steps different from the default
you have to also at least specify the stop position.
Examples:
.Sp
.Vb 2
\&  $x(::2);   # this won\*(Aqt work (in the way you probably intended)
\&  $x(:\-1:2); # this will select every 2nd element in the 1st dim
.Ve
.Sp
Just as with \*(L"slice\*(R" in PDL::Slices negative indices count from the end of the dimension
backwards with \f(CW\*(C`\-1\*(C'\fR being the last element. If the start index is larger
than the stop index the resulting ndarray will have the elements in reverse
order between these limits:
.Sp
.Vb 2
\&  print $x(\-2:0:2);
\& [8 6 4 2 0]
.Ve
.Sp
A single index just selects the given index in the slice
.Sp
.Vb 2
\&  print $x(5);
\& [5]
.Ve
.Sp
Note, however, that the corresponding dimension is not removed from
the resulting ndarray but rather reduced to size 1:
.Sp
.Vb 2
\&  print $x(5)\->info
\& PDL: Double D [1]
.Ve
.Sp
If you want to get completely rid of that dimension enclose the index
in parentheses (again similar to the \*(L"slice\*(R" in PDL::Slices syntax):
.Sp
.Vb 2
\&  print $x((5));
\& 5
.Ve
.Sp
In this particular example a 0D ndarray results. Note that this syntax is
only allowed with a single index. All these will be errors:
.Sp
.Vb 2
\&  print $x((0,4));  # will work but not in the intended way
\&  print $x((0:4));  # compile time error
.Ve
.Sp
An empty argument selects the whole dimension, in this example
all of the first dimension:
.Sp
.Vb 1
\&  print $x(,(0));
.Ve
.Sp
Alternative ways to select a whole dimension are
.Sp
.Vb 5
\&  $x = sequence 5, 5; 
\&  print $x(:,(0));
\&  print $x(0:\-1,(0));
\&  print $x(:\-1,(0));
\&  print $x(0:,(0));
.Ve
.Sp
Arguments for trailing dimensions can be omitted. In that case
these dimensions will be fully kept in the sliced ndarray:
.Sp
.Vb 9
\&  $x = random 3,4,5;
\&  print $x\->info;
\& PDL: Double D [3,4,5]
\&  print $x((0))\->info;
\& PDL: Double D [4,5]
\&  print $x((0),:,:)\->info;  # a more explicit way
\& PDL: Double D [4,5]
\&  print $x((0),,)\->info;    # similar
\& PDL: Double D [4,5]
.Ve
.IP "\(bu" 2
dummy dimensions
.Sp
As in \*(L"slice\*(R" in PDL::Slices, you can insert a dummy dimension by preceding a
single index argument with '*'.  A lone '*' inserts a dummy dimension of 
order 1; a '*' followed by a number inserts a dummy dimension of that order.
.IP "\(bu" 2
ndarray index lists
.Sp
The second way to select indices from a dimension is via 1D ndarrays
of indices. A simple example:
.Sp
.Vb 3
\&  $x = random 10;
\&  $idx = long 3,4,7,0;
\&  $y = $x($idx);
.Ve
.Sp
This way of selecting indices was previously only possible using
\&\*(L"dice\*(R" in PDL::Slices (\f(CW\*(C`PDL::NiceSlice\*(C'\fR attempts to unify the
\&\f(CW\*(C`slice\*(C'\fR and \f(CW\*(C`dice\*(C'\fR interfaces). Note that the indexing ndarrays must
be 1D or 0D. Higher dimensional ndarrays as indices will raise an error:
.Sp
.Vb 4
\&  $x = sequence 5, 5;
\&  $idx2 = ones 2,2;
\&  $sum = $x($idx2)\->sum;
\& ndarray must be <= 1D at /home/XXXX/.perldlrc line 93
.Ve
.Sp
Note that using index ndarrays is not as efficient as using ranges.
If you can represent the indices you want to select using a range
use that rather than an equivalent index ndarray. In particular,
memory requirements are increased with index ndarrays (and execution
time \fImay\fR be longer). That said, if an index ndarray is the way to
go use it!
.PP
As you might have expected ranges and index ndarrays can be freely
mixed in slicing expressions:
.PP
.Vb 2
\&  $x = random 5, 5;
\&  $y = $x(\-1:2,pdl(3,0,1));
.Ve
.SS "ndarrays as indices in ranges"
.IX Subsection "ndarrays as indices in ranges"
You can use ndarrays to specify indices in ranges. No need to
turn them into proper perl scalars with the new slicing syntax.
However, make sure they contain not more than one element! Otherwise
a runtime error will be triggered. First a couple of examples that
illustrate proper usage:
.PP
.Vb 11
\&  $x = sequence 5, 5;
\&  $rg = pdl(1,\-1,3);
\&  print $x($rg(0):$rg(1):$rg(2),2);
\& [
\&  [11 14]
\& ]
\&  print $x($rg+1,:$rg(0));
\& [
\&  [2 0 4]
\&  [7 5 9]
\& ]
.Ve
.PP
The next one raises an error
.PP
.Vb 2
\&  print $x($rg+1,:$rg(0:1));
\& multielement ndarray where only one allowed at XXX/Core.pm line 1170.
.Ve
.PP
The problem is caused by using the 2\-element ndarray \f(CW\*(C`$rg(0:1)\*(C'\fR as the
stop index in the second argument \f(CW\*(C`:$rg(0:1)\*(C'\fR that is interpreted as
a range by \f(CW\*(C`PDL::NiceSlice\*(C'\fR. You \fIcan\fR use multielement ndarrays as
index ndarrays as described above but not in ranges. And
\&\f(CW\*(C`PDL::NiceSlice\*(C'\fR treats any expression with unprotected \f(CW\*(C`:\*(C'\fR's as a
range.  \fIUnprotected\fR means as usual 
\&\fI\*(L"not occurring between matched parentheses\*(R"\fR.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
\&\f(CW\*(C`PDL::NiceSlice\*(C'\fR exploits the ability of Perl to use source filtering
(see also perlfilter). A source filter basically filters (or
rewrites) your perl code before it is seen by the
compiler. \f(CW\*(C`PDL::NiceSlice\*(C'\fR searches through your Perl source code and when
it finds the new slicing syntax it rewrites the argument list
appropriately and splices a call to the \f(CW\*(C`slice\*(C'\fR method using the
modified arg list into your perl code. You can see how this works in
the perldl or pdl2 shells by switching on
reporting (see above how to do that).
.SH "BUGS"
.IX Header "BUGS"
.SS "Conditional operator"
.IX Subsection "Conditional operator"
The conditional operator can't be used in slice expressions (see
above).
.ie n .SS "The ""DATA"" file handle"
.el .SS "The \f(CWDATA\fP file handle"
.IX Subsection "The DATA file handle"
\&\fINote\fR: To avoid clobbering the \f(CW\*(C`DATA\*(C'\fR filehandle \f(CW\*(C`PDL::NiceSlice\*(C'\fR
switches itself off when encountering the \f(CW\*(C`_\|_END_\|_\*(C'\fR or \f(CW\*(C`_\|_DATA_\|_\*(C'\fR tokens.
This should not be a problem for you unless you use \f(CW\*(C`SelfLoader\*(C'\fR to load
\&\s-1PDL\s0 code including the new slicing from that section. It is even desirable
when working with Inline::Pdlpp, see below.
.SS "Possible interaction with Inline::Pdlpp"
.IX Subsection "Possible interaction with Inline::Pdlpp"
There is currently an undesired interaction between \f(CW\*(C`PDL::NiceSlice\*(C'\fR
and Inline::Pdlpp. Since \s-1PP\s0 code generally
contains expressions of the type \f(CW\*(C`$var()\*(C'\fR (to access ndarrays, etc)
\&\f(CW\*(C`PDL::NiceSlice\*(C'\fR recognizes those \fIincorrectly\fR as
slice expressions and does its substitutions. This is not a problem
if you use the \f(CW\*(C`DATA\*(C'\fR section for your Pdlpp code \*(-- the recommended
place for Inline code anyway. In that case
\&\f(CW\*(C`PDL::NiceSlice\*(C'\fR will have switched itself off before encountering any
Pdlpp code (see above):
.PP
.Vb 4
\&    # use with Inline modules
\&  use PDL;
\&  use PDL::NiceSlice;
\&  use Inline Pdlpp;
\&
\&  $x = sequence(10);
\&  print $x(0:5);
\&
\&  _\|_END_\|_
\&
\&  _\|_Pdlpp_\|_
\&
\&  ... inline stuff
.Ve
.PP
Otherwise switch \f(CW\*(C`PDL::NiceSlice\*(C'\fR explicitly off around the
Inline::Pdlpp code:
.PP
.Vb 1
\&  use PDL::NiceSlice;
\&
\&  $x = sequence 10;
\&  $x(0:3)++;
\&  $x\->inc;
\&
\&  no PDL::NiceSlice; # switch off before Pdlpp code
\&  use Inline Pdlpp => "Pdlpp source code";
.Ve
.PP
The cleaner solution is to always stick with the
\&\f(CW\*(C`DATA\*(C'\fR way of including your \f(CW\*(C`Inline\*(C'\fR code as
in the first example. That way you keep your nice Perl
code at the top and all the ugly Pdlpp stuff etc at
the bottom.
.SS "Bug reports"
.IX Subsection "Bug reports"
Feedback and bug reports are welcome. Please include an example
that demonstrates the problem. Log bug reports in the \s-1PDL\s0
issues tracker at <https://github.com/PDLPorters/pdl/issues>
or send them to the pdl-devel mailing list
(see <http://pdl.perl.org/?page=mailing\-lists>).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001, 2002 Christian Soeller. All Rights Reserved.
This module is free software. It may be used, redistributed
and/or modified under the same terms as \s-1PDL\s0 itself
(see <http://pdl.perl.org>).
