.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "FITS 3"
.TH FITS 3 "2022-04-20" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::IO::FITS \- Simple FITS support for PDL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use PDL;
\& use PDL::IO::FITS;
\&
\& $x = rfits(\*(Aqfoo.fits\*(Aq);          # read a FITS file
\& $x\->wfits(\*(Aqbar.fits\*(Aq);           # write a FITS file
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides basic \s-1FITS\s0 support for \s-1PDL,\s0 in the sense of
reading and writing whole \s-1FITS\s0 files. For more complex operations,
such as prefiltering rows out of tables or performing operations on
the \s-1FITS\s0 file in-place on disk, you can use the Astro::FITS::CFITSIO
module that is available on \s-1CPAN.\s0
.PP
Basic \s-1FITS\s0 image files are supported, along with \s-1BINTABLE\s0 and \s-1IMAGE\s0 extensions.
\&\s-1ASCII\s0 Table support is planned, as are the \s-1HEASARC\s0 bintable extensions that
are recommended in the 1999 \s-1FITS\s0 standard.
.PP
Table support is based on hashes and named columns, rather than the
less convenient (but slightly more congruent) technique of perl lists
of numbered columns.
.PP
The principle interface routines are \f(CW\*(C`rfits\*(C'\fR and \f(CW\*(C`wfits\*(C'\fR, for
reading and writing respectively.  \s-1FITS\s0 headers are returned as perl
hashes or (if the module is present) Astro::FITS::Header objects that
are tied to perl hashes.  Astro::FITS::Header objects provide
convenient access through the tied hash interface, but also allow you
to control the card structure in more detail using a separate method
interface; see the Astro::FITS::Header
documentation for details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Karl Glazebrook, Craig DeForest, and Doug Burke, 1997\-2010.
There is no warranty.  You are allowed to redistribute and/or modify
this software under certain conditions.  For details, see the file
\&\s-1COPYING\s0 in the \s-1PDL\s0 distribution.  If this file is separated from the 
\&\s-1PDL\s0 distribution, the copyright notice should be pasted into in this file.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\fBrfits()\fP"
.IX Subsection "rfits()"
Simple ndarray \s-1FITS\s0 reader.
.PP
.Vb 1
\&  $pdl = rfits(\*(Aqfile.fits\*(Aq);   # Read a simple FITS image
.Ve
.PP
Suffix magic:
.PP
.Vb 2
\&  $pdl = rfits(\*(Aqfile.fits.gz\*(Aq); # Read a file with gunzip(1)
\&  $pdl = rfits(\*(Aqfile.fits.Z\*(Aq);  # Read a file with uncompress(1)
\&
\&  $pdl = rfits(\*(Aqfile.fits[2]\*(Aq);    # Read 2nd extension
\&  $pdl = rfits(\*(Aqfile.fits.gz[3]\*(Aq); # Read 3rd extension
\&  @pdls = rfits(\*(Aqfile.fits\*(Aq);      # Read primary data and extensions
.Ve
.PP
Tilde expansion:
.PP
.Vb 2
\&  #expand leading ~ to home directory (using glob())
\&  $pdl = rfits \*(Aq~/filename.fits\*(Aq;
\&
\&  $hdr = rfits(\*(Aqfile.fits\*(Aq,{data=>0});  # Options hash changes behavior
.Ve
.PP
In list context, \f(CW\*(C`rfits\*(C'\fR reads the primary image and all possible
extensions, returning them in the same order that they occurred in the
file \*(-- except that, by default, the primary \s-1HDU\s0 is skipped if it
contains no data.  In scalar context, the default is to read the first
\&\s-1HDU\s0 that contains data. One can read other \s-1HDU\s0's by using the [n]
syntax.  Using the [0] syntax forces a read of the first \s-1HDU,\s0
regardless of whether it contains data or no.  Currently recognized
extensions are \s-1IMAGE\s0 and \s-1BINTABLE.\s0  (See the addendum on \s-1EXTENSIONS\s0
for details).
.PP
\&\f(CW\*(C`rfits\*(C'\fR accepts several options that may be passed in as a hash ref
if desired:
.IP "bscale (default=1)" 3
.IX Item "bscale (default=1)"
Determines whether the data are linearly scaled using the \s-1BSCALE/BZERO\s0 keywords
in the \s-1FITS\s0 header.  To read in the exact data values in the file, set this
to 0.
.IP "data (default=1)" 3
.IX Item "data (default=1)"
Determines whether to read the data, or just the header.  If you set this to 
0, you will get back the \s-1FITS\s0 header rather than the data themselves.  (Note
that the header is normally returned as the \f(CW\*(C`hdr\*(C'\fR field of the returned \s-1PDL\s0;
this causes it to be returned as a hash ref directly.)
.IP "hdrcpy (default=0)" 3
.IX Item "hdrcpy (default=0)"
Determines whether the hdrcpy flag is set in the returned
\&\s-1PDL.\s0  Setting the flag will cause an explicit deep copy of the header whenever
you use the returned \s-1PDL\s0 in an arithmetic or slicing operation.  That is useful
in many circumstances but also causes a hit in speed.  When two or more PDLs 
with hdrcpy set are used in an expression, the result gets the header of the 
first \s-1PDL\s0 in the expression.  See hdrcpy for an example.
.IP "expand (default=1)" 3
.IX Item "expand (default=1)"
Determines whether auto-expansion of tile-compressed images should happen.
Tile-compressed images are transmitted as binary tables with particular
fields (\*(L"\s-1ZIMAGE\*(R"\s0) set.  Leaving this alone does what you want most of the
time, unpacking such images transparently and returning the data and header
as if they were part of a normal \s-1IMAGE\s0 extension.  Setting \*(L"expand\*(R" to 0
delivers the binary table, rather than unpacking it into an image.
.IP "afh (default=1)" 3
.IX Item "afh (default=1)"
By default rfits uses Astro::FITS::Header tied-hash objects to contain
the \s-1FITS\s0 header information.  This permits explicit control over \s-1FITS\s0
card information, and conforms well with the \s-1FITS\s0 specification.  But
Astro::FITS::Header objects are about 40\-60x more memory intensive
than comparable perl hashes, and also use ~10x more \s-1CPU\s0 to manage.
For jobs where header processing performance is important (e.g. reading 
just the headers of 1,000 \s-1FITS\s0 files), set afh to 0 to use the legacy parser
and get a large boost in speed.
.PP
\&\s-1FITS\s0 image headers are stored in the output \s-1PDL\s0 and can be retrieved
with hdr or gethdr.  The
hdrcpy flag of the \s-1PDL\s0 is set so that the header
is copied to derived ndarrays by default.  (This is inefficient if you
are planning to do lots of small operations on the data; clear
the flag with \*(L"\->\fBhcpy\fR\|(0)\*(R" or via the options hash if that's the case.)
.PP
The header is a hash whose keys are the keywords in the \s-1FITS\s0 header.
If you have the \*(L"Astro::FITS::Header\*(R" module installed, the header is
actually a tied hash to a \s-1FITS\s0 header object, which can give you
more control over card order, comment fields, and variable types.
(see Astro::FITS::Header for details).
.PP
The header keywords are converted to \fIuppercase\fR per the \s-1FITS\s0
standard.  Access is case-insensitive on the perl side, provided that
Astro::FITS::Header is installed.
.PP
If Astro::FITS::Header is not installed, then a built-in legacy parser
is used to generate the header hash.  Keyword-associated comments in
the headers are stored under the hash key
\&\f(CW\*(C`<keyword>_COMMENT>\*(C'\fR.  All \s-1HISTORY\s0 cards in the header are
collected into a single multiline string stored in the \f(CW\*(C`HISTORY\*(C'\fR key.
All \s-1COMMENT\s0 cards are similarly collected under the \f(CW\*(C`COMMENT\*(C'\fR key.
.PP
\fI\s-1BSCALE/BZERO\s0\fR
.IX Subsection "BSCALE/BZERO"
.PP
If the \s-1BSCALE\s0 and/or \s-1BZERO\s0 keywords are set, they are applied to the
image before it is returned.  The returned \s-1PDL\s0 is promoted as
necessary to contain the multiplied values, and the \s-1BSCALE\s0 and \s-1BZERO\s0
keywords are deleted from the header for clarity.  If you don't want
this type of processing, set 'bscale=>0' in the options hash.
.PP
\fI\s-1EXTENSIONS\s0\fR
.IX Subsection "EXTENSIONS"
.PP
Sometimes a \s-1FITS\s0 file contains only extensions and a stub header in
the first header/data unit (\*(L"primary \s-1HDU\*(R"\s0).  In scalar context, you
normally only get back the primary \s-1HDU\s0 \*(-- but in this special case,
you get back the first extension \s-1HDU.\s0  You can force a read of the
primary \s-1HDU\s0 by adding a '[0]' suffix to the file name.
.PP
\fI\s-1BINTABLE EXTENSIONS\s0\fR
.IX Subsection "BINTABLE EXTENSIONS"
.PP
Binary tables are handled. Currently only the following \s-1PDL\s0
datatypes are supported: byte, short, ushort, long, float, and
double. At present \fBushort()\fR data is written as a long rather than
as a short with \s-1TSCAL/ZERO\s0; this may change.
.PP
The return value for a binary table is a hash ref containing the names
of the columns in the table (in \s-1UPPER CASE\s0 as per the \s-1FITS\s0 standard).
Each element of the hash contains a \s-1PDL\s0 (for numerical values) or a
perl list (for string values).  The \s-1PDL\s0's 0th dimension runs across
rows; the 1st dimension runs across the repeat index within the row
(for rows with more than one value).  (Note that this is different from
standard broadcasting order \- but it allows Least Surprise to work when
adding more complicated objects such as collections of numbers (via
the repeat count) or variable length arrays.)
.PP
Thus, if your table contains a column named \f(CW\*(C`FOO\*(C'\fR with type \f(CW\*(C`5D\*(C'\fR,
the expression
.PP
.Vb 1
\&  $x\->{FOO}\->((2))
.Ve
.PP
returns a 5\-element double-precision \s-1PDL\s0 containing the values of \s-1FOO\s0
from the third row of the table.
.PP
The header of the table itself is parsed as with a normal \s-1FITS HDU,\s0
and is returned in the element 'hdr' of the returned hash.  You can
use that to preserve the original column order or access the table at a low
level, if you like.
.PP
Scaling and zero-point adjustment are performed as with \s-1BSCALE/BZERO:\s0
the appropriate keywords are deleted from the as-returned header.  To avoid
this behavior, set 'bscale=>0' in the options hash.
.PP
As appropriate, \s-1TSCAL/ZERO\s0 and \s-1TUNIT\s0 are copied into each column-PDL's
header as \s-1BSCALE/BZERO\s0 and \s-1BUNIT.\s0
.PP
The main hash also contains the element 'tbl', which is set
to 'binary' to distinguish it from an \s-1ASCII\s0 table.
.PP
Because different columns in the table might have identical names in a
\&\s-1FITS\s0 file, the binary table reader practices collision avoidance.  If
you have multiple columns named \*(L"\s-1FOO\*(R",\s0 then the first one encountered
(numerically) gets the name \*(L"\s-1FOO\*(R",\s0 the next one gets \*(L"\s-1FOO_1\*(R",\s0 and the
next \*(L"\s-1FOO_2\*(R",\s0 etc.  The appropriate TTYPEn fields in the header are
changed to match the renamed column fields.
.PP
Columns with no name are assigned the name \*(L"COL_<n>\*(R", where <n> starts
at 1 and increments for each no-name column found.
.PP
Variable-length arrays are supported for reading.  They are unpacked
into PDLs that appear exactly the same as the output for fixed-length
rows, except that each row is padded to the maximum length given
in the extra characters \*(-- e.g. a row with \s-1TFORM\s0 of 1PB(300) will
yield an NAXIS2x300 output field in the final hash.   The padding 
uses the \s-1TNUL\s0n keyword for the column, or 0 if \s-1TNUL\s0n is not
present.  The output hash also gets an additional field, \*(L"len_<name>\*(R",
that contains the number of elements in each table row.
.PP
\fITILE-COMPRESSED \s-1IMAGES\s0\fR
.IX Subsection "TILE-COMPRESSED IMAGES"
.PP
\&\s-1CFITSIO\s0 and several large projects (including \s-1NASA\s0's Solar Dynamics
Observatory) now support an unofficial extension to \s-1FITS\s0 that stores
images as a collection of individually compressed tiles within a
\&\s-1BINTABLE\s0 extension.  These images are automagically uncompressed by
default, and delivered as if they were normal image files.  You can 
override this behavior by supplying the \*(L"expand\*(R" key in the options hash.
.PP
Currently, only Rice compression is supported, though there is a framework
in place for adding other compression schemes.
.PP
\fI\s-1BAD VALUE HANDLING\s0\fR
.IX Subsection "BAD VALUE HANDLING"
.PP
If a \s-1FITS\s0 file contains the \f(CW\*(C`BLANK\*(C'\fR keyword (and has \f(CW\*(C`BITPIX > 0\*(C'\fR), 
the ndarray will have its bad flag set, and those elements which equal the
\&\f(CW\*(C`BLANK\*(C'\fR value will be set bad.  For \f(CW\*(C`BITPIX < 0\*(C'\fR, any NaN's are
converted to bad (if necessary).
.SS "\fBrfitshdr()\fP"
.IX Subsection "rfitshdr()"
Read only the header of a \s-1FITS\s0 file or an extension within it.
.PP
This is syntactic sugar for the \f(CW\*(C`data=>0\*(C'\fR option to rfits.
.PP
See rfits for details on header handling.  \fBrfitshdr()\fR runs 
the same code to read the header, but returns it rather than 
reading in a data structure as well.
.SS "\fBwfits()\fP"
.IX Subsection "wfits()"
Simple \s-1PDL FITS\s0 writer
.PP
.Vb 3
\&  wfits $pdl, \*(Aqfilename.fits\*(Aq, [$BITPIX], [$COMPRESSION_OPTIONS];
\&  wfits $hash, \*(Aqfilename.fits\*(Aq, [$OPTIONS];
\&  $pdl\->wfits(\*(Aqfoo.fits\*(Aq,\-32);
.Ve
.PP
Suffix magic:
.PP
.Vb 4
\&  # Automatically compress through pipe to gzip
\&  wfits $pdl, \*(Aqfilename.fits.gz\*(Aq;
\&  # Automatically compress through pipe to compress 
\&  wfits $pdl, \*(Aqfilename.fits.Z\*(Aq;
.Ve
.PP
Tilde expansion:
.PP
.Vb 2
\&  #expand leading ~ to home directory (using glob())
\&  wfits $pdl, \*(Aq~/filename.fits\*(Aq;
.Ve
.IP "\(bu" 3
Ordinary (\s-1PDL\s0) data handling:
.Sp
If the first argument is a \s-1PDL,\s0 then the \s-1PDL\s0 is written out as an
ordinary \s-1FITS\s0 file with a single Header/Data Unit of data.
.Sp
\&\f(CW$BITPIX\fR is then optional and coerces the output data type according to 
the standard \s-1FITS\s0 convention for the \s-1BITPIX\s0 field (with positive 
values representing integer types and negative values representing
floating-point types).
.Sp
If \f(CW$pdl\fR has a \s-1FITS\s0 header attached to it (actually, any hash that
contains a \f(CW\*(C`SIMPLE=>T\*(C'\fR keyword), then that \s-1FITS\s0 header is written
out to the file.  The image dimension tags are adjusted to the actual
dataset.  If there's a mismatch between the dimensions of the data and
the dimensions in the \s-1FITS\s0 header, then the header gets corrected and
a warning is printed.
.Sp
If \f(CW$pdl\fR is a slice of another \s-1PDL\s0 with a \s-1FITS\s0 header already
present (and header copying enabled), then you must be careful.
\&\f(CW\*(C`wfits\*(C'\fR will remove any extraneous \f(CW\*(C`NAXISn\*(C'\fR keywords (per the \s-1FITS\s0
standard), and also remove the other keywords associated with that
axis: \f(CW\*(C`CTYPEn\*(C'\fR, \f(CW\*(C`CRPIXn\*(C'\fR, \f(CW\*(C`CRVALn\*(C'\fR, \f(CW\*(C`CDELTn\*(C'\fR, and \f(CW\*(C`CROTAn\*(C'\fR.  This
may cause confusion if the slice is \s-1NOT\s0 out of the last dimension:
\&\f(CW\*(C`wfits($x(:,(0),:),\*(Aqfile.fits\*(Aq);\*(C'\fR and you would be best off adjusting
the header yourself before calling \f(CW\*(C`wfits\*(C'\fR.
.Sp
You can tile-compress images according to the \s-1CFITSIO\s0 extension to the 
\&\s-1FITS\s0 standard, by adding an option hash to the arguments:
.RS 3
.IP "compress" 3
.IX Item "compress"
This can be either unity, in which case Rice compression is used,
or a (case-insensitive) string matching the \s-1CFITSIO\s0 compression 
type names.  Currently supported compression algorithms are:
.RS 3
.IP "\(bu" 3
\&\s-1RICE_1\s0 \- linear Rice compression
.Sp
This uses limited-symbol-length Rice compression, which works well on 
low entropy image data (where most pixels differ from their neighbors 
by much less than the dynamic range of the image).
.RE
.RS 3
.RE
.ie n .IP "\s-1BLOCKSIZE\s0 (\s-1RICE_1\s0 only; default 32)" 3
.el .IP "\s-1BLOCKSIZE\s0 (\s-1RICE_1\s0 only; default \f(CW32\fR)" 3
.IX Item "BLOCKSIZE (RICE_1 only; default 32)"
For \s-1RICE_1,\s0 indicates the number of pixel samples to use
for each compression block within the compression algorithm.  The 
blocksize is independent of the tile dimensions.  For \s-1RICE\s0
compression the pixels from each tile are arranged in normal pixel 
order (early dims fastest) and compressed as a linear stream.
.RE
.RS 3
.RE
.IP "\(bu" 3
Table handling:
.Sp
If you feed in a hash ref instead of a \s-1PDL,\s0 then the hash ref is
written out as a binary table extension.  The hash ref keys are
treated as column names, and their values are treated as the data to
be put in each column.
.Sp
For numeric information, the hash values should contain PDLs.  The 0th
dim of the \s-1PDL\s0 runs across rows, and higher dims are written as
multi-value entries in the table (e.g. a 7x5 \s-1PDL\s0 will yield a single
named column with 7 rows and 5 numerical entries per row, in a binary
table).  Note that this is slightly different from the usual concept
of broadcasting, in which dimension 1 runs across rows.
.Sp
\&\s-1ASCII\s0 tables only allow one entry per column in each row, so
if you plan to write an \s-1ASCII\s0 table then all of the values of \f(CW$hash\fR
should have at most one dim.
.Sp
All of the columns' 0 dims must agree in the broadcasting sense. That is to
say, the 0th dimension of all of the values of \f(CW$hash\fR should be the
same (indicating that all columns have the same number of rows).  As
an exception, if the 0th dim of any of the values is 1, or if that
value is a \s-1PDL\s0 scalar (with 0 dims), then that value is \*(L"broadcasted\*(R"
over \*(-- copied into all rows.
.Sp
Data dimensions higher than 2 are preserved in binary tables,
via the TDIMn field (e.g. a 7x5x3 \s-1PDL\s0 is stored internally as 
seven rows with 15 numerical entries per row, and reconstituted
as a 7x5x3 \s-1PDL\s0 on read).
.Sp
Non-PDL Perl scalars are treated as strings, even if they contain
numerical values.  For example, a list ref containing 7 values is
treated as 7 rows containing one string each.  There is no such thing
as a multi-string column in \s-1FITS\s0 tables, so any nonscalar values in
the list are stringified before being written.  For example, if you
pass in a perl list of 7 PDLs, each \s-1PDL\s0 will be stringified before
being written, just as if you printed it to the screen.  This is
probably not what you want \*(-- you should use \*(L"glue\*(R" to connect 
the separate PDLs into a single one.  (e.g. \f(CW\*(C`$x\->glue(1,$y,$c)\->mv(1,0)\*(C'\fR)
.Sp
The column names are case-insensitive, but by convention the keys of
\&\f(CW$hash\fR should normally be \s-1ALL CAPS,\s0 containing only digits, capital
letters, hyphens, and underscores.  If you include other characters,
then case is smashed to \s-1ALL CAPS,\s0 whitespace is converted to
underscores, and unrecognized characters are ignored \*(-- so if you
include the key \*(L"Au Purity (%)\*(R", it will be written to the file as a
column that is named \*(L"\s-1AU_PURITY\*(R".\s0  Since this is not guaranteed to 
produce unique column names, subsequent columns by the same name are
disambiguated by the addition of numbers.
.Sp
You can specify the use of variable-length rows in the output, saving
space in the file.  To specify variable length rows for a column named
\&\*(L"\s-1FOO\*(R",\s0 you can include a separate key \*(L"len_FOO\*(R" in the hash to be
written.  The key's value should be a \s-1PDL\s0 containing the number of
actual samples in each row.  The result is a \s-1FITS\s0 P\-type variable
length column that, upon read with \f(CW\*(C`rfits()\*(C'\fR, will restore to a field
named \s-1FOO\s0 and a corresponding field named \*(L"len_FOO\*(R".  Invalid data in
the final \s-1PDL\s0 consist of a padding value (which defaults to 0 but
which you may set by including a \s-1TNULL\s0 field in the hdr specificaion).
Variable length arrays must be 2\-D PDLs, with the variable length in
the 1 dimension.
.Sp
Two further special keys, 'hdr' and 'tbl', can contain
meta-information about the type of table you want to write.  You may
override them by including an \f(CW$OPTIONS\fR hash with a 'hdr' and/or
\&'tbl' key.
.Sp
The 'tbl' key, if it exists, must contain either '\s-1ASCII\s0' or 'binary'
(case-insensitive), indicating whether to write an ascii or binary
table.  The default is binary. [\s-1ASCII\s0 table writing is planned but
does not yet exist].
.Sp
You can specify the format of the table quite specifically with the
\&'hdr' key or option field.  If it exists, then the 'hdr' key should
contain fields appropriate to the table extension being used.  Any
field information that you don't specify will be filled in
automatically, so (for example) you can specify that a particular
column name goes in a particular position, but allow \f(CW\*(C`wfits\*(C'\fR to
arrange the other columns in the usual alphabetical order into any
unused slots that you leave behind.  The \f(CW\*(C`TFORMn\*(C'\fR, \f(CW\*(C`TFIELDS\*(C'\fR,
\&\f(CW\*(C`PCOUNT\*(C'\fR, \f(CW\*(C`GCOUNT\*(C'\fR, \f(CW\*(C`NAXIS\*(C'\fR, and \f(CW\*(C`NAXISn\*(C'\fR keywords are ignored:
their values are calculated based on the hash that you supply.  Any
other fields are passed into the final \s-1FITS\s0 header verbatim.
.Sp
As an example, the following
.Sp
.Vb 3
\&  $x = long(1,2,4);
\&  $y = double(1,2,4);
\&  wfits { \*(AqCOLA\*(Aq=>$x, \*(AqCOLB\*(Aq=>$y }, "table1.fits";
.Ve
.Sp
will create a binary \s-1FITS\s0 table called \fItable1.fits\fR which
contains two columns called \f(CW\*(C`COLA\*(C'\fR and \f(CW\*(C`COLB\*(C'\fR. The order
of the columns is controlled by setting the \f(CW\*(C`TTYPEn\*(C'\fR
keywords in the header array, so
.Sp
.Vb 2
\&  $h = { \*(AqTTYPE1\*(Aq=>\*(AqY\*(Aq, \*(AqTTYPE2\*(Aq=>\*(AqX\*(Aq };
\&  wfits { \*(AqX\*(Aq=>$x, \*(AqY\*(Aq=>$y, hdr=>$h }, "table2.fits";
.Ve
.Sp
creates \fItable2.fits\fR where the first column is
called \f(CW\*(C`Y\*(C'\fR and the second column is \f(CW\*(C`X\*(C'\fR.
.IP "\(bu" 3
multi-value handling
.Sp
If you feed in a perl array-ref rather than a \s-1PDL\s0 or a hash, then
each element is written out as a separate \s-1HDU\s0 in the \s-1FITS\s0 file.  
Each element of the list must be a \s-1PDL\s0 or a hash.
.IP "\(bu" 3
\&\s-1DEVEL NOTES\s0
.Sp
\&\s-1ASCII\s0 tables are not yet handled but should be.
.Sp
Binary tables currently only handle one vector (up to 1\-D array) 
per table entry; the standard allows more, and should be fully implemented.
.Sp
Handling multidim arrays implies that perl multidim lists should also be
handled.
.PP
For integer types (ie \f(CW\*(C`BITPIX > 0\*(C'\fR), the \f(CW\*(C`BLANK\*(C'\fR keyword is set
to the bad value.  For floating-point types, the bad value is
converted to NaN (if necessary) before writing.
.SS "fits_field_cmp"
.IX Subsection "fits_field_cmp"
fits_field_cmp
.PP
Sorting comparison routine that makes proper sense of the digits at the end
of some \s-1FITS\s0 header fields.  Sort your hash keys using \*(L"fits_field_cmp\*(R" and 
you will get (e.g.) your \*(L"\s-1TTYPE\*(R"\s0 fields in the correct order even if there
are 140 of them.
.PP
This is a standard perl comparison sub \*(-- it uses the magical
\&\f(CW$a\fR and \f(CW$b\fR variables, rather than normal argument passing.
.SS "\fB_rows()\fP"
.IX Subsection "_rows()"
Return the number of rows in a variable for table entry
.PP
You feed in a \s-1PDL\s0 or a list ref, and you get back the 0th dimension.
.SS "\fB_prep_table()\fP"
.IX Subsection "_prep_table()"
Accept a hash ref containing a table, and return a header describing the table
and a string to be written out as the table, or barf.
.PP
You can indicate whether the table should be binary or ascii.  The default
is binary; it can be overridden by the \*(L"tbl\*(R" field of the hash (if present)
or by parameter.
