.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Ufunc 3"
.TH Ufunc 3 "2022-08-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Ufunc \- primitive ufunc operations for pdl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides some primitive and useful functions defined
using \s-1PDL::PP\s0 based on functionality of what are sometimes called
\&\fIufuncs\fR (for example NumPY and Mathematica talk about these).
It collects all the functions generally used to \f(CW\*(C`reduce\*(C'\fR or
\&\f(CW\*(C`accumulate\*(C'\fR along a dimension. These all do their job across the
first dimension but by using the slicing functions you can do it
on any dimension.
.PP
The PDL::Reduce module provides an alternative interface
to many of the functions in this module.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use PDL::Ufunc;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "prodover"
.IX Subsection "prodover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via product to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the product along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = prodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = prodover $image\->transpose
.Ve
.PP
prodover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "cprodover"
.IX Subsection "cprodover"
.Vb 1
\&  Signature: (a(n); cdouble [o]b())
.Ve
.PP
Project via product to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the product along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = cprodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = cprodover $image\->transpose
.Ve
.PP
Unlike \*(L"prodover\*(R", the calculations are performed in complex double
precision.
.PP
cprodover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "dprodover"
.IX Subsection "dprodover"
.Vb 1
\&  Signature: (a(n); double [o]b())
.Ve
.PP
Project via product to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the product along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = dprodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = dprodover $image\->transpose
.Ve
.PP
Unlike \*(L"prodover\*(R", the calculations are performed in double precision.
.PP
dprodover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "cumuprodover"
.IX Subsection "cumuprodover"
.Vb 1
\&  Signature: (a(n); int+ [o]b(n))
.Ve
.PP
Cumulative product
.PP
This function calculates the cumulative product
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative product
is the first element of the parameter.
.PP
.Vb 1
\& $y = cumuprodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = cumuprodover $image\->transpose
.Ve
.PP
cumuprodover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "dcumuprodover"
.IX Subsection "dcumuprodover"
.Vb 1
\&  Signature: (a(n); double [o]b(n))
.Ve
.PP
Cumulative product
.PP
This function calculates the cumulative product
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative product
is the first element of the parameter.
.PP
.Vb 1
\& $y = dcumuprodover($x);
.Ve
.PP
.Vb 1
\& $spectrum = dcumuprodover $image\->transpose
.Ve
.PP
Unlike \*(L"cumuprodover\*(R", the calculations are performed in double precision.
.PP
dcumuprodover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "sumover"
.IX Subsection "sumover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via sum to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the sum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = sumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = sumover $image\->transpose
.Ve
.PP
sumover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "csumover"
.IX Subsection "csumover"
.Vb 1
\&  Signature: (a(n); cdouble [o]b())
.Ve
.PP
Project via sum to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the sum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = csumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = csumover $image\->transpose
.Ve
.PP
Unlike \*(L"sumover\*(R", the calculations are performed in complex double
precision.
.PP
csumover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "dsumover"
.IX Subsection "dsumover"
.Vb 1
\&  Signature: (a(n); double [o]b())
.Ve
.PP
Project via sum to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the sum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = dsumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = dsumover $image\->transpose
.Ve
.PP
Unlike \*(L"sumover\*(R", the calculations are performed in double precision.
.PP
dsumover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "cumusumover"
.IX Subsection "cumusumover"
.Vb 1
\&  Signature: (a(n); int+ [o]b(n))
.Ve
.PP
Cumulative sum
.PP
This function calculates the cumulative sum
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative sum
is the first element of the parameter.
.PP
.Vb 1
\& $y = cumusumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = cumusumover $image\->transpose
.Ve
.PP
cumusumover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "dcumusumover"
.IX Subsection "dcumusumover"
.Vb 1
\&  Signature: (a(n); double [o]b(n))
.Ve
.PP
Cumulative sum
.PP
This function calculates the cumulative sum
along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
The sum is started so that the first element in the cumulative sum
is the first element of the parameter.
.PP
.Vb 1
\& $y = dcumusumover($x);
.Ve
.PP
.Vb 1
\& $spectrum = dcumusumover $image\->transpose
.Ve
.PP
Unlike \*(L"cumusumover\*(R", the calculations are performed in double precision.
.PP
dcumusumover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "andover"
.IX Subsection "andover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via and to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the and along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = andover($x);
.Ve
.PP
.Vb 1
\& $spectrum = andover $image\->transpose
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "bandover"
.IX Subsection "bandover"
.Vb 1
\&  Signature: (a(n);  [o]b())
.Ve
.PP
Project via bitwise and to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the bitwise and along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = bandover($x);
.Ve
.PP
.Vb 1
\& $spectrum = bandover $image\->transpose
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "borover"
.IX Subsection "borover"
.Vb 1
\&  Signature: (a(n);  [o]b())
.Ve
.PP
Project via bitwise or to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the bitwise or along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = borover($x);
.Ve
.PP
.Vb 1
\& $spectrum = borover $image\->transpose
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "orover"
.IX Subsection "orover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via or to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the or along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = orover($x);
.Ve
.PP
.Vb 1
\& $spectrum = orover $image\->transpose
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "zcover"
.IX Subsection "zcover"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via == 0 to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the == 0 along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = zcover($x);
.Ve
.PP
.Vb 1
\& $spectrum = zcover $image\->transpose
.Ve
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data (and its bad flag is set), 
\&\f(CW\*(C`b()\*(C'\fR is set bad. Otherwise \f(CW\*(C`b()\*(C'\fR will have its bad flag cleared,
as it will not contain any bad values.
.SS "intover"
.IX Subsection "intover"
.Vb 1
\&  Signature: (a(n); float+ [o]b())
.Ve
.PP
Project via integral to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the integral along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = intover($x);
.Ve
.PP
.Vb 1
\& $spectrum = intover $image\->transpose
.Ve
.PP
Notes:
.PP
\&\f(CW\*(C`intover\*(C'\fR uses a point spacing of one (i.e., delta\-h==1).  You will
need to scale the result to correct for the true point delta).
.PP
For \f(CW\*(C`n > 3\*(C'\fR, these are all \f(CW\*(C`O(h^4)\*(C'\fR (like Simpson's rule), but are
integrals between the end points assuming the pdl gives values just at
these centres: for such `functions', sumover is correct to \f(CWO(h)\fR, but
is the natural (and correct) choice for binned data, of course.
.PP
intover ignores the bad-value flag of the input ndarrays.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "average"
.IX Subsection "average"
.Vb 1
\&  Signature: (a(n); int+ [o]b())
.Ve
.PP
Project via average to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the average along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = average($x);
.Ve
.PP
.Vb 1
\& $spectrum = average $image\->transpose
.Ve
.PP
average processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "avgover"
.IX Subsection "avgover"
.Vb 1
\&  Synonym for average.
.Ve
.SS "caverage"
.IX Subsection "caverage"
.Vb 1
\&  Signature: (a(n); cdouble [o]b())
.Ve
.PP
Project via average to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the average along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = caverage($x);
.Ve
.PP
.Vb 1
\& $spectrum = caverage $image\->transpose
.Ve
.PP
Unlike average, the calculation is performed in complex double
precision.
.PP
caverage processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "cavgover"
.IX Subsection "cavgover"
.Vb 1
\&  Synonym for caverage.
.Ve
.SS "daverage"
.IX Subsection "daverage"
.Vb 1
\&  Signature: (a(n); double [o]b())
.Ve
.PP
Project via average to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the average along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = daverage($x);
.Ve
.PP
.Vb 1
\& $spectrum = daverage $image\->transpose
.Ve
.PP
Unlike average, the calculation is performed in double
precision.
.PP
daverage processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "davgover"
.IX Subsection "davgover"
.Vb 1
\&  Synonym for daverage.
.Ve
.SS "minimum"
.IX Subsection "minimum"
.Vb 1
\&  Signature: (a(n); [o]c())
.Ve
.PP
Project via minimum to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the minimum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = minimum($x);
.Ve
.PP
.Vb 1
\& $spectrum = minimum $image\->transpose
.Ve
.PP
Output is set bad if no elements of the input are non-bad,
otherwise the bad flag is cleared for the output ndarray.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values and will \*(L"win\*(R" over non\-\f(CW\*(C`NaN\*(C'\fR;
see isfinite and badmask
for ways of masking NaNs.
.SS "minover"
.IX Subsection "minover"
.Vb 1
\&  Synonym for minimum.
.Ve
.SS "minimum_ind"
.IX Subsection "minimum_ind"
.Vb 1
\&  Signature: (a(n); indx [o] c())
.Ve
.PP
Like minimum but returns the index rather than the value
.PP
Output is set bad if no elements of the input are non-bad,
otherwise the bad flag is cleared for the output ndarray.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values and will \*(L"win\*(R" over non\-\f(CW\*(C`NaN\*(C'\fR;
see isfinite and badmask
for ways of masking NaNs.
.SS "minover_ind"
.IX Subsection "minover_ind"
.Vb 1
\&  Synonym for minimum_ind.
.Ve
.SS "minimum_n_ind"
.IX Subsection "minimum_n_ind"
.Vb 1
\&  Signature: (a(n); indx [o]c(m); PDL_Indx m_size => m)
.Ve
.PP
Returns the index of \f(CW\*(C`m_size\*(C'\fR minimum elements. As of 2.077, you can
specify how many by either passing in an ndarray of the given size
(\s-1DEPRECATED\s0 \- will be converted to indx if needed and the input arg will
be set to that), or just the size, or a null and the size.
.PP
.Vb 3
\&  minimum_n_ind($pdl, $out = zeroes(5)); # DEPRECATED
\&  $out = minimum_n_ind($pdl, 5);
\&  minimum_n_ind($pdl, $out = null, 5);
.Ve
.PP
Output bad flag is cleared for the output ndarray if sufficient non-bad elements found,
else remaining slots in \f(CW\*(C`$c()\*(C'\fR are set bad.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values and will \*(L"win\*(R" over non\-\f(CW\*(C`NaN\*(C'\fR;
see isfinite and badmask
for ways of masking NaNs.
.SS "minover_n_ind"
.IX Subsection "minover_n_ind"
.Vb 1
\&  Synonym for minimum_n_ind.
.Ve
.SS "maximum"
.IX Subsection "maximum"
.Vb 1
\&  Signature: (a(n); [o]c())
.Ve
.PP
Project via maximum to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the maximum along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = maximum($x);
.Ve
.PP
.Vb 1
\& $spectrum = maximum $image\->transpose
.Ve
.PP
Output is set bad if no elements of the input are non-bad,
otherwise the bad flag is cleared for the output ndarray.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values and will \*(L"win\*(R" over non\-\f(CW\*(C`NaN\*(C'\fR;
see isfinite and badmask
for ways of masking NaNs.
.SS "maxover"
.IX Subsection "maxover"
.Vb 1
\&  Synonym for maximum.
.Ve
.SS "maximum_ind"
.IX Subsection "maximum_ind"
.Vb 1
\&  Signature: (a(n); indx [o] c())
.Ve
.PP
Like maximum but returns the index rather than the value
.PP
Output is set bad if no elements of the input are non-bad,
otherwise the bad flag is cleared for the output ndarray.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values and will \*(L"win\*(R" over non\-\f(CW\*(C`NaN\*(C'\fR;
see isfinite and badmask
for ways of masking NaNs.
.SS "maxover_ind"
.IX Subsection "maxover_ind"
.Vb 1
\&  Synonym for maximum_ind.
.Ve
.SS "maximum_n_ind"
.IX Subsection "maximum_n_ind"
.Vb 1
\&  Signature: (a(n); indx [o]c(m); PDL_Indx m_size => m)
.Ve
.PP
Returns the index of \f(CW\*(C`m_size\*(C'\fR maximum elements. As of 2.077, you can
specify how many by either passing in an ndarray of the given size
(\s-1DEPRECATED\s0 \- will be converted to indx if needed and the input arg will
be set to that), or just the size, or a null and the size.
.PP
.Vb 3
\&  maximum_n_ind($pdl, $out = zeroes(5)); # DEPRECATED
\&  $out = maximum_n_ind($pdl, 5);
\&  maximum_n_ind($pdl, $out = null, 5);
.Ve
.PP
Output bad flag is cleared for the output ndarray if sufficient non-bad elements found,
else remaining slots in \f(CW\*(C`$c()\*(C'\fR are set bad.
.PP
Note that \f(CW\*(C`NaNs\*(C'\fR are considered to be valid values and will \*(L"win\*(R" over non\-\f(CW\*(C`NaN\*(C'\fR;
see isfinite and badmask
for ways of masking NaNs.
.SS "maxover_n_ind"
.IX Subsection "maxover_n_ind"
.Vb 1
\&  Synonym for maximum_n_ind.
.Ve
.SS "minmaximum"
.IX Subsection "minmaximum"
.Vb 1
\&  Signature: (a(n); [o]cmin(); [o] cmax(); indx [o]cmin_ind(); indx [o]cmax_ind())
.Ve
.PP
Find minimum and maximum and their indices for a given ndarray;
.PP
.Vb 4
\& pdl> $x=pdl [[\-2,3,4],[1,0,3]]
\& pdl> ($min, $max, $min_ind, $max_ind)=minmaximum($x)
\& pdl> p $min, $max, $min_ind, $max_ind
\& [\-2 0] [4 3] [0 1] [2 2]
.Ve
.PP
See also \*(L"minmax\*(R", which clumps the ndarray together.
.PP
If \f(CW\*(C`a()\*(C'\fR contains only bad data, then the output ndarrays will
be set bad, along with their bad flag.
Otherwise they will have their bad flags cleared,
since they will not contain any bad values.
.SS "minmaxover"
.IX Subsection "minmaxover"
.Vb 1
\&  Synonym for minmaximum.
.Ve
.SS "avg"
.IX Subsection "avg"
Return the average of all elements in an ndarray.
.PP
See the documentation for \*(L"average\*(R" for more information.
.PP
.Vb 1
\& $x = avg($data);
.Ve
.PP
This routine handles bad values.
.SS "sum"
.IX Subsection "sum"
Return the sum of all elements in an ndarray.
.PP
See the documentation for \*(L"sumover\*(R" for more information.
.PP
.Vb 1
\& $x = sum($data);
.Ve
.PP
This routine handles bad values.
.SS "prod"
.IX Subsection "prod"
Return the product of all elements in an ndarray.
.PP
See the documentation for \*(L"prodover\*(R" for more information.
.PP
.Vb 1
\& $x = prod($data);
.Ve
.PP
This routine handles bad values.
.SS "davg"
.IX Subsection "davg"
Return the average (in double precision) of all elements in an ndarray.
.PP
See the documentation for \*(L"daverage\*(R" for more information.
.PP
.Vb 1
\& $x = davg($data);
.Ve
.PP
This routine handles bad values.
.SS "dsum"
.IX Subsection "dsum"
Return the sum (in double precision) of all elements in an ndarray.
.PP
See the documentation for \*(L"dsumover\*(R" for more information.
.PP
.Vb 1
\& $x = dsum($data);
.Ve
.PP
This routine handles bad values.
.SS "dprod"
.IX Subsection "dprod"
Return the product (in double precision) of all elements in an ndarray.
.PP
See the documentation for \*(L"dprodover\*(R" for more information.
.PP
.Vb 1
\& $x = dprod($data);
.Ve
.PP
This routine handles bad values.
.SS "zcheck"
.IX Subsection "zcheck"
Return the check for zero of all elements in an ndarray.
.PP
See the documentation for \*(L"zcover\*(R" for more information.
.PP
.Vb 1
\& $x = zcheck($data);
.Ve
.PP
This routine handles bad values.
.SS "and"
.IX Subsection "and"
Return the logical and of all elements in an ndarray.
.PP
See the documentation for \*(L"andover\*(R" for more information.
.PP
.Vb 1
\& $x = and($data);
.Ve
.PP
This routine handles bad values.
.SS "band"
.IX Subsection "band"
Return the bitwise and of all elements in an ndarray.
.PP
See the documentation for \*(L"bandover\*(R" for more information.
.PP
.Vb 1
\& $x = band($data);
.Ve
.PP
This routine handles bad values.
.SS "or"
.IX Subsection "or"
Return the logical or of all elements in an ndarray.
.PP
See the documentation for \*(L"orover\*(R" for more information.
.PP
.Vb 1
\& $x = or($data);
.Ve
.PP
This routine handles bad values.
.SS "bor"
.IX Subsection "bor"
Return the bitwise or of all elements in an ndarray.
.PP
See the documentation for \*(L"borover\*(R" for more information.
.PP
.Vb 1
\& $x = bor($data);
.Ve
.PP
This routine handles bad values.
.SS "min"
.IX Subsection "min"
Return the minimum of all elements in an ndarray.
.PP
See the documentation for \*(L"minimum\*(R" for more information.
.PP
.Vb 1
\& $x = min($data);
.Ve
.PP
This routine handles bad values.
.SS "max"
.IX Subsection "max"
Return the maximum of all elements in an ndarray.
.PP
See the documentation for \*(L"maximum\*(R" for more information.
.PP
.Vb 1
\& $x = max($data);
.Ve
.PP
This routine handles bad values.
.SS "median"
.IX Subsection "median"
Return the median of all elements in an ndarray.
.PP
See the documentation for \*(L"medover\*(R" for more information.
.PP
.Vb 1
\& $x = median($data);
.Ve
.PP
This routine handles bad values.
.SS "mode"
.IX Subsection "mode"
Return the mode of all elements in an ndarray.
.PP
See the documentation for \*(L"modeover\*(R" for more information.
.PP
.Vb 1
\& $x = mode($data);
.Ve
.PP
This routine handles bad values.
.SS "oddmedian"
.IX Subsection "oddmedian"
Return the oddmedian of all elements in an ndarray.
.PP
See the documentation for \*(L"oddmedover\*(R" for more information.
.PP
.Vb 1
\& $x = oddmedian($data);
.Ve
.PP
This routine handles bad values.
.SS "any"
.IX Subsection "any"
Return true if any element in ndarray set
.PP
Useful in conditional expressions:
.PP
.Vb 1
\& if (any $x>15) { print "some values are greater than 15\en" }
.Ve
.PP
See \*(L"or\*(R" for comments on what happens when all elements
in the check are bad.
.SS "all"
.IX Subsection "all"
Return true if all elements in ndarray set
.PP
Useful in conditional expressions:
.PP
.Vb 1
\& if (all $x>15) { print "all values are greater than 15\en" }
.Ve
.PP
See \*(L"and\*(R" for comments on what happens when all elements
in the check are bad.
.SS "minmax"
.IX Subsection "minmax"
Returns a list with minimum and maximum values of an ndarray.
.PP
.Vb 1
\& ($mn, $mx) = minmax($pdl);
.Ve
.PP
This routine does \fInot\fR broadcast over the dimensions of \f(CW$pdl\fR;
it returns the minimum and maximum values of the whole ndarray.
See \*(L"minmaximum\*(R" if this is not what is required.
The two values are returned as Perl scalars,
and therefore ignore whether the values are bad.
.PP
.Vb 4
\& pdl> $x = pdl [1,\-2,3,5,0]
\& pdl> ($min, $max) = minmax($x);
\& pdl> p "$min $max\en";
\& \-2 5
.Ve
.SS "medover"
.IX Subsection "medover"
.Vb 1
\&  Signature: (a(n); [o]b(); [t]tmp(n))
.Ve
.PP
Project via median to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the median along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = medover($x);
.Ve
.PP
.Vb 1
\& $spectrum = medover $image\->transpose
.Ve
.PP
medover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "oddmedover"
.IX Subsection "oddmedover"
.Vb 1
\&  Signature: (a(n); [o]b(); [t]tmp(n))
.Ve
.PP
Project via oddmedian to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the oddmedian along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = oddmedover($x);
.Ve
.PP
.Vb 1
\& $spectrum = oddmedover $image\->transpose
.Ve
.PP
The median is sometimes not a good choice as if the array has
an even number of elements it lies half-way between the two
middle values \- thus it does not always correspond to a data
value. The lower-odd median is just the lower of these two values
and so it \s-1ALWAYS\s0 sits on an actual data value which is useful in
some circumstances.
.PP
oddmedover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "modeover"
.IX Subsection "modeover"
.Vb 1
\&  Signature: (data(n); [o]out(); [t]sorted(n))
.Ve
.PP
Project via mode to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the mode along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = modeover($x);
.Ve
.PP
.Vb 1
\& $spectrum = modeover $image\->transpose
.Ve
.PP
The mode is the single element most frequently found in a 
discrete data set.
.PP
It \fIonly\fR makes sense for integer data types, since
floating-point types are demoted to integer before the
mode is calculated.
.PP
\&\f(CW\*(C`modeover\*(C'\fR treats \s-1BAD\s0 the same as any other value:  if
\&\s-1BAD\s0 is the most common element, the returned value is also \s-1BAD.\s0
.PP
modeover does not process bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "pctover"
.IX Subsection "pctover"
.Vb 1
\&  Signature: (a(n); p(); [o]b(); [t]tmp(n))
.Ve
.PP
Project via specified percentile to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the specified percentile along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = pctover($x);
.Ve
.PP
.Vb 1
\& $spectrum = pctover $image\->transpose
.Ve
.PP
The specified
percentile must be between 0.0 and 1.0.  When the specified percentile
falls between data points, the result is interpolated.  Values outside
the allowed range are clipped to 0.0 or 1.0 respectively.  The algorithm
implemented here is based on the interpolation variant described at
<http://en.wikipedia.org/wiki/Percentile> as used by Microsoft Excel
and recommended by \s-1NIST.\s0
.PP
pctover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "oddpctover"
.IX Subsection "oddpctover"
.Vb 1
\&  Signature: (a(n); p(); [o]b(); [t]tmp(n))
.Ve
.PP
Project via specified percentile to N\-1 dimensions
.PP
This function reduces the dimensionality of an ndarray
by one by taking the specified percentile along the 1st dimension.
.PP
By using xchg etc. it is possible to use
\&\fIany\fR dimension.
.PP
.Vb 1
\& $y = oddpctover($x);
.Ve
.PP
.Vb 1
\& $spectrum = oddpctover $image\->transpose
.Ve
.PP
The specified
percentile must be between 0.0 and 1.0.  When the specified percentile
falls between two values, the nearest data value is the result.
The algorithm implemented is from the textbook version described
first at <http://en.wikipedia.org/wiki/Percentile>.
.PP
oddpctover processes bad values.
It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.
.SS "pct"
.IX Subsection "pct"
Return the specified percentile of all elements in an ndarray. The
specified percentile (p) must be between 0.0 and 1.0.  When the
specified percentile falls between data points, the result is interpolated.
.PP
.Vb 1
\& $x = pct($data, $pct);
.Ve
.SS "oddpct"
.IX Subsection "oddpct"
Return the specified percentile of all elements in an ndarray. The
specified percentile (p) must be between 0.0 and 1.0.  When the
specified percentile falls between data points, the nearest data value is the result.
.PP
.Vb 1
\& $x = oddpct($data, $pct);
.Ve
.SS "qsort"
.IX Subsection "qsort"
.Vb 1
\&  Signature: (a(n); [o]b(n))
.Ve
.PP
Quicksort a vector into ascending order.
.PP
.Vb 1
\& print qsort random(10);
.Ve
.PP
Bad values are moved to the end of the array:
.PP
.Vb 4
\& pdl> p $y
\& [42 47 98 BAD 22 96 74 41 79 76 96 BAD 32 76 25 59 BAD 96 32 BAD]
\& pdl> p qsort($y)
\& [22 25 32 32 41 42 47 59 74 76 76 79 96 96 96 98 BAD BAD BAD BAD]
.Ve
.SS "qsorti"
.IX Subsection "qsorti"
.Vb 1
\&  Signature: (a(n); indx [o]indx(n))
.Ve
.PP
Quicksort a vector and return index of elements in ascending order.
.PP
.Vb 2
\& $ix = qsorti $x;
\& print $x\->index($ix); # Sorted list
.Ve
.PP
Bad elements are moved to the end of the array:
.PP
.Vb 4
\& pdl> p $y
\& [42 47 98 BAD 22 96 74 41 79 76 96 BAD 32 76 25 59 BAD 96 32 BAD]
\& pdl> p $y\->index( qsorti($y) )
\& [22 25 32 32 41 42 47 59 74 76 76 79 96 96 96 98 BAD BAD BAD BAD]
.Ve
.SS "qsortvec"
.IX Subsection "qsortvec"
.Vb 1
\&  Signature: (a(n,m); [o]b(n,m))
.Ve
.PP
Sort a list of vectors lexicographically.
.PP
The 0th dimension of the source ndarray is dimension in the vector;
the 1st dimension is list order.  Higher dimensions are broadcasted over.
.PP
.Vb 9
\& print qsortvec pdl([[1,2],[0,500],[2,3],[4,2],[3,4],[3,5]]);
\& [
\&  [  0 500]
\&  [  1   2]
\&  [  2   3]
\&  [  3   4]
\&  [  3   5]
\&  [  4   2]
\& ]
.Ve
.PP
Vectors with bad components are moved to the end of the array:
.PP
.Vb 1
\&  pdl> p $p = pdl("[0 0] [\-100 0] [BAD 0] [100 0]")\->qsortvec
\&
\&  [
\&   [\-100    0]
\&   [   0    0]
\&   [ 100    0]
\&   [ BAD    0]
\&  ]
.Ve
.SS "qsortveci"
.IX Subsection "qsortveci"
.Vb 1
\&  Signature: (a(n,m); indx [o]indx(m))
.Ve
.PP
Sort a list of vectors lexicographically, returning the indices of the
sorted vectors rather than the sorted list itself.
.PP
As with \f(CW\*(C`qsortvec\*(C'\fR, the input \s-1PDL\s0 should be an NxM array containing M
separate N\-dimensional vectors.  The return value is an integer M\-PDL 
containing the M\-indices of original array rows, in sorted order.
.PP
As with \f(CW\*(C`qsortvec\*(C'\fR, the zeroth element of the vectors runs slowest in the
sorted list.
.PP
Additional dimensions are broadcasted over: each plane is sorted separately,
so qsortveci may be thought of as a collapse operator of sorts (groan).
.PP
Vectors with bad components are moved to the end of the array as
for \*(L"qsortvec\*(R".
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Tuomas J. Lukka 1997 (lukka@husc.harvard.edu).
Contributions by Christian Soeller (c.soeller@auckland.ac.nz)
and Karl Glazebrook (kgb@aaoepp.aao.gov.au).  All rights
reserved. There is no warranty. You are allowed to redistribute this
software / documentation under certain conditions. For details, see
the file \s-1COPYING\s0 in the \s-1PDL\s0 distribution. If this file is separated
from the \s-1PDL\s0 distribution, the copyright notice should be included in
the file.
