.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "API 1"
.TH API 1 "2022-02-14" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::API \- making ndarrays from Perl and C/XS code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use PDL;
\&  sub mkmyndarray {
\&   ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A simple cookbook how to create ndarrays manually.
It covers both the Perl and the C/XS level.
Additionally, it describes the \s-1PDL\s0 core routines
that can be accessed from other modules. These
routines basically define the \s-1PDL API.\s0 If you need to
access ndarrays from C/XS you probably need to know
about these functions.
.PP
Also described is the new (as of \s-1PDL 2.058\s0) access to \s-1PDL\s0 operations
via C functions, which the \s-1XS\s0 functions now call.
.SS "Creating an ndarray manually from Perl"
.IX Subsection "Creating an ndarray manually from Perl"
Sometimes you want to create an ndarray \fImanually\fR
from binary data. You can do that at the Perl level.
Examples in the distribution include some of the
\&\s-1IO\s0 routines. The code snippet below illustrates the
required steps.
.PP
.Vb 7
\&   use Carp;
\&   sub mkmyndarray {
\&     my $class = shift;
\&     my $pdl  = $class\->new;
\&     $pdl\->set_datatype($PDL_B);
\&     $pdl\->setdims([1,3,4]);
\&     my $dref = $pdl\->get_dataref();
\&
\&     # read data directly from file
\&     open my $file, \*(Aq<data.dat\*(Aq or die "couldn\*(Aqt open data.dat";
\&     my $len = $pdl\->nelems*PDL::Core::howbig($pdl\->get_datatype);
\&     croak "couldn\*(Aqt read enough data" if
\&       read( $file, $$dref, $len) != $len;
\&     close $file;
\&     $pdl\->upd_data();
\&
\&     return $pdl;
\&   }
.Ve
.SS "Creating an ndarray in C"
.IX Subsection "Creating an ndarray in C"
The following example creates an ndarray at the C level.
We use the \f(CW\*(C`Inline\*(C'\fR module which is a good way to interface
Perl and C, using the \f(CW\*(C`with\*(C'\fR capability in Inline 0.68+.
.PP
Note that to create a \*(L"scalar\*(R" ndarray (with no dimensions at all,
and a single element), just pass a zero-length \f(CW\*(C`dims\*(C'\fR array, with
\&\f(CW\*(C`ndims\*(C'\fR as zero.
.PP
.Vb 1
\&   use PDL::LiteF;
\&
\&   $x = myfloatseq(); # exercise our C ndarray constructor
\&
\&   print $x\->info,"\en";
\&
\&   use Inline with => \*(AqPDL\*(Aq;
\&   use Inline C;
\&   Inline\->init; # useful if you want to be able to \*(Aqdo\*(Aq\-load this script
\&
\&   _\|_DATA_\|_
\&
\&   _\|_C_\|_
\&
\&   static pdl* new_pdl(int datatype, PDL_Indx dims[], int ndims)
\&   {
\&     pdl *p = PDL\->pdlnew();
\&     if (!p) return p;
\&     pdl_error err = PDL\->setdims(p, dims, ndims);  /* set dims */
\&     if (err.error) { PDL\->destroy(p); return NULL; }
\&     p\->datatype = datatype;         /* and data type */
\&     err = PDL\->allocdata (p);       /* allocate the data chunk */
\&     if (err.error) { PDL\->destroy(p); return NULL; }
\&     return p;
\&   }
\&
\&   pdl* myfloatseq()
\&   {
\&     PDL_Indx dims[] = {5,5,5};
\&     pdl *p = new_pdl(PDL_F,dims,3);
\&     if (!p) return p;
\&     PDL_Float *dataf = (PDL_Float *) p\->data;
\&     PDL_Indx i; /* dimensions might be 64bits */
\&
\&     for (i=0;i<5*5*5;i++)
\&       dataf[i] = i; /* the data must be initialized ! */
\&     return p;
\&   }
.Ve
.SS "Wrapping your own data into an ndarray"
.IX Subsection "Wrapping your own data into an ndarray"
Sometimes you obtain a chunk of data from another
source, for example an image processing library, etc.
All you want to do in that case is wrap your data
into an ndarray struct at the C level. Examples using this approach
can be found in the \s-1IO\s0 modules (where FastRaw and FlexRaw
use it for mmapped access) and the Gimp Perl module (that
uses it to wrap Gimp pixel regions into ndarrays).
The following script demonstrates a simple example:
.PP
.Vb 3
\&   use PDL::LiteF;
\&   use PDL::Core::Dev;
\&   use PDL::Graphics::PGPLOT;
\&
\&   $y = mkndarray();
\&
\&   print $y\->info,"\en";
\&
\&   imag1 $y;
\&
\&   use Inline with => \*(AqPDL\*(Aq;
\&   use Inline C;
\&   Inline\->init;
\&
\&   _\|_DATA_\|_
\&
\&   _\|_C_\|_
\&
\&   /* wrap a user supplied chunk of data into an ndarray
\&    * You must specify the dimensions (dims,ndims) and 
\&    * the datatype (constants for the datatypes are declared
\&    * in pdl.h; e.g. PDL_B for byte type, etc)
\&    *
\&    * when the created ndarray \*(Aqp\*(Aq is destroyed on the
\&    * Perl side the function passed as the \*(Aqdelete_magic\*(Aq
\&    * parameter will be called with the pointer to the pdl structure
\&    * and the \*(Aqdelparam\*(Aq argument.
\&    * This gives you an opportunity to perform any clean up
\&    * that is necessary. For example, you might have to
\&    * explicitly call a function to free the resources
\&    * associated with your data pointer.
\&    * At the very least \*(Aqdelete_magic\*(Aq should zero the ndarray\*(Aqs data pointer:
\&    * 
\&    *     void delete_mydata(pdl* pdl, int param)
\&    *     {
\&    *       pdl\->data = 0;
\&    *     }
\&    *     pdl *p = pdl_wrap(mydata, PDL_B, dims, ndims, delete_mydata,0);
\&    *
\&    * pdl_wrap returns the pointer to the pdl
\&    * that was created.
\&    */
\&   typedef void (*DelMagic)(pdl *, int param);
\&   static void default_magic(pdl *p, int pa) { p\->data = 0; }
\&   static pdl* pdl_wrap(void *data, int datatype, PDL_Indx dims[],
\&                        int ndims, DelMagic delete_magic, int delparam)
\&   {
\&     pdl* p = PDL\->pdlnew(); /* get the empty container */
\&     if (!p) return p;
\&     pdl_error err = PDL\->setdims(p, dims, ndims);  /* set dims */
\&     if (err.error) { PDL\->destroy(p); return NULL; }
\&     p\->datatype = datatype;     /* and data type */
\&     p\->data = data;             /* point it to your data */
\&     /* make sure the core doesn\*(Aqt meddle with your data */
\&     p\->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
\&     if (delete_magic != NULL)
\&       PDL\->add_deletedata_magic(p, delete_magic, delparam);
\&     else
\&       PDL\->add_deletedata_magic(p, default_magic, 0);
\&     return p;
\&   }
\&
\&   #define SZ 256
\&   /* a really silly function that makes a ramp image
\&    * in reality this could be an opaque function
\&    * in some library that you are using
\&    */
\&   static PDL_Byte* mkramp(void)
\&   {
\&     PDL_Byte *data;
\&     int i; /* should use PDL_Indx to support 64bit pdl indexing */
\&
\&     if ((data = malloc(SZ*SZ*sizeof(PDL_Byte))) == NULL)
\&       croak("mkramp: Couldn\*(Aqt allocate memory");
\&     for (i=0;i<SZ*SZ;i++)
\&       data[i] = i % SZ;
\&
\&     return data;
\&   }
\&
\&   /* this function takes care of the required clean\-up */
\&   static void delete_myramp(pdl* p, int param)
\&   {
\&     if (p\->data)
\&       free(p\->data);
\&     p\->data = 0;
\&   }
\&
\&   pdl* mkndarray()
\&   {
\&     PDL_Indx dims[] = {SZ,SZ};
\&     pdl *p;
\&
\&     p = pdl_wrap((void *) mkramp(), PDL_B, dims, 2, 
\&                  delete_myramp,0); /* the delparam is abitrarily set to 0 */
\&     return p;
\&   }
.Ve
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
.SS "The Core struct \*(-- getting at \s-1PDL\s0 core routines at runtime"
.IX Subsection "The Core struct getting at PDL core routines at runtime"
\&\s-1PDL\s0 uses a technique similar to that employed by the Tk modules
to let other modules use its core routines. A pointer to all
shared core \s-1PDL\s0 routines is stored in the \f(CW$PDL::SHARE\fR variable.
\&\s-1XS\s0 code should get hold of this pointer at boot time so that
the rest of the C/XS code can then use that pointer for access
at run time. This initial loading of the pointer is most easily
achieved using the functions \f(CW\*(C`PDL_AUTO_INCLUDE\*(C'\fR and \f(CW\*(C`PDL_BOOT\*(C'\fR
that are defined and exported by \f(CW\*(C`PDL::Core::Dev\*(C'\fR. Typical usage
with the Inline module has already been demonstrated:
.PP
.Vb 1
\&   use Inline with => \*(AqPDL\*(Aq;
.Ve
.PP
In earlier versions of \f(CW\*(C`Inline\*(C'\fR, this was achieved like this:
.PP
.Vb 5
\&   use Inline C => Config =>
\&     INC           => &PDL_INCLUDE,
\&     TYPEMAPS      => &PDL_TYPEMAP,
\&     AUTO_INCLUDE  => &PDL_AUTO_INCLUDE, # declarations
\&     BOOT          => &PDL_BOOT;         # code for the XS boot section
.Ve
.PP
The code returned by \f(CW\*(C`PDL_AUTO_INCLUDE\*(C'\fR makes sure that \fIpdlcore.h\fR
is included and declares the static variables to hold the pointer to
the \f(CW\*(C`Core\*(C'\fR struct. It looks something like this:
.PP
.Vb 1
\&   print PDL_AUTO_INCLUDE;
\&
\& #include <pdlcore.h>
\& static Core* PDL; /* Structure holds core C functions */
\& static SV* CoreSV;       /* Gets pointer to Perl var holding core structure */
.Ve
.PP
The code returned by \f(CW\*(C`PDL_BOOT\*(C'\fR retrieves the \f(CW$PDL::SHARE\fR variable
and initializes the pointer to the \f(CW\*(C`Core\*(C'\fR struct. For those who know
their way around the Perl \s-1API\s0 here is the code:
.PP
.Vb 11
\&   perl_require_pv ("PDL/Core.pm"); /* make sure PDL::Core is loaded */
\&#ifndef aTHX_
\&#define aTHX_
\&#endif
\&   if (SvTRUE (ERRSV)) Perl_croak(aTHX_ "%s",SvPV_nolen (ERRSV));
\&   if (!(CoreSV = perl_get_sv("PDL::SHARE",FALSE))) /* SV* value */
\&     Perl_croak(aTHX_ "We require the PDL::Core module, which was not found");
\&   if (!(PDL = INT2PTR(Core*,SvIV( CoreSV )))) /* Core* value */
\&     Perl_croak(aTHX_ "Got NULL pointer for PDL");
\&   if (PDL\->Version != PDL_CORE_VERSION)
\&     Perl_croak(aTHX_ "[PDL\->Version: \e%d PDL_CORE_VERSION: \e%d XS_VERSION: \e%s] The code needs to be recompiled against the newly installed PDL", PDL\->Version, PDL_CORE_VERSION, XS_VERSION);
.Ve
.PP
The \f(CW\*(C`Core\*(C'\fR struct contains version info to ensure that the structure defined
in \fIpdlcore.h\fR really corresponds to the one obtained at runtime. The code
above tests for this
.PP
.Vb 2
\&   if (PDL\->Version != PDL_CORE_VERSION)
\&     ....
.Ve
.PP
For more information on the Core struct see PDL::Internals.
.PP
With these preparations your code can now access the
core routines as already shown in some of the examples above, e.g.
.PP
.Vb 1
\&  pdl *p = PDL\->pdlnew();
.Ve
.PP
By default the C variable named \f(CW\*(C`PDL\*(C'\fR is used to hold the pointer to the
\&\f(CW\*(C`Core\*(C'\fR struct. If that is (for whichever reason) a problem you can
explicitly specify a name for the variable with the \f(CW\*(C`PDL_AUTO_INCLUDE\*(C'\fR
and the \f(CW\*(C`PDL_BOOT\*(C'\fR routines:
.PP
.Vb 5
\&   use Inline C => Config =>
\&     INC           => &PDL_INCLUDE,
\&     TYPEMAPS      => &PDL_TYPEMAP,
\&     AUTO_INCLUDE  => &PDL_AUTO_INCLUDE \*(AqPDL_Corep\*(Aq,
\&     BOOT          => &PDL_BOOT \*(AqPDL_Corep\*(Aq;
.Ve
.PP
Make sure you use the same identifier with \f(CW\*(C`PDL_AUTO_INCLUDE\*(C'\fR
and \f(CW\*(C`PDL_BOOT\*(C'\fR and use that same identifier in your own code.
E.g., continuing from the example above:
.PP
.Vb 1
\&  pdl *p = PDL_Corep\->pdlnew();
.Ve
.SS "Some selected core routines explained"
.IX Subsection "Some selected core routines explained"
The full definition of the \f(CW\*(C`Core\*(C'\fR struct can be found in the file
\&\fIpdlcore.h\fR. In the following the most frequently used member
functions of this struct are briefly explained.
.IP "\(bu" 5
\&\f(CW\*(C`pdl *SvPDLV(SV *sv)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`pdl *SetSV_PDL(SV *sv, pdl *it)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`pdl *pdlnew()\*(C'\fR
.Sp
\&\f(CW\*(C`pdlnew\*(C'\fR returns an empty pdl object that is initialised like a \*(L"null\*(R"
but with no data. Example:
.Sp
.Vb 5
\&  pdl *p = PDL\->pdlnew();
\&  if (!p) return p;
\&  pdl_error err = PDL\->setdims(p, dims, ndims);  /* set dims */
\&  if (err.error) { PDL\->destroy(p); return NULL; }
\&  p\->datatype = PDL_B;
.Ve
.Sp
Returns \f(CW\*(C`NULL\*(C'\fR if a problem occurred, so check for that.
.IP "\(bu" 5
\&\f(CW\*(C`pdl *null()\*(C'\fR
.Sp
Returns \f(CW\*(C`NULL\*(C'\fR if a problem occurred, so check for that.
.IP "\(bu" 5
\&\f(CW\*(C`SV *copy(pdl* p, char* )\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`void *smalloc(STRLEN nbytes)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`int howbig(int pdl_datatype)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`pdl_error add_deletedata_magic(pdl *p, void (*func)(pdl*, int), int param)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`pdl_error allocdata(pdl *p)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`pdl_error make_physical(pdl *p)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`pdl_error make_physdims(pdl *p)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`pdl_error make_physvaffine(pdl *p)\*(C'\fR
.IP "\(bu" 5
\&\f(CW\*(C`void pdl_barf(const char* pat,...)\*(C'\fR and
\&\f(CW\*(C`void pdl_warn(const char* pat,...)\*(C'\fR
.Sp
These are C\-code equivalents of \f(CW\*(C`barf\*(C'\fR and \f(CW\*(C`warn\*(C'\fR. They include special handling of error or warning
messages during pthreading (i.e. processor multi-threading) that defer the messages until after pthreading
is completed. When pthreading is complete, perl's \f(CW\*(C`barf\*(C'\fR or \f(CW\*(C`warn\*(C'\fR is called with the deferred messages. This
is needed to keep from calling perl's \f(CW\*(C`barf\*(C'\fR or \f(CW\*(C`warn\*(C'\fR during pthreading, which can cause segfaults.
.Sp
Note that \f(CW\*(C`barf\*(C'\fR and \f(CW\*(C`warn\*(C'\fR have been redefined (using c\-preprocessor macros) in pdlcore.h to \f(CW\*(C`PDL\->barf\*(C'\fR
and \f(CW\*(C`PDL\->warn\*(C'\fR. This is to keep any \s-1XS\s0 or \s-1PP\s0 code from calling perl's \f(CW\*(C`barf\*(C'\fR or \f(CW\*(C`warn\*(C'\fR directly, which can
cause segfaults during pthreading.
.Sp
See PDL::ParallelCPU for more information on pthreading.
.Sp
\&\fB\s-1NB\s0\fR As of 2.064, it is \fBhighly recommended\fR that you do not call
\&\f(CW\*(C`barf\*(C'\fR at all in \s-1PP\s0 code, but instead use \f(CW\*(C`$CROAK()\*(C'\fR. This will return
a \f(CW\*(C`pdl_error\*(C'\fR which will transparently be used to throw the correct
exception in Perl code, but can be handled suitably by non-Perl callers.
.IP "\(bu" 5

.Sp
.Vb 1
\&  safe_indterm
.Ve
.Sp
Checks given offset is within given ndarray's bounds, else throws an
exception.
.IP "\(bu" 5

.Sp
.Vb 1
\&  converttype
.Ve
.Sp
Used by \f(CW\*(C`set_datatype\*(C'\fR to change an ndarray's type, converting and
possibly re-allocating the data if a different size. If the ndarray's
\&\f(CW\*(C`badflag\*(C'\fR was set, its \f(CW\*(C`badvalue\*(C'\fR will become the default for the
new type. Bad values will still be bad.
.IP "\(bu" 5

.Sp
.Vb 1
\&  converttypei_new
.Ve
.Sp
Affine transformation used only by \f(CW\*(C`get_convertedpdl\*(C'\fR to convert an
ndarray's type. Not bad-value aware.
.IP "\(bu" 5

.Sp
.Vb 1
\&  get_convertedpdl
.Ve
.Sp
Used by \*(L"convert\*(R" in PDL::Core.
.IP "\(bu" 5

.Sp
.Vb 1
\&  affine_new
.Ve
.Sp
Creates a child vaffine ndarray from given parent ndarray, with given offs
(starting point for that pthread in that ndarray), inclist and dims.
.IP "\(bu" 5

.Sp
.Vb 1
\&  make_trans_mutual
.Ve
.Sp
Triggers the actual running of a previously-set-up \f(CW\*(C`pdl_trans\*(C'\fR.
.IP "\(bu" 5

.Sp
.Vb 1
\&  get
.Ve
.Sp
Get data at given coordinates.
.IP "\(bu" 5

.Sp
.Vb 1
\&  get_offs
.Ve
.Sp
Get data at given offset.
.IP "\(bu" 5

.Sp
.Vb 1
\&  put_offs
.Ve
.Sp
Put data at given offset.
.IP "\(bu" 5

.Sp
.Vb 1
\&  setdims_careful
.Ve
.Sp
Despite the name, just calls \f(CW\*(C`resize_defaultincs\*(C'\fR then
\&\f(CW\*(C`reallocbroadcastids\*(C'\fR with one.
.IP "\(bu" 5

.Sp
.Vb 1
\&  destroy
.Ve
.Sp
Destroy ndarray.
.IP "\(bu" 5

.Sp
.Vb 1
\&  reallocdims
.Ve
.Sp
Cause the ndarray to have given number of dimensions, destroying
previous ones.
.IP "\(bu" 5

.Sp
.Vb 1
\&  reallocbroadcastids
.Ve
.Sp
Reallocate n broadcastids. Set the new extra ones to the end.
.IP "\(bu" 5

.Sp
.Vb 1
\&  resize_defaultincs
.Ve
.Sp
Recalculate default increments from \f(CW\*(C`dims\*(C'\fR, and grow the \s-1PDL\s0 data.
.SS "Handy macros from pdl.h"
.IX Subsection "Handy macros from pdl.h"
Some of the C \s-1API\s0 functions return \f(CW\*(C`PDL_Anyval\*(C'\fR C type which
is a structure and therefore requires special handling.
.PP
You might want to use for example \f(CW\*(C`get_pdl_badvalue\*(C'\fR function:
.PP
.Vb 2
\& /* THIS DOES NOT WORK! (although it did in older PDL) */
\& if( PDL\->get_pdl_badvalue(a) == 0 )  { ... }
\&
\& /* THIS IS CORRECT */
\& double bad_a;
\& PDL_Anyval bv = PDL\->get_pdl_badvalue(a);
\& if (bv.type < 0) croak("error getting badvalue");
\& ANYVAL_TO_CTYPE(bad_a, double, bv);
\& if( bad_a == 0 ) { ... }
.Ve
.PP
As of \s-1PDL 2.014,\s0 in \fIpdl.h\fR there are the following macros for handling
PDL_Anyval from C code:
.PP
.Vb 3
\& ANYVAL_FROM_CTYPE(out_anyval, out_anyval_type, in_variable)
\& ANYVAL_TO_CTYPE(out_variable, out_ctype, in_anyval)
\& ANYVAL_EQ_ANYVAL(x, y) /* returns \-1 on type error */
.Ve
.PP
As of \s-1PDL 2.039\s0 (returns \-1 rather than croaking on failure as of
2.064) there is:
.PP
.Vb 1
\& ANYVAL_ISNAN(anyval)
.Ve
.PP
As of \s-1PDL 2.040\s0 (changed parameter list, also returns \-1 rather than
croaking on failure, in 2.064) \- you need to check the badflag first:
.PP
.Vb 1
\& ANYVAL_ISBAD(in_anyval, badval)
.Ve
.PP
e.g.
.PP
.Vb 11
\& int badflag = (x\->state & PDL_BADVAL) > 0;
\& PDL_Anyval badval = pdl_get_pdl_badvalue(x);
\& if (badflag) {
\&   int isbad = ANYVAL_ISBAD(result, badval);
\&   if (isbad == \-1) croak("ANYVAL_ISBAD error on types %d, %d", result.type, badval.type);
\&   if (isbad)
\&     RETVAL = newSVpvn( "BAD", 3 );
\&   else
\&     ANYVAL_TO_SV(RETVAL, result);
\& } else
\&   ANYVAL_TO_SV(RETVAL, result);
.Ve
.PP
As of \s-1PDL 2.058,\s0 there are:
.PP
.Vb 2
\&  ANYVAL_FROM_CTYPE_OFFSET(result, datatype, x, ioff);
\&  ANYVAL_TO_CTYPE_OFFSET(x, ioff, datatype, value);
.Ve
.PP
The latter dispatches on both the destination type and the input
\&\*(L"anyval\*(R" type. They are intended for retrieving values from, and setting
them within, ndarrays.
.PP
As of \s-1PDL 2.048,\s0 in \fIpdlperl.h\fR there are:
.PP
.Vb 2
\& ANYVAL_FROM_SV(out_anyval, in_SV, use_undefval, forced_type)
\& ANYVAL_TO_SV(out_SV, in_anyval)
.Ve
.PP
Because these are used in the \s-1PDL\s0 \fItypemap.pdl\fR, you will need to
include \fIpdlperl.h\fR in any \s-1XS\s0 file with functions that take or
return a \f(CW\*(C`PDL_Anyval\*(C'\fR.
.SS "Access to \s-1PDL\s0 operations as C functions"
.IX Subsection "Access to PDL operations as C functions"
As of 2.058, all \s-1PDL\s0 operations can be accessed from C code in a similar
way to \s-1XS\s0 functions, since that is what the \s-1XS\s0 functions now call. Each
module defines various C functions and data-structures for each operation,
as needed to operate as a \s-1PDL\s0 transformation. The entry point from outside
(and from \s-1XS\s0 functions) is a C function called \f(CW\*(C`pdl_(operationname)_run\*(C'\fR,
with a signature derived from its \f(CW\*(C`Pars\*(C'\fR and \f(CW\*(C`OtherPars\*(C'\fR. E.g.
.PP
.Vb 6
\&  # from PDL::Primitive
\&  pp_def(\*(Aqwtstat\*(Aq,
\&    Pars => \*(Aqa(n); wt(n); avg(); [o]b();\*(Aq,
\&    OtherPars => \*(Aqint deg\*(Aq,
\&    # ...
\&  );
.Ve
.PP
has the C signature:
.PP
.Vb 1
\&  void pdl_wtstat_run(pdl *a, pdl *wt, pdl *avg, pdl *b, int deg);
.Ve
.PP
Not very surprisingly, all \f(CW\*(C`pdl*\*(C'\fR parameters must be initialised (at
least to \f(CW\*(C`PDL\->null\*(C'\fR status), and they are changed according to
the operation's specification. This makes the \s-1XS\s0 \f(CW\*(C`_(name)_int\*(C'\fR
non-varargs \s-1XS\s0 functions very thin layers over this.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1PDL\s0
.PP
Inline
.SH "BUGS"
.IX Header "BUGS"
This manpage is still under development.
Feedback and corrections are welcome.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2013 Chris Marshall (chm@cpan.org).
.PP
Copyright 2010 Christian Soeller (c.soeller@auckland.ac.nz).
You can distribute and/or modify this document under the same
terms as the current Perl license.
.PP
See: http://dev.perl.org/licenses/
