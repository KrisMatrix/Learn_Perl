.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "FAQ 1"
.TH FAQ 1 "2022-03-13" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::FAQ \- Frequently asked questions about PDL
.SH "VERSION"
.IX Header "VERSION"
Current \s-1FAQ\s0 version:  1.008
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is version 1.008 of the \s-1PDL FAQ,\s0 a collection of  frequently 
asked questions about \s-1PDL\s0 \- the Perl Data Language.
.SH "ABOUT THIS DOCUMENT"
.IX Header "ABOUT THIS DOCUMENT"
.SS "Q: 1.1    Where to find this document"
.IX Subsection "Q: 1.1 Where to find this document"
You can find the latest version of this document at 
<http://pdl.perl.org/?docs=FAQ&title=Frequently%20Asked%20Questions> .
.SS "Q: 1.2    How to contribute to this document"
.IX Subsection "Q: 1.2 How to contribute to this document"
This is a considerably reworked version of the \s-1PDL FAQ.\s0 As
such many errors might have crept in and many updates might
not have made it in.  You are explicitly encouraged to let us
know about questions which you think should be answered in
this document but currently aren't.
.PP
Similarly, if you think parts of this document are
unclear, please tell the \s-1FAQ\s0 maintainer about it. Where
a specific answer is taken in full from someones posting
the authorship should be indicated, let the \s-1FAQ\s0 maintainer
know if it isn't. For more general information explicit
acknowledgment is not made in the text, but rather there
is an incomplete list of contributors at the end of this
document. Please contact the \s-1FAQ\s0 maintainer if you feel
hard done by.
.PP
Send your comments, additions, suggestions or corrections
to the \s-1PDL\s0 mailing list at pdl\-general@lists.sourceforge.net.
See Q: 3.2 below for instructions on how to join the mailing
lists.
.SH "GENERAL QUESTIONS"
.IX Header "GENERAL QUESTIONS"
.SS "Q: 2.1    What is \s-1PDL\s0 ?"
.IX Subsection "Q: 2.1 What is PDL ?"
\&\s-1PDL\s0 stands for 
\&\fIPerl Data  Language\fR . To say it with the words of Karl Glazebrook,
initiator of the \s-1PDL\s0 project:
.PP
.Vb 5
\&    The PDL concept is to give standard perl5 the ability
\&    to COMPACTLY store and SPEEDILY manipulate the large
\&    N\-dimensional data sets which are the bread and butter
\&    of scientific computing. e.g. $x=$y+$z can add two
\&    2048x2048 images in only a fraction of a second.
.Ve
.PP
It provides tons of useful functionality for scientific and numeric analysis.
.PP
For readers familiar with other scientific data evaluation packages it
may be helpful to add that \s-1PDL\s0 is in many respects similar to \s-1IDL,
MATLAB\s0 and similar packages. However, it tries to improve on a number
of issues which were perceived (by the authors of \s-1PDL\s0) as shortcomings
of those existing packages.
.SS "Q: 2.2    Who supports \s-1PDL\s0? Who develops it?"
.IX Subsection "Q: 2.2 Who supports PDL? Who develops it?"
\&\s-1PDL\s0 is supported by its users. General informal support for \s-1PDL\s0
is provided through the \s-1PDL\s0 mailing list (pdl\-general@lists.sourceforge.net ,
see below).
.PP
As a Perl extension (see Q: 2.5 below) it is devoted to the idea of free and
open development put forth by the Perl community. \s-1PDL\s0 was and is being
actively developed by a loosely knit group of people around the world who
coordinate their activities through the \s-1PDL\s0 development mailing list
(pdl\-devel@lists.sourceforge.net , see Q: 3.2 below). If you would like
to join in the ongoing efforts to improve \s-1PDL\s0 please join this list.
.SS "Q: 2.3    Why yet another Data Language ?"
.IX Subsection "Q: 2.3 Why yet another Data Language ?"
There are actually several reasons and everyone should decide for
themselves which are the most important ones:
.IP "\(bu" 4
\&\s-1PDL\s0 is \*(L"free software\*(R". The authors of \s-1PDL\s0 think
that this concept has several advantages: everyone has
access to the sources \-> better debugging, easily
adaptable to your own needs, extensible for your purposes,
etc... In comparison with commercial packages such as \s-1MATLAB\s0
and \s-1IDL\s0 this is of considerable importance for workers who
want to do some work at home and cannot afford the
considerable cost to buy commercial packages for personal
use.
.IP "\(bu" 4
\&\s-1PDL\s0 is based on a powerful and well designed scripting
language: Perl. In contrast to other scientific/numeric data
analysis languages it has been designed using the features of 
a proven language instead of having grown into existence from 
scratch. Defining the control structures while features were 
added during development leads to languages that often appear 
clumsy and badly planned for most existing packages with 
similar scope as \s-1PDL.\s0
.IP "\(bu" 4
Using Perl as the basis a \s-1PDL\s0 programmer has all the
powerful features of Perl at their hand, right from the
start. This includes regular expressions, associative arrays
(hashes), well designed interfaces to the operating system,
network, etc. Experience has shown that even in mainly
numerically oriented programming it is often extremely handy
if you have easy access to powerful semi-numerical or
completely non-numerical functionality as well. For example,
you might want to offer the results of a complicated
computation as a server process to other processes on the
network, perhaps directly accepting input from other
processes on the network. Using Perl and existing Perl
extension packages things like this are no problem at all
(and it all will fit into your \*(L"\s-1PDL\s0 script\*(R").
.IP "\(bu" 4
Extremely easy extensibility and interoperability as \s-1PDL\s0 is
a Perl extension; development support for Perl extensions is
an integral part of Perl and there are already numerous
extensions to standard Perl freely available on the network.
.IP "\(bu" 4
Integral language features of Perl (regular expressions,
hashes, object modules) immensely facilitated development
and implementation of key concepts of \s-1PDL.\s0 One of the most
striking examples for this point is probably \s-1PDL::PP\s0 
(see Q: 6.16 below), a code generator/parser/pre\-processor that
generates \s-1PDL\s0 functions from concise descriptions.
.IP "\(bu" 4
None of the existing data languages follow the Perl language
rules, which the authors firmly believe in:
.RS 4
.IP "\(bu" 4
\&\s-1TIMTOWTDI:\s0 There is more than one way to do it.
Minimalist languages are interesting for computer
scientists, but for users, a little bit of redundancy
makes things wildly easier to cope with and allows
individual programming styles \- just as people speak in
different ways. For many people this will undoubtedly be
a reason to avoid \s-1PDL\s0 ;)
.IP "\(bu" 4
Simple things are simple, complicated things possible:
Things that are often done should be easy to do in the language,
whereas seldom done things shouldn't be too cumbersome.
.RE
.RS 4
.Sp
All existing languages violate at least one of these rules.
.RE
.IP "\(bu" 4
As a project for the future \s-1PDL\s0 should be able to use super
computer features, e.g. vector capabilities/parallel processing,
\&\s-1GPGPU\s0 acceleration. This will probably be achieved by having 
\&\s-1PDL::PP\s0 (see Q: 6.16 below) generate appropriate code
on such architectures to exploit these features.
.IP "\(bu" 4
[ fill in your personal 111 favourite reasons here...]
.SS "Q: 2.4    What is \s-1PDL\s0 good for ?"
.IX Subsection "Q: 2.4 What is PDL good for ?"
Just in case you do not yet know what the main features of \s-1PDL\s0 are and
what one could do with them, here is a (necessarily selective) list of
key features:
.PP
\&\s-1PDL\s0 is well suited for matrix computations, general handling
of multidimensional data, image processing, general scientific
computation, numerical applications. It supports I/O for many
popular image and data formats, 1D (line plots), 2D (images)
and 3D (volume visualization, surface plots via OpenGL \- for
instance implemented using Mesa or video card OpenGL drivers),
graphics display capabilities and implements many numerical and
semi-numerical algorithms.
.PP
Through the powerful pre-processor it is also easy to interface Perl
to your favorite C routines, more of that further below.
.SS "Q: 2.5    What is the connection between \s-1PDL\s0 and Perl ?"
.IX Subsection "Q: 2.5 What is the connection between PDL and Perl ?"
\&\s-1PDL\s0 is a Perl5 extension package. As such it needs an existing Perl5
installation (see below) to run. Furthermore, much of \s-1PDL\s0 is written in
Perl (+ some core functionality that is written in C). \s-1PDL\s0 programs
are (syntactically) just Perl scripts that happen to use some of the
functionality implemented by the package \*(L"\s-1PDL\*(R".\s0
.SS "Q: 2.6    What do I need to run \s-1PDL\s0 on my machine ?"
.IX Subsection "Q: 2.6 What do I need to run PDL on my machine ?"
Since \s-1PDL\s0 is just a Perl5 package you need first of
all an installation of Perl5 on your machine. As of this
writing \s-1PDL\s0 requires version 5.10.x of perl, or higher.  More
information on where and how to get a Perl installation
can be found at the Perl home page <http://www.perl.org>
and at many \s-1CPAN\s0 sites (if you do not know what \fI\s-1CPAN\s0\fR
is, check the answer to the next question).
.PP
To build \s-1PDL\s0 you also need a working C compiler, support
for Xsubs, and the package Extutils::MakeMaker. If you
don't have a compiler there might be a binary distribution
available, see \*(L"Binary distributions\*(R" below.
.PP
If you can (or cannot) get \s-1PDL\s0 working on a new (previously
unsupported) platform we would like to hear about it. Please,
report your success/failure to the \s-1PDL\s0 mailing list at 
pdl\-general@lists.sourceforge.net . We will do our best to
assist you in porting \s-1PDL\s0 to a new system.
.SS "Q: 2.7    Where do I get it?"
.IX Subsection "Q: 2.7 Where do I get it?"
\&\s-1PDL\s0 is available as source distribution in the 
\&\fIComprehensive Perl Archive Network\fR (or \s-1CPAN\s0) and from the
GitHub project page at <https://github.com/PDLPorters/pdl>.
The \s-1CPAN\s0 archives contains not only the \s-1PDL\s0 distribution but
also just about everything else that is Perl-related.  \s-1CPAN\s0 is
mirrored by dozens of sites all over the world.  The main site
is <http://www.cpan.org>, and local \s-1CPAN\s0 sites (mirrors) can be
found there. \s-1PDL\s0's homepage is at <http://pdl.perl.org> and the
latest version can also be downloaded from there.
.SS "Q: 2.8    What do I have to pay to get \s-1PDL\s0?"
.IX Subsection "Q: 2.8 What do I have to pay to get PDL?"
We are delighted to be able to give you the nicest possible
answer on a question like this: \s-1PDL\s0 is *free software* and all
sources are publicly available. But still, there are some
copyrights to comply with. So please, try to be as nice as we
(the \s-1PDL\s0 authors) are and try to comply with them.
.PP
Oh, before you think it is *completely* free: you
have to invest some time to pull the distribution from the net,
compile and install it and (maybe) read the manuals.
.SH "GETTING HELP/MORE INFORMATION"
.IX Header "GETTING HELP/MORE INFORMATION"
.SS "Q: 3.1    Where can I get information on \s-1PDL\s0?"
.IX Subsection "Q: 3.1 Where can I get information on PDL?"
The complete \s-1PDL\s0 documentation is available with the \s-1PDL\s0 distribution.
Use the command \f(CW\*(C`perldoc PDL\*(C'\fR to start learning about \s-1PDL.\s0
.PP
The easiest way by far, however, to get familiar with \s-1PDL\s0 is to use
the \s-1PDL\s0 on-line help facility from within the \s-1PDL\s0
shell, \f(CW\*(C`pdl2\*(C'\fR  Just type \f(CW\*(C`pdl2\*(C'\fR at your system prompt. Once you are inside the
\&\f(CW\*(C`pdl2\*(C'\fR shell type \f(CW\*(C`help\*(C'\fR .  Using the \f(CW\*(C`help\*(C'\fR and \f(CW\*(C`apropos\*(C'\fR commands
inside the shell you should be able to find the way round the
documentation.
.PP
Even better, you can immediately try your newly acquired
knowledge about \s-1PDL\s0 by issuing PDL/Perl commands directly at the command
line. To illustrate this process, here is the record of a typical
\&\f(CW\*(C`pdl2\*(C'\fR session of a \s-1PDL\s0 beginner (lengthy output is only symbolically
reproduced in braces ( <... ...> ) ):
.PP
.Vb 12
\&    unix> pdl2
\&    pdl> help
\&    < ... help output ... >
\&    pdl> help PDL::QuickStart
\&    < ... perldoc page ... >
\&    pdl> $x = pdl (1,5,7.3,1.0)
\&    pdl> $y = sequence float, 4, 4
\&    pdl> help inner
\&    < ... help on the \*(Aqinner\*(Aq function ... >
\&    pdl> $c = inner $x, $y
\&    pdl> p $c
\&    [22.6 79.8 137 194.2]
.Ve
.PP
For further sources of information that are accessible through the
Internet see next question.
.SS "Q: 3.2    Are there other \s-1PDL\s0 information sources on the Internet?"
.IX Subsection "Q: 3.2 Are there other PDL information sources on the Internet?"
First of all, for all purely Perl-related questions there are
tons of sources on the net. Good points to start are 
<http://www.perl.com> and <http://www.perl.org> .
.PP
The \s-1PDL\s0 home site can be accessed by pointing your web browser to 
<http://pdl.perl.org> . It has tons of goodies for anyone interested in \s-1PDL:\s0
.IP "\(bu" 4
\&\s-1PDL\s0 distributions
.IP "\(bu" 4
On-line documentation
.IP "\(bu" 4
Pointers to an \s-1HTML\s0 archive of the \s-1PDL\s0 mailing lists
.IP "\(bu" 4
A list of platforms on which \s-1PDL\s0 has been successfully tested.
.IP "\(bu" 4
News about recently added features, ported libraries, etc.
.IP "\(bu" 4
Name of the current pumpkin holders for the different \s-1PDL\s0 modules (if
you want to know what that means you better had a look at the web
pages).
.PP
If you are interested in \s-1PDL\s0 in general you can join the pdl-general mailing
list. This is a forum to discuss programming issues in \s-1PDL,\s0 report bugs, seek
assistance with \s-1PDL\s0 related problems, etc.
.PP
If you are interested in all the technical details of the ongoing \s-1PDL\s0
development you can join the pdl-devel mailing list.
.PP
Subscription and current archive links to both mailing lists can be
found at <http://pdl.perl.org/?page=mailing\-lists>.
.PP
Cross-posting between these lists should be avoided unless there is a
\&\fIvery\fR good reason for doing that.
.PP
The \s-1PDL\s0 project, begun in the late 1990s, has undergone considerable evolution
since that time, and the support for it has as well. Thus mailing-list
archives are in several places.  Originally pdl-general was called 'perldl',
and pdl-devel was called 'pdl\-porters'.
.PP
|Time Period | \s-1URL\s0                                                   |
|\-\-\-\-\-\-\-\-\-\-\-\-|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
|1996 \- 2004 | http://www.xray.mpe.mpg.de/mailing\-lists/perldl/      |
|1997 \- 2004 | http://www.xray.mpe.mpg.de/mailing\-lists/pdl\-porters/ |
|2005 \- 2015 | http://perldl.jach.hawaii.narkive.com/                |
|2005 \- 2015 | http://pdl\-porters.jach.hawaii.narkive.com/           |
|2015 \-      | https://sourceforge.net/p/pdl/mailman/pdl\-general/    |
|2015 \-      | https://sourceforge.net/p/pdl/mailman/pdl\-devel/      |
|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
.SS "Q: 3.3    What is the current version of \s-1PDL\s0 ?"
.IX Subsection "Q: 3.3 What is the current version of PDL ?"
As of this writing (\s-1FAQ\s0 version 1.008 of 21 May 2017) the latest stable version
is 2.018.  The latest stable version should always be available from a \s-1CPAN\s0
mirror site near you (see Question 2.7 for
info on where to get \s-1PDL\s0).
.PP
The most current (possibly unstable) version of \s-1PDL\s0 can be obtained 
from the Git repository, see Question 4.10
and periodic \s-1CPAN\s0 developers releases of the Git code will be made for testing
purposes and more general availability.
.SS "Q: 3.4  How can \s-1PDL\-2.2\s0 be older than \s-1PDL\-2.007\s0?"
.IX Subsection "Q: 3.4 How can PDL-2.2 be older than PDL-2.007?"
Over its development, \s-1PDL\s0 has used both a single floating point version
number (from the versions 1.x through 2.005) at which point it switched
to a dotted triple version for 2.1.1 onward\-\-\-EXCEPT for version 2.2
which came out which should have been 2.2.0.  To simplify and unify
things, \s-1PDL\s0 has reverted to a single float version representation with
\&\s-1PDL\-2.006.\s0  This can cause dependency problems for modules that set a
minimum \s-1PDL\s0 version of 2.2.  The work around it, note that all extant
\&\s-1PDL\s0 releases have version numbers greater than 2.2.1 so that using
0 as the minimum version will work.
.SS "Q: 3.5    I want to contribute to the further development of \s-1PDL.\s0 How can I help?"
.IX Subsection "Q: 3.5 I want to contribute to the further development of PDL. How can I help?"
Two ways that you could help almost immediately are (1) participate
in \s-1CPAN\s0 Testers for \s-1PDL\s0 and related modules, and (2) proofreading and
clarifying the \s-1PDL\s0 documentation so that it is most useable for \s-1PDL\s0
users, especially new users.
.PP
To participate in \s-1CPAN\s0 Testers and contribute test reports, the page
<http://wiki.cpantesters.org/wiki/QuickStart> has instructions for
starting for either \f(CW\*(C`CPAN\*(C'\fR or \f(CW\*(C`CPANPLUS\*(C'\fR users.
.PP
If you have a certain project in mind you should check if somebody
else is already working on it or if you could benefit from existing
modules. Do so by posting your planned project to the \s-1PDL\s0 developers
mailing list at pdl\-devel@lists.sourceforge.net . See the subscription
instructions in Question 3.2.
We are always looking for people to write code and/or documentation ;).
.SS "Q: 3.6    I think I have found a bug in the current version of \s-1PDL.\s0 What shall I do?"
.IX Subsection "Q: 3.6 I think I have found a bug in the current version of PDL. What shall I do?"
First, make sure that the bug/problem you came across has not already been
dealt with somewhere else in this \s-1FAQ.\s0  Secondly, you can check the
searchable archive of the \s-1PDL\s0 mailing lists to find whether
this bug has already been discussed.  If you still haven't found
any explanations you can post a bug report to pdl\-general@lists.sourceforge.net ,
or through the Bugs link on <http://pdl.perl.org> .  See the \fI\s-1BUGS\s0\fR
file in the \s-1PDL\s0 distribution for what information to include.  If
you are unsure, discussions via the perldl mailing list can be
most helpful.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
.SS "Q: 4.1    I have problems installing \s-1PDL.\s0 What shall I do?"
.IX Subsection "Q: 4.1 I have problems installing PDL. What shall I do?"
First make sure you have read the file \fI\s-1INSTALL\s0\fR in the distribution.
This contains a list of common problems which are unnecessary to repeat
here.
.PP
Next, check the file \fIperldl.conf\fR to see if by editing the
configuration options in that file you will be able to successfully
build \s-1PDL.\s0 Some of the modules need additional software installed,
please refer to the file \fI\s-1DEPENDENCIES\s0\fR for further details. Make sure
to edit the location of these packages in perldl.conf if you have them
in non-standard locations.
.PP
N.B. Unix shell specific: If you would like to save an edited perldl.conf
for future builds just copy it as \fI~/.perldl.conf\fR into your home directory
where it will be picked up automatically during the \s-1PDL\s0 build process.
.PP
Also, check for another, pre-existing version of \s-1PDL\s0 on the build
system.  Multiple \s-1PDL\s0 installs in the same \s-1PATH\s0 or \f(CW@INC\fR can cause
puzzling test or build failures.
.PP
If you still can't make it work properly please submit a bug
report including detailed information on the problems you
encountered to the perldl mailing list ( pdl\-general@lists.sourceforge.net ,
see also above). Response is often rapid.
.SS "Q: 4.2    Are there configuration files for \s-1PDL I\s0 have to edit?"
.IX Subsection "Q: 4.2 Are there configuration files for PDL I have to edit?"
Most users should not have to edit any configuration files manually.
However, in some cases you might have to supply some information
about awkwardly placed include files/libraries or you might want
to explicitly disable building some of the optional \s-1PDL\s0 modules.
Check the files \fI\s-1INSTALL\s0\fR and \fIperldl.conf\fR for details.
.PP
If you had to manually edit \fIperldl.conf\fR and are happy with the
results you can keep the file handy for future
reference. Place it in \fI~/.perldl.conf\fR where it will be picked
up automatically or use \f(CW\*(C`perl Makefile.PL  PDLCONF=your_file_name\*(C'\fR
next time you build \s-1PDL.\s0
.SS "Q: 4.3    Do I need other software for successful operation?"
.IX Subsection "Q: 4.3 Do I need other software for successful operation?"
For the basic \s-1PDL\s0 functionality you don't need any
additional software.  However, some of the optional \s-1PDL\s0
modules included in the distribution (notably most graphics
and some I/O modules) require certain other
libraries/programs to be installed. Check the file
\&\fI\s-1DEPENDENCIES\s0\fR in the distribution for details and directions
on how to get these.
.SS "Q: 4.4    How can I install \s-1PDL\s0 in a non-standard location?"
.IX Subsection "Q: 4.4 How can I install PDL in a non-standard location?"
To install \s-1PDL\s0 in a non-standard location, use the \s-1INSTALL_BASE\s0
option in the \f(CW\*(C`perl Makefile.PL\*(C'\fR configure step.  For example,
\&\f(CW\*(C`perl Makefile.PL INSTALL_BASE=/mydir/perl5\*(C'\fR will configure \s-1PDL\s0
to install into the tree rooted at \f(CW\*(C`/mydir/perl5\*(C'\fR.  For more
details see \*(L"How do I keep my own module/library directory?\*(R" in perlfaq8
and subsequent sections.  Another alternative is to use local::lib
to do the heavy lifting for the needed configuration.
.SS "Q: 4.5    How can I force a completely clean installation?"
.IX Subsection "Q: 4.5 How can I force a completely clean installation?"
To guarantee a completely clean installation of \s-1PDL,\s0 you will need
to first delete the current installation files and folders.  These
will be all directories named \f(CW\*(C`PDL\*(C'\fR in the Perl \f(CW@INC\fR path,
files named \f(CW\*(C`*Pdlpp*\*(C'\fR in any \f(CW\*(C`Inline\*(C'\fR directories, and the 
programs \f(CW\*(C`pdl, pdldoc, pdl2, perldl, and pptemplate\*(C'\fR.  Then just build
and install as usual.  This is much easier to keep track of if you
always install \f(CW\*(C`PDL\*(C'\fR into a non-standard location.  See Q: 4.4 above.
.SH "BINARY DISTRIBUTIONS"
.IX Header "BINARY DISTRIBUTIONS"
.SS "Q: 4.5    What binary distributions are available?"
.IX Subsection "Q: 4.5 What binary distributions are available?"
Information about binary distributions of \s-1PDL\s0 can be found on
<http://pdl.perl.org> .  At present there are binary distributions 
of \s-1PDL\s0 for Linux (RedHat and Debian), FreeBSD, Mac \s-1OS X\s0 and Windows, 
though they might not be the most recent version.
.PP
If someone is interested in providing binary distributions for other 
architectures, that would be very welcome. Let us know on the 
pdl\-devel@lists.sourceforge.net mailing list. Also check your Linux
distribution's package manager as many now include \s-1PDL.\s0  PPMs
for win32 versions (both 32bit and 64bit) are also available.
.SS "Q: 4.6    Does \s-1PDL\s0 run on Linux? (And what about packages?)"
.IX Subsection "Q: 4.6 Does PDL run on Linux? (And what about packages?)"
Yes, \s-1PDL\s0 does run on Linux and indeed much of the development
has been done under Linux. On <http://pdl.perl.org> you can find 
links to packages for some of the major distributions. Also 
check your distribution's package manager (yum, apt, urpmi, ...)
as \s-1PDL\s0 is now found by many of these.
.SS "Q: 4.7    Does \s-1PDL\s0 run under Windows?"
.IX Subsection "Q: 4.7 Does PDL run under Windows?"
\&\s-1PDL\s0 builds fine on Win32 using MinGW or Microsoft compilers.  See
the \fIwin32/INSTALL\fR file in the \s-1PDL\s0 source distribution for details.
Other compilers have not been tested\*(--input is welcome.  There is
also a distribution of \s-1PDL\s0 through ActiveState's ppm, though it
might not always be the latest version.  \s-1PDL\-2.018\s0 builds out of
the box on Strawberry Perl and ActiveState Perl and there are 
distributions of Strawberry Perl with bundled \s-1PDL\s0
(see <http://strawberryperl.com/releases.html>).
.SH "CVS, GIT, AND ON-GOING DEVELOPMENT"
.IX Header "CVS, GIT, AND ON-GOING DEVELOPMENT"
.SS "Q: 4.8    Can I get \s-1PDL\s0 via \s-1CVS\s0?"
.IX Subsection "Q: 4.8 Can I get PDL via CVS?"
No.  \s-1PDL\s0 development was conducted with a \s-1CVS\s0 repository from December
1999 to April 2009.  In April 2009 the project switched to the
Git version control system (see <http://git\-scm.com>).
.SS "Q: 4.9    How do I get \s-1PDL\s0 via Git?"
.IX Subsection "Q: 4.9 How do I get PDL via Git?"
Assume you have Git installed on your system and want to download the
project source code into the directory \f(CW\*(C`PDL\*(C'\fR. To get read-only access
to the repository, you type at the command line
.PP
.Vb 1
\&   git clone git://github.com/PDLPorters/pdl
.Ve
.PP
If you wish to submit changes to \s-1PDL,\s0 you should \*(L"fork\*(R" the repository
from <https://github.com/PDLPorters/pdl>, then clone your fork in the
normal fashion.
.PP
To become an official \s-1PDL\s0 developer, you will need to be added to the
GitHub \*(L"PDLPorters\*(R" organisation.
.PP
For official \s-1PDL\s0 developers, to get read/write access to the repository
type at the command line
.PP
.Vb 1
\&   git clone git://github.com/PDLPorters/pdl
.Ve
.PP
They can still use their own fork; at least one active developer uses
that model rather than branches on the main repository.
.SS "Q: 4.10   I had a problem with the Git version, how do I check if someone has submitted a patch?"
.IX Subsection "Q: 4.10 I had a problem with the Git version, how do I check if someone has submitted a patch?"
The best way is to check <https://github.com/PDLPorters/pdl/pulls> to see if
somebody has submitted a pull request related to your problem.
.PP
In addition, if you are not subscribing to the mailing list,
check the archive of the \f(CW\*(C`pdl\-devel\*(C'\fR and \f(CW\*(C`pdl\-general\*(C'\fR mailing lists.
See Question 3.2 for details.
.SS "Q: 4.11   I have gotten developer access to Git, how do I upload my changes?"
.IX Subsection "Q: 4.11 I have gotten developer access to Git, how do I upload my changes?"
The first thing you should do is to read the Git documentation and
learn the basics about Git. There are many sources available online.
It is very important that you use Git \*(L"best practice\*(R", with branches,
but fortunately this is very easy! Here are the basics.
.PP
Make sure your copy is up to date with the main repo:
.PP
.Vb 2
\&   git checkout master
\&   git pull \-\-rebase # rebase in case you wrongly changed your own master
.Ve
.PP
Make a branch:
.PP
.Vb 1
\&   git checkout \-b mybranch\-name
.Ve
.PP
Commit your changes locally:
.PP
.Vb 2
\&   git add <file1> <file2> ...
\&   git commit
.Ve
.PP
or combine these two with:
.PP
.Vb 1
\&   git commit \-a
.Ve
.PP
Test the \s-1PDL\s0 before you push it to the main repository.  If the
code is broken for you, then it is most likely broken for others.
Luckily, the rest of this process will test that automatically to help
you catch such errors.
.PP
Then update the shared repository with your changes:
.PP
.Vb 1
\&   git push \-u origin mybranch\-name
.Ve
.PP
This will still leave your changes on a branch, but this is good. Now
go to the GitHub page, <https://github.com/PDLPorters/pdl>. It will
ask you whether you want to make a \*(L"pull request\*(R" \- you do. Follow the
prompts. This will then initiate the automated \*(L"continuous integration\*(R"
tests, on Linux and Windows, with various versions of Perl, with various
compilers. You will also want to get at least one other developer to
review your changes.
.PP
Once this review process is successfully completed, you can merge your
changes to the master branch!
.SH "PDL JARGON"
.IX Header "PDL JARGON"
.SS "Q: 5.1    What is broadcasting (is \s-1PDL\s0 a newsreader)?"
.IX Subsection "Q: 5.1 What is broadcasting (is PDL a newsreader)?"
Until 2.075, \*(L"threading\*(R" was used to refer to two ideas,
but that ambiguity has now been resolved by using the now (as of
2022) industry-standard term \*(L"broadcasting\*(R" for the vectorisation /
array-programming concept.
.IP "\(bu" 4
When mentioned in the \fI\s-1INSTALL\s0\fR directions and possibly
during the build process we have the usual computer science
meaning of multi-threading in mind (useful mainly on
multiprocessor machines or clusters), currently (as of 2.074)
\&\s-1POSIX\s0 threads (see PDL::ParallelCPU).
.IP "\(bu" 4
\&\s-1PDL\s0 broadcasting of operations on ndarrays (as mentioned in the
indexing docs) is the iteration of a basic operation over
appropriate sub-slices of ndarrays, e.g. the inner product 
\&\f(CW\*(C`inner $x, $y\*(C'\fR of a (3) pdl \f(CW$x\fR and a (3,5,4) pdl 
\&\f(CW$y\fR results in a (5,4) ndarray where each
value is the result of an inner product of the (3) pdl with a
(3) sub-slice of the (3,5,4) ndarray.  For details check
PDL::Indexing
.PP
The connection is that broadcasting divides up independent operations
that can be done in parallel.
.SS "Q: 5.2    What is an ndarray?"
.IX Subsection "Q: 5.2 What is an ndarray?"
Well, \s-1PDL\s0 scalar variables (which are instances of a particular class
of Perl objects, i.e. blessed thingies (see \f(CW\*(C`perldoc perlobj\*(C'\fR )) are
in common \s-1PDL\s0 parlance often called \fIndarrays\fR (for example, check the
mailing list archives).  Err, clear?  If not, simply use the term
\&\fIndarray\fR when you refer to a \s-1PDL\s0 variable (an instance of a \s-1PDL\s0
object as you might remember) regardless of what actual data the \s-1PDL\s0
variable contains.
.SH "TECHNICAL QUESTIONS"
.IX Header "TECHNICAL QUESTIONS"
.SS "Q: 6.1    What is perldl?   What is pdl2?"
.IX Subsection "Q: 6.1 What is perldl? What is pdl2?"
Sometimes \f(CW\*(C`perldl\*(C'\fR (\f(CW\*(C`pdl2\*(C'\fR) is used as a synonym for \s-1PDL.\s0 Strictly
speaking, however, the name \f(CW\*(C`perldl\*(C'\fR (\f(CW\*(C`pdl2\*(C'\fR) is reserved for the
little shell that comes with the \s-1PDL\s0 distribution and is
supposed to be used for the interactive prototyping of \s-1PDL\s0
scripts. For details check perldl or pdl2.
.SS "Q: 6.2    How do I get on-line help for \s-1PDL\s0?"
.IX Subsection "Q: 6.2 How do I get on-line help for PDL?"
Just type \f(CW\*(C`help\*(C'\fR (shortcut = \*(L"?\*(R") at the \f(CW\*(C`pdl2\*(C'\fR shell 
prompt and proceed from there. Another useful command 
is the \f(CW\*(C`apropos\*(C'\fR (shortcut = \*(L"??\*(R") command.
Also try the \f(CW\*(C`demo\*(C'\fR command in the \f(CW\*(C`perldl\*(C'\fR or \f(CW\*(C`pdl2\*(C'\fR
shell if you are new to \s-1PDL.\s0
.SH "MANIPULATION OF NDARRAYS"
.IX Header "MANIPULATION OF NDARRAYS"
.ie n .SS "Q: 6.3    I want to access the third element of a pdl but $x[2] doesn't work ?!"
.el .SS "Q: 6.3    I want to access the third element of a pdl but \f(CW$x\fP[2] doesn't work ?!"
.IX Subsection "Q: 6.3 I want to access the third element of a pdl but $x[2] doesn't work ?!"
See answer to the next question why the normal Perl array syntax doesn't
work for ndarrays.
.SS "Q: 6.4    The docs say ndarrays are some kind of array. But why doesn't the Perl array syntax work with ndarrays then ?"
.IX Subsection "Q: 6.4 The docs say ndarrays are some kind of array. But why doesn't the Perl array syntax work with ndarrays then ?"
\&\s-1OK,\s0 you are right in a way. The docs say that ndarrays can be
thought of arrays.  More specifically, it says (
PDL::QuickStart ):
.PP
.Vb 4
\&    I find when using the Perl Data Language it is most useful
\&    to think of standard Perl @x variables as "lists" of generic
\&    "things" and PDL variables like $x as "arrays" which can be
\&    contained in lists or hashes.
.Ve
.PP
So, while ndarrays can be thought of as some kind of
multi-dimensional array they are 
\&\fB not\fR arrays in the Perl sense. Rather,
from the point of view of Perl they are some special class
(which is currently implemented as an opaque pointer to some
stuff in memory) and therefore need special functions (or
\&'methods' if you are using the \s-1OO\s0 version) to access
individual elements or a range of elements. The
functions/methods to check are 
\&\f(CW\*(C`at\*(C'\fR / \f(CW\*(C`set\*(C'\fR (see
the section 'Sections' in PDL::QuickStart ) or the powerful 
\&\f(CW\*(C`slice\*(C'\fR function and friends (see PDL::Slices and 
PDL::Indexing and especially PDL::NiceSlice ).
.PP
Finally, to confuse you completely, you can have Perl arrays
of ndarrays, e.g. \f(CW$spec[3]\fR can refer to a pdl representing ,e.g,
a spectrum, where \f(CW$spec[3]\fR is the fourth element of the Perl
list (or array ;) \f(CW@spec\fR .  This may be confusing but is 
very useful !
.SS "Q: 6.5    How do I concatenate ndarrays?"
.IX Subsection "Q: 6.5 How do I concatenate ndarrays?"
Most people will try to form new ndarrays from old ndarrays
using some variation over the theme: 
\&\f(CW\*(C`$x =  pdl([$y, 0, 2])\*(C'\fR.  This does work, but may not work in the way
that a novice user would expect. (If \f(CW$y\fR has N dimensions then \f(CW$x\fR
will have N+1 dimensions.) Other ways to concatenate ndarrays are
to use the functions \f(CW\*(C`cat\*(C'\fR, \f(CW\*(C`append\*(C'\fR, and \f(CW\*(C`glue\*(C'\fR. Similarly you can
split ndarrays using the command \f(CW\*(C`dog\*(C'\fR.
.SS "Q: 6.6    Sometimes I am getting these strange results when using inplace  operations?"
.IX Subsection "Q: 6.6 Sometimes I am getting these strange results when using inplace operations?"
This question is related to the \f(CW\*(C`inplace\*(C'\fR function. From the
documentation (see PDL::QuickStart):
.PP
.Vb 7
\&    Most functions, e.g. log(), return a result which is a
\&    transformation of their argument. This makes for good
\&    programming practice. However many operations can be done
\&    "in\-place" and this may be required when large arrays are in
\&    use and memory is at a premium. For these circumstances the
\&    operator inplace() is provided which prevents the extra copy
\&    and allows the argument to be modified. e.g.:
\&    
\&    $x = log($array);          # $array unaffected
\&    log( inplace($bigarray) ); # $bigarray changed in situ
.Ve
.PP
And also from the doc !!:
.PP
.Vb 3
\&    Obviously when used with some functions which can not be
\&    applied in situ (e.g. convolve()) unexpected effects may
\&    occur!
.Ve
.ie n .SS "Q: 6.7    What is this strange usage of the string concatenation operator  "".=""  in \s-1PDL\s0 scripts?"
.el .SS "Q: 6.7    What is this strange usage of the string concatenation operator  \f(CW.=\fP  in \s-1PDL\s0 scripts?"
.IX Subsection "Q: 6.7 What is this strange usage of the string concatenation operator .= in PDL scripts?"
See next question on assignment in \s-1PDL.\s0
.SS "Q: 6.8    Why are there two different kinds of assignment in \s-1PDL\s0 ?"
.IX Subsection "Q: 6.8 Why are there two different kinds of assignment in PDL ?"
This is caused by the fact that currently the assignment
operator \f(CW\*(C`=\*(C'\fR allows only restricted
overloading. For some purposes of \s-1PDL\s0 it turned out to be
necessary to have more control over the overloading of an
assignment operator. Therefore, \s-1PDL\s0 peruses the operator 
\&\f(CW\*(C`.=\*(C'\fR for certain types of assignments.
.SS "Q: 6.9    How do I set a set of values in an ndarray?"
.IX Subsection "Q: 6.9 How do I set a set of values in an ndarray?"
In Perl 5.6.7 and higher this assignment can be made
using lvalue subroutines:
.PP
.Vb 5
\&    pdl> $x = sequence(5); p $x
\&    [0 1 2 3 4]
\&    pdl> $x\->slice(\*(Aq1:2\*(Aq) .= pdl([5,6])
\&    pdl> p $x
\&    [0 5 6 3 4]
.Ve
.PP
see PDL::Lvalue for more info.  \s-1PDL\s0 also supports a more
matrix-like slice syntax via the PDL::NiceSlice module:
.PP
.Vb 3
\&    pdl> $x(1:2) .= pdl([5,6])
\&    pdl> p $x
\&    [0 5 6 3 4]
.Ve
.PP
With versions of Perl prior to 5.6.7 \fBor when running under
the perl debugger\fR this has to be done using a temporary variable:
.PP
.Vb 7
\&    pdl> $x = sequence(5); p $x
\&    [0 1 2 3 4]
\&    pdl> $tmp = $x\->slice(\*(Aq1:2\*(Aq); p $tmp;
\&    [1 2]
\&    pdl> $tmp .= pdl([5, 6]);    # Note .= !!
\&    pdl> p $x
\&    [0 5 6 3 4]
.Ve
.PP
This can also be made into one expression, which is often
seen in \s-1PDL\s0 code:
.PP
.Vb 3
\&    pdl> ($tmp = $x\->slice(\*(Aq1:2\*(Aq)) .= pdl([5,6])
\&    pdl> p $x
\&    [0 5 6 3 4]
.Ve
.SS "Q: 6.10   Can I use an ndarray in a conditional expression?"
.IX Subsection "Q: 6.10 Can I use an ndarray in a conditional expression?"
Yes you can, but not in the way you probably tried first. It
is not possible to use an ndarray directly in a conditional
expression since this is usually poorly defined. Instead \s-1PDL\s0
has two very useful functions: 
\&\f(CW\*(C`any\*(C'\fR and \f(CW\*(C`all\*(C'\fR . Use these to test if any or
all elements in an ndarray fulfills some criterion:
.PP
.Vb 3
\&    pdl> $x=pdl ( 1, \-2, 3);
\&    pdl> print \*(Aq$x has at least one element < 0\*(Aq if (any $x < 0);
\&    $x has at least one element < 0
\&    
\&    pdl> print \*(Aq$x is not positive definite\*(Aq unless (all $x > 0);
\&    $x is not positive definite
.Ve
.SS "Q: 6.11   Logical operators and ndarrays \-  '||' and '&&' don't work!"
.IX Subsection "Q: 6.11 Logical operators and ndarrays - '||' and '&&' don't work!"
It is a common problem that you try to make a mask array or something 
similar using a construct such as
.PP
.Vb 1
\&    $mask = which($ndarray > 1 && $ndarray < 2);   # incorrect
.Ve
.PP
This \fB does not\fR work! What you are looking for is the \fB bitwise\fR 
logical operators '|' and '&' which work on an element-by-element
basis. So it is really very simple: Do not use logical operators on 
multi-element ndarrays since that really doesn't make sense, instead 
write the example as:
.PP
.Vb 1
\&    $mask = which($ndarray > 1 & $ndarray < 2);
.Ve
.PP
which works correctly.
.SH "ADVANCED TOPICS"
.IX Header "ADVANCED TOPICS"
.SS "Q: 6.12   What is a null pdl ?"
.IX Subsection "Q: 6.12 What is a null pdl ?"
\&\f(CW\*(C`null\*(C'\fR is a special token for 'empty ndarray'. A null pdl 
can be used to flag to a \s-1PDL\s0 function that it should create 
an appropriately sized and typed ndarray. \fINull\fR ndarrays 
can be used in places where a \s-1PDL\s0 function expects an 
\&\fIoutput\fR or \fItemporary\fR argument. \fIOutput\fR and 
\&\fItemporary\fR arguments are flagged in the
\&\fIsignature\fR of a \s-1PDL\s0 function with the \f(CW\*(C`[o]\*(C'\fR and 
\&\f(CW\*(C`[t]\*(C'\fR qualifiers (see next question if you don't know what 
the \fIsignature\fR of a \s-1PDL\s0 function is).  For example, you 
can invoke the \f(CW\*(C`sumover\*(C'\fR function as follows:
.PP
.Vb 1
\&    sumover $x, $y=null;
.Ve
.PP
which is equivalent to
.PP
.Vb 1
\&    $y = sumover $x;
.Ve
.PP
If this seems still a bit murky check 
PDL::Indexing and 
\&\s-1PDL::PP\s0 for details about calling
conventions, the \fIsignature\fR and 
\&\fIbroadcasting\fR (see also below).
.SS "Q: 6.13   What is the signature of a \s-1PDL\s0 function ?"
.IX Subsection "Q: 6.13 What is the signature of a PDL function ?"
The \fIsignature\fR of a function is an important concept in \s-1PDL.\s0
Many (but not all) \s-1PDL\s0 function have a \fIsignature\fR which 
specifies the arguments and their (minimal) dimensionality. As 
an example, look at the signature of the \f(CW\*(C`maximum\*(C'\fR function:
.PP
.Vb 1
\&    \*(Aqa(n); [o] b;\*(Aq
.Ve
.PP
this says that \f(CW\*(C`maximum\*(C'\fR takes two arguments, the first of which is
(at least) one-dimensional while the second one is zero-dimensional and
an \fIoutput\fR argument (flagged by the \f(CW\*(C`[o]\*(C'\fR qualifier). If the function
is called with ndarrays of higher dimension the function will be repeatedly
called with slices of these ndarrays of appropriate dimension(this is called 
\&\fIbroadcasting\fR in \s-1PDL\s0).
.PP
For details and further explanations consult 
PDL::Indexing and \s-1PDL::PP\s0 .
.SS "Q: 6.14   How can I subclass (inherit from) ndarrays?"
.IX Subsection "Q: 6.14 How can I subclass (inherit from) ndarrays?"
The short answer is: read PDL::Objects (e.g. type 
\&\f(CW\*(C`help PDL::Objects\*(C'\fR in the \fIperldl\fR or \fIpdl2\fR shell).
.PP
The longer answer (extracted from PDL::Objects ): 
Since a \s-1PDL\s0 object is an opaque reference to a C struct, it is not 
possible to extend the \s-1PDL\s0 class by e.g. extra data via sub-classing 
(as you could do with a hash based Perl object).  To circumvent this 
problem \s-1PDL\s0 has built-in support to extend the \s-1PDL\s0 class via the 
\&\fIhas-a\fR relation for blessed hashes. You can get the \fIHAS-A\fR to
behave like \fIIS-A\fR simply in that you assign the \s-1PDL\s0
object to the attribute named \f(CW\*(C`PDL\*(C'\fR and
redefine the method \fBinitialize()\fR. For example:
.PP
.Vb 1
\&    package FOO;
\&    
\&    @FOO::ISA = qw(PDL);
\&    sub initialize {
\&       my $class = shift;
\&       my $self = {
\&          creation_time => time(),  # necessary extension :\-)
\&          PDL => PDL\->null,         # used to store PDL object
\&       };
\&       bless $self, $class;
\&    }
.Ve
.PP
For another example check the script 
\&\fIt/subclass.t\fR in the \s-1PDL\s0 distribution.
.SS "Q: 6.15   What on earth is this dataflow stuff ?"
.IX Subsection "Q: 6.15 What on earth is this dataflow stuff ?"
Dataflow is an experimental project that you don't need to concern
yourself with (it should not interfere with your usual programming). 
However, if you want to know, have a look at 
PDL::Dataflow . There
are applications which will benefit from this feature (and it is already
at work behind the scenes).
.SS "Q: 6.16   What is \s-1PDL::PP\s0?"
.IX Subsection "Q: 6.16 What is PDL::PP?"
Simple answer: \s-1PDL::PP\s0 is both a glue between external
libraries and \s-1PDL\s0 and a concise language for writing \s-1PDL\s0
functions.
.PP
Slightly longer answer: \s-1PDL::PP\s0 is used to compile very
concise definitions into \s-1XSUB\s0 routines implemented in C that
can easily be called from \s-1PDL\s0 and which automatically support
broadcasting, dataflow and other things without you having to
worry about it.
.PP
For further details check \s-1PDL::PP\s0 and the
section below on Extensions of \s-1PDL\s0.
.SS "Q: 6.17   What happens when I have several references to the same \s-1PDL\s0 object in different variables (cloning, etc?) ?"
.IX Subsection "Q: 6.17 What happens when I have several references to the same PDL object in different variables (cloning, etc?) ?"
ndarrays behave like Perl references in many respects. So when you say
.PP
.Vb 2
\&    $x = pdl [0,1,2,3];
\&    $y = $x;
.Ve
.PP
then both \f(CW$y\fR and \f(CW$x\fR point to the same object, e.g. then saying
.PP
.Vb 1
\&    $y++;
.Ve
.PP
will *not* create a copy of the original ndarray but just increment in
place, of which you can convince yourself by saying
.PP
.Vb 2
\&    print $x;
\&    [1 2 3 4]
.Ve
.PP
This should not be mistaken for dataflow which connects several
*different* objects so that data changes are propagated between
the so linked ndarrays (though, under certain circumstances, dataflowed
ndarrays can share physically the same data).
.PP
It is important to keep the \*(L"reference nature\*(R" of ndarrays in mind
when passing ndarrays into subroutines. If you modify the input
ndarrays you modify the original argument, \fInot\fR a copy of it. This
is different from some other array processing languages but makes
for very efficient passing of ndarrays between subroutines. If you
do not want to modify the original argument but rather a copy
of it just create a copy explicitly (this example also demonstrates
how to properly check for an \fIexplicit\fR request to process
inplace, assuming your routine can work inplace):
.PP
.Vb 11
\&    sub myfunc {
\&       my $pdl = shift;
\&       if ($pdl\->is_inplace) {
\&          $pdl\->set_inplace(0)
\&       } else {
\&          # modify a copy by default
\&          $pdl = $pdl\->copy
\&       }
\&       $pdl\->set(0,0);
\&       return $pdl;
\&    }
.Ve
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
.SS "Q: 6.18   What I/O formats are supported by \s-1PDL\s0 ?"
.IX Subsection "Q: 6.18 What I/O formats are supported by PDL ?"
The current versions of \s-1PDL\s0 already support quite a number of different
I/O formats.  However, it is not always obvious which module implements
which formats.  To help you find the right module for the format you
require, here is a short list of the current list of I/O formats and
a hint in which module to find the implementation:
.IP "\(bu" 4
A home brew fast raw (binary) I/O format for \s-1PDL\s0 is implemented by the
FastRaw module
.IP "\(bu" 4
The FlexRaw module implements generic methods for
the input and output of `raw' data arrays.  In particular, it is
designed to read output from \s-1FORTRAN 77 UNFORMATTED\s0 files and the
low-level C \f(CW\*(C`write\*(C'\fR function, even if the files are compressed or gzipped.
.Sp
It is possible that the FastRaw functionality will be included in the
FlexRaw module at some time in the future.
.IP "\(bu" 4
\&\s-1FITS I/O\s0 is implemented by the \f(CW\*(C`wfits\*(C'\fR/\f(CW\*(C`rfits\*(C'\fR functions in \s-1PDL::IO::FITS\s0 .
.IP "\(bu" 4
\&\s-1ASCII\s0 file I/O in various formats can be achieved by using the 
\&\f(CW\*(C`rcols\*(C'\fR and \f(CW\*(C`rgrep\*(C'\fR functions, also in PDL::IO::Misc .
.IP "\(bu" 4
PDL::IO::Pic implements an interface to the
NetPBM/PBM+ filters to read/write several popular image formats; also
supported is output of image sequences as \s-1MPEG\s0 movies, animated GIFs
and a wide variety of other video formats.
.IP "\(bu" 4
On \s-1CPAN\s0 you can find the PDL::NetCDF module that works with \s-1PDL 2.007.\s0
.PP
For further details consult the more detailed list in the \s-1PDL::IO\s0
documentation or the documentation for the individual modules.
.SS "Q: 6.19   How can I stack a set of 2D arrays (images) into a 3D ndarray?"
.IX Subsection "Q: 6.19 How can I stack a set of 2D arrays (images) into a 3D ndarray?"
Assuming all arrays are of the same size and in some format recognized by
\&\f(CW\*(C`rpic\*(C'\fR (see PDL::IO::Pic ) you could say:
.PP
.Vb 8
\&    use PDL::IO::Pic;
\&    @names = qw/name1.tif .... nameN.tif/;  # some file names
\&    $dummy = PDL\->rpic($names[0]);
\&    $cube = PDL\->zeroes($dummy\->type,$dummy\->dims,$#names+1); # make 3D ndarray
\&    for (0..$#names) {
\&        # this is the slice assignment
\&        ($tmp = $cube\->slice(":,:,($_)")) .= PDL\->rpic($names[$_]);
\&    }
.Ve
.PP
or
.PP
.Vb 1
\&    $cube(:,:,($_)) .= PDL\->rpic($names[$_]);
.Ve
.PP
for the slice assignment using the new PDL::NiceSlice syntax and Lvalue
assignments.
.PP
The for loop reads the actual images into a temporary 2D ndarray whose
values are then assigned (using the overloaded \f(CW\*(C`.=\*(C'\fR operator) to the
appropriate slices of the 3D ndarray \f(CW$cube\fR .
.SS "Q: 6.20   Where are test files for the graphics modules?"
.IX Subsection "Q: 6.20 Where are test files for the graphics modules?"
This answer applies mainly to PDL::Graphics::TriD (\s-1PDL\s0's device
independent 3D graphics model) which is the trickiest one in this
respect. You find some test scripts in Demos/TriD in the distribution.
There are also \fI3dtest.pl\fR and \fIline3d.pl\fR in the PDL/Example/TriD
directory.  After you have built \s-1PDL\s0 you can do:
.PP
.Vb 1
\&    perl \-Mblib Example/TriD/3dtest.pl
\&
\&    perl \-Mblib Example/TriD/line3d.pl
.Ve
.PP
to try the two TriD test programs.  They only exercise one TriD function
each but their simplicity makes it easy to debug if needed with the
Perl debugger, see perldebug.
.PP
The programs in the Demo directory can be run most easily from the
\&\f(CW\*(C`perldl\*(C'\fR or \f(CW\*(C`pdl2\*(C'\fR interactive shell:
.PP
.Vb 1
\&    perl \-Mblib perldl  or  perl \-Mblib Perldl2/pdl2
.Ve
.PP
followed by \f(CW\*(C`demo 3d\*(C'\fR or \f(CW\*(C`demo 3d2\*(C'\fR at the prompt.
\&\f(CW\*(C`demo\*(C'\fR by itself will give you a list of the available \s-1PDL\s0 demos.
.PP
You can run the test scripts in the Demos/TriD directory manually
by changing to that directory and running
.PP
.Vb 1
\&    perl \-Mblib <testfile>
.Ve
.PP
where \f(CW\*(C`testfile\*(C'\fR ; should match the pattern \f(CW\*(C`test[3\-9].p\*(C'\fR
and watch the results. Some of the tests should bring up a window
where you can control (twiddle) the 3D objects with the mouse. Try using
mouse button 1 for turning the objects in 3D space, mouse button 3
to zoom in and out, and 'q' to advance to the next stage of the test.
.SS "Q: 6.21   What is TriD or PDL::TriD or PDL::Graphics::TriD?"
.IX Subsection "Q: 6.21 What is TriD or PDL::TriD or PDL::Graphics::TriD?"
Questions like this should be a thing of the past with the \s-1PDL\s0
on-line help system in place. Just try (after installation):
.PP
.Vb 2
\&    un*x> pdl2
\&    pdl> apropos trid
.Ve
.PP
Check the output for promising hits and then try to look up
some of them, e.g.
.PP
.Vb 1
\&    pdl> help PDL::Graphics::TriD
.Ve
.PP
Note that case matters with \f(CW\*(C`help\*(C'\fR but not with \f(CW\*(C`apropos\*(C'\fR .
.SS "Q: 6.22   \s-1PGPLOT\s0 does not write out \s-1PNG\s0 files."
.IX Subsection "Q: 6.22 PGPLOT does not write out PNG files."
There are a few sources of trouble with \s-1PGPLOT\s0 and \s-1PNG\s0 files. First,
when compiling the pgplot libraries, make sure you uncomment the \s-1PNG\s0
entries in the \fIdrivers.list\fR file. Then when running 'make' you
probably got an error like
.PP
.Vb 1
\&  C<make: *** No rule to make target \`png.h\*(Aq, needed by \`pndriv.o\*(Aq.  Stop.>
.Ve
.PP
To fix this, find the line in the 'makefile' that starts with
\&'pndriv.o:' (it's near the bottom). Change, for example, ./png.h to
/usr/include/png.h, if that is where your header files are (you do
have the libpng and libz devel packages, don't you?).  Do this for all
four entries on that line, then go back and run \f(CW\*(C`make\*(C'\fR.
.PP
Second, if you already have the \s-1PGPLOT\s0 Perl module and \s-1PDL\s0 installed,
you probably tried to write out a \s-1PNG\s0 file and got fatal error message
like:
.PP
.Vb 1
\&  C<undefined symbol: png_create_write_struct>
.Ve
.PP
This is because the \s-1PGPLOT\s0 Perl module does not automatically link
against the png and z libraries. So when you are installing the \s-1PGPLOT\s0
Perl module (version 2.19) from \s-1CPAN,\s0 don't do \f(CW\*(C`install PGPLOT\*(C'\fR, but
just do \f(CW\*(C`get PGPLOT\*(C'\fR. Then exit from \s-1CPAN\s0 and manually install
\&\s-1PGPLOT,\s0 calling the makefile thusly:
.PP
.Vb 1
\&  C<perl Makefile.PL EXLIB=png,z EXDIR=/usr/lib>
.Ve
.PP
assuming that there exist files such as /usr/lib/libpng.so.*,
/usr/lib/libz.so.*. Then do the standard \f(CW\*(C`make;make test;make
install;\*(C'\fR sequence. Now you can write png files from \s-1PDL\s0!
.SH "EXTENSIONS OF PDL"
.IX Header "EXTENSIONS OF PDL"
.SS "Q: 7.1    I am looking for a package to do \s-1XXX\s0 in \s-1PDL.\s0 Where shall I look for it?"
.IX Subsection "Q: 7.1 I am looking for a package to do XXX in PDL. Where shall I look for it?"
The first stop is again \f(CW\*(C`perldl\*(C'\fR or \f(CW\*(C`pdl2\*(C'\fR and the on-line help
or the \s-1PDL\s0 documentation. There is already a lot of functionality in
\&\s-1PDL\s0 which you might not be aware of.  The easiest way to look for
functionality is to use the \f(CW\*(C`apropos\*(C'\fR command:
.PP
.Vb 5
\&    pdl> apropos \*(Aqintegral\*(Aq
\&    ceil            Round to integral values in floating\-point format
\&    floor           Round to integral values in floating\-point format
\&    intover         Project via integral to N\-1 dimensions
\&    rint            Round to integral values in floating\-point format
.Ve
.PP
Since the apropos command is no sophisticated search engine make
sure that you search on a couple of related topics and use short
phrases.
.PP
However there is a good chance that what you need is not part
of the \s-1PDL\s0 distribution. You are then well advised to check
out <http://pdl.perl.org> where there is a list of packages
using \s-1PDL.\s0 If that does not solve your problem, ask on the
mailing-list, if nothing else you might get assistance which
will let you interface your package with \s-1PDL\s0 yourself, see
also the next question.
.SS "Q: 7.2    Can I access my C/FORTRAN library routines in  \s-1PDL\s0?"
.IX Subsection "Q: 7.2 Can I access my C/FORTRAN library routines in PDL?"
Yes, you can, in fact it is very simple for many simple
applications. What you want is the \s-1PDL\s0 pre-processor \s-1PP\s0
(\s-1PDL::PP\s0 ). This will allow you to make a 
simple interface to your C routine.
.PP
The two functions you need to learn (at least first) are 
\&\f(CW\*(C`pp_def\*(C'\fR which defines the calling interface to the function, 
specifying input and output parameters, and contains the code 
that links to the external library. The other command is 
\&\f(CW\*(C`pp_end\*(C'\fR which finishes the \s-1PP\s0 definitions.  For details see
the \s-1PDL::PP\s0 man-page, but we also have a worked 
example here.
.PP
.Vb 4
\&    double eight_sum(int n)
\&    {
\&         int i;
\&         double sum, x;
\&    
\&         sum = 0.0; x=0.0;
\&         for (i=1; i<=n; i++) {
\&           x++;
\&           sum += x/((4.0*x*x\-1.0)*(4.0*x*x\-1.0));
\&         } 
\&         return 1.0/sum;
\&    }
.Ve
.PP
We will here show you an example of how you interface C
code with \s-1PDL.\s0 This is the first example and will show
you how to approximate the number 8...
.PP
The C code is shown above and is a simple function
returning a double, and expecting an integer \- the number
of terms in the sum \- as input. This function could be
defined in a library or, as we do here, as an inline
function.
.PP
We will postpone the writing of the Makefile till
later. First we will construct the 
\&\f(CW\*(C`.pd\*(C'\fR file. This is the file
containing \s-1PDL::PP\s0 code. We call this 
\&\f(CW\*(C`eight.pd\*(C'\fR .
.PP
.Vb 9
\&    # 
\&    # pp_def defines a PDL function. 
\&    #
\&    pp_addhdr (
\&    \*(Aq
\&    double eight_sum(int n)
\&    {
\&      int i;
\&      double sum, x;
\&    
\&      sum = 0.0; x=0.0;
\&      for (i=1; i<=n; i++) {
\&       x++; 
\&       sum += x/((4.0*x*x\-1.0)*(4.0*x*x\-1.0));
\&      }
\&     return 1.0/sum; 
\&    
\&    }  
\&    \*(Aq); 
\&    
\&    pp_def (
\&            \*(Aqeight\*(Aq,
\&         Pars => \*(Aqint a(); double [o]b();\*(Aq,
\&            Code => \*(Aq$b()=eight_sum($a());\*(Aq
\&           );
\&    
\&    # Always make sure that you finish your PP declarations with
\&    # pp_done
\&    
\&    pp_done();
.Ve
.PP
A peculiarity with our example is that we have included
the entire code with 
\&\f(CW\*(C`pp_addhdr\*(C'\fR instead of linking it in. This is only for the purposes of
example, in a typical application you will use 
\&\f(CW\*(C`pp_addhdr\*(C'\fR to include header
files. Note that the argument to 
\&\f(CW\*(C`pp_addhdr\*(C'\fR is enclosed in quotes.
.PP
What is most important in this example is however the
\&\f(CW\*(C`pp_def\*(C'\fR command. The first
argument to this is the name of the new function 
\&\fIeight \fR , then comes a hash which
the real meat:
.IP "\(bu" 4
This gives the input parameters (here  \f(CW\*(C`a\*(C'\fR) and the output parameters
(here  \f(CW\*(C`b\*(C'\fR). The latter are indicated by the  \f(CW\*(C`[o]\*(C'\fR specifier. Both
arguments can have a type specification as shown here.
.Sp
Many variations and further flexibility in the interface can be
specified. See \f(CW\*(C`perldoc PDL::PP\*(C'\fR for details.
.IP "\(bu" 4
This switch contains the code that should be
executed. As you can see this is a rather peculiar
mix of C and Perl, but essentially it is just as
you would write it in C, but the variables that
are passed from \s-1PDL\s0 are treated differently and
have to be referred to with a preceding '$'.
.Sp
There are also simple macros to pass pointers to
data and to obtain the values of other Perl
quantities, see the manual page for further
details.
.PP
Finally note the call to  
\&\f(CW\*(C`pp_done()\*(C'\fR at the end of the
file. This is necessary in all \s-1PP\s0 files.
.PP
\&\s-1OK.\s0 So now we have a file with code that we dearly would
like to use in Perl via \s-1PDL.\s0 To do this we need to
compile the function, and to do that we need a
Makefile.
.PP
.Vb 3
\&    use PDL::Core::Dev;
\&    use ExtUtils::MakeMaker;
\&    PDL::Core::Dev\->import();
\&    
\&    $package = ["eight.pd",Eight,PDL::Eight,\*(Aq\*(Aq,1];
\&    %hash = pdlpp_stdargs($package);
\&    
\&    WriteMakefile( %hash );
\&    
\&    sub MY::postamble {pdlpp_postamble($package)};
.Ve
.PP
The code above should go in a file called Makefile.PL,
which should subsequently be called in  the standard
Perl way: 
\&\f(CW\*(C`perl Makefile.PL\*(C'\fR .
This should give you a Makefile and running 
\&\f(CW\*(C`make\*(C'\fR should compile the module for
you and 
\&\f(CW\*(C`make install\*(C'\fR will
install it for you.
.PP
The fifth element in the \f(CW$package\fR array-ref is true. This tells \s-1PDL\s0
to generate one C file per \s-1PP\s0 function, which with the right \f(CW\*(C`make\*(C'\fR
options can be compiled in parallel, for a useful speedup of development
/ installation.
.SS "Q: 7.3    How can I interface package \s-1XXX\s0 in \s-1PDL\s0?"
.IX Subsection "Q: 7.3 How can I interface package XXX in PDL?"
This question is closely related to the previous one, and as
we said there, the 
\&\s-1PDL::PP\s0 pre-processor is the standard
way of interfacing external packages with \s-1PDL.\s0 The most usual
way to use \s-1PDL::PP\s0 is to write a short interface routine, see
the \s-1PDL::PP\s0 perldoc page and
the answer to the previous question for
examples.
.PP
However it is also possible to interface a package to \s-1PDL\s0 by
re-writing your function in \s-1PDL::PP\s0 directly. This can be
convenient in certain situations, in particular if you have a
routine that expects a function as input and you would like to
pass the function a Perl function for convenience.
.PP
The \s-1PDL::PP\s0 perldoc page is the main
source of information for writing \s-1PDL::PP\s0 extensions, but it
is very useful to look for files in the distribution of \s-1PDL\s0 as
many of the core functions are written in \s-1PDL::PP.\s0 Look for
files that end in \f(CW\*(C`.pd\*(C'\fR which is the generally accepted 
suffix for \s-1PDL::PP\s0 files. But we also have a simple example here.
.PP
The following example will show you how to write a simple
function that automatically allows broadcasting. To make this
concise the example is of an almost trivial function, but
the intention is to show the basics of writing a \s-1PDL::PP\s0
interface.
.PP
We will write a simple function that calculates the minimum,
maximum and average of an ndarray. On my machine the resulting
function is 8 times faster than the built-in function 
\&\f(CW\*(C`stats\*(C'\fR (of course the latter also
calculates the median).
.PP
Let's jump straight in. Here is the code (from a file called
\&\f(CW\*(C`quickstats.pd\*(C'\fR )
.PP
.Vb 10
\&    #
\&    pp_def(\*(Aqquickstats\*(Aq,
\&         Pars => \*(Aqa(n); [o]avg(); [o]max(); [o]min()\*(Aq,
\&         Code => \*(Aq$GENERIC(a) curmax, curmin;
\&                  $GENERIC(a) tmp=0;
\&                     loop(n) %{
\&                       tmp += $a();
\&                       if (!n || $a() > curmax) { curmax = $a();}
\&                       if (!n || $a() < curmin) { curmin = $a();}
\&                     %}
\&                     $avg() = tmp/$SIZE(n);
\&                  $max() = curmax;
\&                  $min() = curmin;
\&                    \*(Aq
\&         );
\&    
\&    pp_done();
.Ve
.PP
The above might look like a confusing mixture of C and
Perl, but behind the peculiar syntax lies a very
powerful language. Let us take it line by line.
.PP
The first line declares that we are starting the
definition of a \s-1PDL:PP\s0 function called
\&\f(CW\*(C`quickstats\*(C'\fR .
.PP
The second line is very important as it specifies the
input and output parameters of the function.  
\&\f(CWa(n)\fR tells us that there is one input
parameter that we will refer to as 
\&\f(CW\*(C`a\*(C'\fR which is expected to be a vector of
length n (likewise matrices, both square and rectangular
would be written as 
\&\f(CW\*(C`a(n,n)\*(C'\fR and
\&\f(CW\*(C`a(n,m)\*(C'\fR respectively). To
indicate that something is an output parameter we put
\&\f(CW\*(C`[o]\*(C'\fR in front of their names, so
referring back to the code we see that avg, max and min
are three output parameters, all of which are scalar
(since they have no dimensional size indicated.
.PP
The third line starts the code definition which is
essentially pure C but with a couple of convenient
functions. 
\&\f(CW$GENERIC\fR is a
function that returns the C type of its argument \- here
the input parameter a. Thus the first two lines of the
code section are variable declarations.
.PP
The 
\&\f(CWloop(n)\fR construct is a
convenience function that loops over the dimension
called n in the parameter section. Inside this loop we
calculate the cumulative sum of the input vector and
keep track of the maximum and minimum values. Finally 
we assign the resulting values to the output
parameters.
.PP
Finally we finish our function declaration with 
\&\f(CW\*(C`pp_done()\*(C'\fR .
.PP
To compile our new function we need to create a Makefile,
which we will just list since its creation is discussed in
an earlier question.
.PP
.Vb 3
\&    use PDL::Core::Dev;
\&    use ExtUtils::MakeMaker;
\&    PDL::Core::Dev\->import();
\&    
\&    $package = ["quickstats.pd",Quickstats,PDL::Quickstats,\*(Aq\*(Aq,1];
\&    %hash = pdlpp_stdargs($package);
\&    
\&    WriteMakefile( %hash );
\&    
\&    sub MY::postamble {pdlpp_postamble($package)};
.Ve
.PP
An example Makefile.PL
.PP
Our new statistic function should now compile using the
tried and tested Perl way: 
\&\f(CW\*(C`perl Makefile.PL; make\*(C'\fR .
.PP
You should experiment with this function, changing the
calculations and input and output parameters. In conjunction
with the \s-1PDL::PP\s0 perldoc page this should allow you to quickly
write more advanced routines directly in \s-1PDL::PP.\s0
.SH "BUGS"
.IX Header "BUGS"
If you find any inaccuracies in this document (or dis-functional
URLs) please report to the perldl mailing list pdl\-general@lists.sourceforge.net.
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Achim Bohnet (ach@mpe.mpg.de ) for suggesting CoolHTML as a
prettypodder (although we have switched to \s-1XML\s0 now) and various
other improvements. Suggestions for some questions were taken
from Perl \s-1FAQ\s0 and adapted for \s-1PDL.\s0
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Many people have contributed or given feedback on the current
version of the \s-1FAQ,\s0 here is an incomplete list of individuals
whose contributions or posts to the mailing-list have improved
this \s-1FAQ\s0 at some point in time alphabetically listed by first
name: Christian Soeller, Chris Marshall, Doug Burke, Doug Hunt,
Frank Schmauder, Jarle Brinchmann, John Cerney, Karl Glazebrook,
Kurt Starsinic, Thomas Yengst, Tuomas J. Lukka.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
This document emerged from a joint effort of several \s-1PDL\s0
developers (Karl Glazebrook, Tuomas J. Lukka, Christian
Soeller) to compile a list of the most frequently asked questions
about \s-1PDL\s0 with answers.  Permission is granted for verbatim
copying (and formatting) of this material as part of \s-1PDL.\s0
.PP
Permission is explicitly not granted for distribution in book
or any corresponding form. Ask on the \s-1PDL\s0 mailing list
pdl\-general@lists.sourceforge.net if some of the issues covered
in here are unclear.
