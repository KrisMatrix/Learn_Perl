.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "BADVALUES 1"
.TH BADVALUES 1 "2022-04-15" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::BadValues \- Discussion of bad value support in PDL
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "What are bad values and why should I bother with them?"
.IX Subsection "What are bad values and why should I bother with them?"
Sometimes it's useful to be able to specify a certain value is 'bad' or 
\&'missing'; for example CCDs used in astronomy produce 2D images which are not
perfect since certain areas contain invalid data due to imperfections in the
detector.  Whilst \s-1PDL\s0's powerful index
routines and all the complicated business with dataflow, slices, etc etc mean 
that these regions can be ignored in processing, it's awkward to do. It would
be much easier to be able to say \f(CW\*(C`$c = $x + $y\*(C'\fR and leave all the hassle to 
the computer.
.PP
If you're not interested in this, then you may (rightly) be concerned 
with how this affects the speed of \s-1PDL,\s0 since the overhead of checking for a
bad value at each operation can be large. 
Because of this, the code has been written to be as fast as possible \-
particularly when operating on ndarrays which do not contain bad values.
In fact, you should notice essentially no speed difference when working 
with ndarrays which do not contain bad values.
.PP
You may also ask 'well, my computer supports \s-1IEEE\s0 NaN, so I already have this'.
They are different things; a bad value signifies \*(L"leave this out of
processing\*(R", whereas NaN is the result of a mathematically-invalid
operation.
.PP
Many routines, such as \f(CW\*(C`y=sin(x)\*(C'\fR, will propagate NaN's
without the user having to code differently, but routines such as \f(CW\*(C`qsort\*(C'\fR, or
finding the median of an array, need to be re-coded to handle bad values.
For floating-point datatypes, \f(CW\*(C`NaN\*(C'\fR and \f(CW\*(C`Inf\*(C'\fR can be used to flag bad
values, but by default
special values are used (Default bad values).
.PP
There is one default bad value for each datatype, but
as of \s-1PDL 2.040,\s0 you can have different bad values for separate ndarrays of the
same type.
.PP
You can use \f(CW\*(C`NaN\*(C'\fR as the bad value for any floating-point type,
including complex.
.SS "A quick overview"
.IX Subsection "A quick overview"
.Vb 10
\& pdl> $x = sequence(4,3);
\& pdl> p $x
\& [
\&  [ 0  1  2  3]
\&  [ 4  5  6  7]
\&  [ 8  9 10 11]
\& ]
\& pdl> $x = $x\->setbadif( $x % 3 == 2 )
\& pdl> p $x
\& [
\&  [  0   1 BAD   3]
\&  [  4 BAD   6   7]
\&  [BAD   9  10 BAD]
\& ]
\& pdl> $x *= 3
\& pdl> p $x
\& [
\&  [  0   3 BAD   9]
\&  [ 12 BAD  18  21]
\&  [BAD  27  30 BAD]
\& ]
\& pdl> p $x\->sum
\& 120
.Ve
.PP
\&\f(CW\*(C`demo bad\*(C'\fR
within perldl or pdl2 gives a demonstration of some of the things
possible with bad values.  These are also available on \s-1PDL\s0's web-site,
at \fIhttp://pdl.perl.org/demos/\fR.  See PDL::Bad for useful routines for working 
with bad values and \fIt/bad.t\fR to see them in action.
.PP
To find out if a routine supports bad values, use the \f(CW\*(C`badinfo\*(C'\fR command in
perldl or pdl2 or the \f(CW\*(C`\-b\*(C'\fR option to pdldoc.
.PP
Each ndarray contains a flag \- accessible via \f(CW\*(C`$pdl\->badflag\*(C'\fR \- to say
whether there's any bad data present:
.IP "\(bu" 4
If \fBfalse/0\fR, which means there's no bad data here, the code supplied by the 
\&\f(CW\*(C`Code\*(C'\fR option to \f(CW\*(C`pp_def()\*(C'\fR is executed.
.IP "\(bu" 4
If \fBtrue/1\fR, then this says there \fI\s-1MAY\s0\fR be bad data in the ndarray, so use the
code in the \f(CW\*(C`BadCode\*(C'\fR option (assuming that the \f(CW\*(C`pp_def()\*(C'\fR for this routine 
has been updated to have a BadCode key). 
You get all the advantages of broadcasting, as with the \f(CW\*(C`Code\*(C'\fR option,
but it will run slower since you are going to have to handle the presence of bad values.
.PP
If you create an ndarray, it will have its bad-value flag set to 0. To change 
this, use \f(CW\*(C`$pdl\->badflag($new_bad_status)\*(C'\fR, where \f(CW$new_bad_status\fR can be 0 or 1.
When a routine creates an ndarray, its bad-value flag will depend on the input
ndarrays: unless over-ridden (see the \f(CW\*(C`CopyBadStatusCode\*(C'\fR option to \f(CW\*(C`pp_def\*(C'\fR), the 
bad-value flag will be set true if any of the input ndarrays contain bad values.
To check that an ndarray really contains bad data, use the \f(CW\*(C`check_badflag\*(C'\fR method.
.PP
\&\fI\s-1NOTE\s0\fR: propagation of the badflag
.PP
If you change the badflag of an ndarray, this change is propagated to all
the \fIchildren\fR of an ndarray, so
.PP
.Vb 8
\&   pdl> $x = zeroes(20,30);
\&   pdl> $y = $x\->slice(\*(Aq0:10,0:10\*(Aq);
\&   pdl> $c = $y\->slice(\*(Aq,(2)\*(Aq);
\&   pdl> print ">>c: ", $c\->badflag, "\en";
\&   >>c: 0
\&   pdl> $x\->badflag(1);
\&   pdl> print ">>c: ", $c\->badflag, "\en";
\&   >>c: 1
.Ve
.PP
This is also propagated to the parents of an ndarray, so
.PP
.Vb 5
\&   pdl> print ">>a: ", $x\->badflag, "\en";
\&   >>a: 1
\&   pdl> $c\->badflag(0);
\&   pdl> print ">>a: ", $x\->badflag, "\en";
\&   >>a: 0
.Ve
.PP
There's also
the issue of what happens if you change the badvalue of an ndarray \- should
these propagate to children/parents (yes) or whether you should only be
able to change the badvalue at the 'top' level \- i.e. those ndarrays which do
not have parents.
.PP
The \f(CW\*(C`orig_badvalue()\*(C'\fR method returns the compile-time value for a given 
datatype. It works on ndarrays, PDL::Type objects, and numbers \- eg
.PP
.Vb 1
\&  $pdl\->orig_badvalue(), byte\->orig_badvalue(), and orig_badvalue(4).
.Ve
.PP
To get the current bad value, use the \f(CW\*(C`badvalue()\*(C'\fR method \- it has the same
syntax as \f(CW\*(C`orig_badvalue()\*(C'\fR.
.PP
To change the current bad value, supply the new number to badvalue \- eg
.PP
.Vb 1
\&  $pdl\->badvalue(2.3), byte\->badvalue(2), badvalue(5,\-3e34).
.Ve
.PP
\&\fINote\fR: the value is silently converted to the correct C type, and
returned \- i.e. \f(CW\*(C`byte\->badvalue(\-26)\*(C'\fR returns 230 on my Linux machine.
.PP
Note that changes to the bad value are \fI\s-1NOT\s0\fR propagated to previously-created
ndarrays \- they will still have the bad flag set, but suddenly the elements
that were bad will become 'good', but containing the old bad value.
See discussion below.
.SS "Bad values and boolean operators"
.IX Subsection "Bad values and boolean operators"
For those boolean operators in PDL::Ops, evaluation 
on a bad value returns the bad value. This:
.PP
.Vb 1
\& $mask = $img > $thresh;
.Ve
.PP
correctly propagates bad values. This will omit any bad values, but
return a bad value if there are no good ones:
.PP
.Vb 1
\& $bool = any( $img > $thresh );
.Ve
.PP
As of 2.077, a bad value used as a boolean will throw an exception.
.PP
When using one of the 'projection' functions in PDL::Ufunc \- such as 
orover \- 
bad values are skipped over (see the documentation of these
functions for the current handling of the case when
all elements are bad).
.SH "IMPLEMENTATION DETAILS"
.IX Header "IMPLEMENTATION DETAILS"
A new flag has been added to the state of an ndarray \- \f(CW\*(C`PDL_BADVAL\*(C'\fR. If unset, then
the ndarray does not contain bad values, and so all the support code can be 
ignored. If set, it does not guarantee that bad values are present, just that
they should be checked for.
.PP
The \f(CW\*(C`pdl_trans\*(C'\fR structure has been extended to include an integer value,
\&\f(CW\*(C`bvalflag\*(C'\fR, which acts as a switch to tell the code whether to handle bad values
or not. This value is set if any of the input ndarrays have their \f(CW\*(C`PDL_BADVAL\*(C'\fR 
flag set (although this code can be replaced by setting \f(CW\*(C`FindBadStateCode\*(C'\fR in 
pp_def).
.SS "Default bad values"
.IX Subsection "Default bad values"
The default bad values
are now stored in a structure within the Core \s-1PDL\s0 structure
\&\- \f(CW\*(C`PDL.bvals\*(C'\fR (eg \fIBasic/Core/pdlcore.h.PL\fR); see also 
\&\f(CW\*(C`typedef badvals\*(C'\fR in \fIBasic/Core/pdl.h.PL\fR and the
\&\s-1BOOT\s0 code of \fIBasic/Core/Core.xs.PL\fR where the values are initialised to 
(hopefully) sensible values.
See \*(L"badvalue\*(R" in PDL::Bad and \*(L"orig_badvalue\*(R" in PDL::Bad for read/write routines to the values.
.PP
The default/original bad values are set to the C type's maximum (unsigned
integers) or the minimum (floating-point and signed integers).
.SS "How do I change a routine to handle bad values?"
.IX Subsection "How do I change a routine to handle bad values?"
See \*(L"BadCode\*(R" in \s-1PDL::PP\s0 and \*(L"HandleBad\*(R" in \s-1PDL::PP\s0.
.PP
If you have a routine that you want to be able to use as in-place, look
at the routines in \fIbad.pd\fR (or \fIops.pd\fR)
which use the \f(CW\*(C`in\-place\*(C'\fR option to see how the
bad flag is propagated to children using the \f(CW\*(C`xxxBadStatusCode\*(C'\fR options.
I decided not to automate this as rules would be a
little complex, since not every in-place op will need to propagate the 
badflag (eg unary functions).
.PP
This all means that you can change
.PP
.Vb 1
\&   Code => \*(Aq$a() = $b() + $c();\*(Aq
.Ve
.PP
to
.PP
.Vb 5
\&   BadCode => \*(Aqif ( $ISBAD(b()) || $ISBAD(c()) ) { 
\&                 $SETBAD(a()); 
\&               } else {
\&                 $a() = $b() + $c();
\&               }\*(Aq
.Ve
.PP
leaving Code as it is. PP::PDLCode will then create code something like
.PP
.Vb 5
\&   if ( _\|_trans\->bvalflag ) {
\&        broadcastloop over BadCode
\&   } else { 
\&        broadcastloop over Code
\&   }
.Ve
.SH "WHAT ABOUT DOCUMENTATION?"
.IX Header "WHAT ABOUT DOCUMENTATION?"
One of the strengths of \s-1PDL\s0 is its on-line documentation. The aim is to use
this system to provide information on how/if a routine supports bad values:
in many cases \f(CW\*(C`pp_def()\*(C'\fR contains all the information anyway, so the 
function-writer doesn't need to do anything at all! For the cases when this is
not sufficient, there's the \f(CW\*(C`BadDoc\*(C'\fR option. For code written at
the Perl level \- i.e. in a .pm file \- use the \f(CW\*(C`=for bad\*(C'\fR pod directive.
.PP
This information will be available via man/pod2man/html documentation. It's also
accessible from the \f(CW\*(C`perldl\*(C'\fR or \f(CW\*(C`pdl2\*(C'\fR shells \- using the \f(CW\*(C`badinfo\*(C'\fR command \- and the \f(CW\*(C`pdldoc\*(C'\fR
shell command \- using the \f(CW\*(C`\-b\*(C'\fR option.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Doug Burke (djburke@cpan.org), 2000, 2006.
.PP
The per-ndarray bad value support is by Heiko Klein (2006).
