.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "TIPS 1"
.TH TIPS 1 "2021-11-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Tips \- Small tidbits of useful arcana. Programming tidbits and such.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use PDL;
\&
\&        # Whatever happens here.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page documents useful idioms, helpful hints and tips for using
Perl Data Language v2.0.
.SS "Help"
.IX Subsection "Help"
Use \f(CW\*(C`help help\*(C'\fR within \fIperldl\fR or \fIpdl2\fR or use the \f(CW\*(C`pdldoc\*(C'\fR
program from the command line for access to the PerlDL documentation.
\&\s-1HTML\s0 versions of the pages should also be present, in the
\&\fIHtmlDocs/PDL\fR directory of the \s-1PDL\s0 distribution. To find this 
directory, try the following
.PP
.Vb 1
\& pdl> foreach ( map{"$_/PDL/HtmlDocs"}@INC ) { p "$_\en" if \-d $_ }
.Ve
.SS "Indexing idioms"
.IX Subsection "Indexing idioms"
The following code normalizes a bunch of vectors in \f(CW$x\fR.
This works regardless of the dimensionality of \f(CW$x\fR.
.PP
.Vb 1
\&        $x /= $x\->sumover\->dummy(0);
.Ve
.SS "What is actually happening?"
.IX Subsection "What is actually happening?"
If you want to see what the code is actually doing,
try the command
.PP
.Vb 1
\&        PDL::Core::set_debugging(1);
.Ve
.PP
somewhere. This spews out a huge amount of debug info for \s-1PDL\s0
into \s-1STDOUT.\s0 Plans for the future include making it possible to
redirect the output, and also making it possible to select messages
with more precision.
.PP
Many of the messages come from \f(CW\*(C`Basic/Core/pdlapi.c\*(C'\fR and you
can look at the source to see what is going on.
.PP
If you have any extra time to work on these mechanisms,
inform the pdl-porters mailing list.
.SS "Memory savings"
.IX Subsection "Memory savings"
If you are running recursively something that selects certain
indices of a large ndarray, like
.PP
.Vb 6
\&        while(1) {
\&                $inds = where($x>0);
\&                $x = $x\->index($inds);
\&                $y = $y\->index($inds);
\&                func($y,$x);
\&        }
.Ve
.PP
If you are not writing to \f(CW$y\fR, it saves a lot of memory to change this
to
.PP
.Vb 1
\&                $y = $y\->index($inds)\->sever;
.Ve
.PP
The new method \f(CW\*(C`sever\*(C'\fR is a causes the write-back relation to be
forgotten. It is like copy except it changes the original ndarray
and returns it).
.PP
Of course, the probably best way to do the above is
.PP
.Vb 8
\&        $inds = xvals ($x\->long);
\&        while(1) {
\&                $inds0 = where($x>0);
\&                $inds1 = $inds\->index($inds)\->sever;
\&                $x = $a0\->index($inds1);
\&                $y = $y\->index($inds1)\->sever;
\&                func($y,$x);
\&        }
.Ve
.PP
which doesn't save all the temporary instances of \f(CW$x\fR in memory.
See \f(CW\*(C`mandel.pl\*(C'\fR in the Demos subdirectory of the PerlDL distribution
for an example.
.SS "\s-1PP\s0 speed"
.IX Subsection "PP speed"
If you really want to write speedy \s-1PP\s0 code, the first
thing you need to do is to make sure that your C compiler
is allowed to do the necessary optimizations.
.PP
What this means is that you have to allow as many variables
as possible to go into registers:
.PP
.Vb 3
\&        loop(a) %{
\&                $a() += $COMP(foo_member) * $b()
\&        %}
.Ve
.PP
expands to
.PP
.Vb 3
\&        for(i=0; i<10000; i++) {
\&                a[i] += _\|_privtrans\->foo_member * b[i];
\&        }
.Ve
.PP
is about the worst you can do, since your C compiler is not
allowed to assume that \f(CW\*(C`a\*(C'\fR doesn't clobber \f(CW\*(C`foo_member\*(C'\fR
which completely inhibits vectorization. Instead, do
.PP
.Vb 4
\&        float foo = $COMP(foo_member);
\&        loop(a) %{
\&                $a() += foo * $b();
\&        %}
.Ve
.PP
This is not a restriction caused by \s-1PP\s0 but by \s-1ANSI C\s0 semantics.
Of course, we could copy the struct into local variables and back but that
could cause very strange things sometimes.
.PP
There are many other issues on organizing loops.
.PP
We are currently planning to make \s-1PP\s0 able to do fixed-width
things as well as physical ndarrays (where looping over the first
dimensions would be cheaper as there are less distinct increments,
which might make a difference on machines with a small number of registers).
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Tuomas J. Lukka 1997. All rights reserved.
Duplication in the same form and printing a copy for yourself allowed.
