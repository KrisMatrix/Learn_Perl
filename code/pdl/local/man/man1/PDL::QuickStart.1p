.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "QUICKSTART 1"
.TH QUICKSTART 1 "2022-03-19" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::QuickStart \- Quick introduction to PDL features.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A brief summary of the main \s-1PDL\s0 features and how to use them.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Introduction"
.IX Subsection "Introduction"
Perl is an extremely good and versatile scripting language, well suited to
beginners and allows rapid prototyping. However until recently it did not
support data structures which allowed it to do fast number crunching.
.PP
However with the development of Perl v5, Perl acquired 'Objects'. To put
it simply users can define their own special data types, and write
custom routines to manipulate them either in low level languages (C and
Fortran) or in Perl itself.
.PP
This has been fully exploited by the PerlDL developers. The '\s-1PDL\s0' module is a
complete Object-Oriented extension to Perl (although you don't have to know
what an object is to use it) which allows large N\-dimensional data sets, such
as large images, spectra, time series, etc to be stored  \fBefficiently\fR and
manipulated \fBen masse\fR.  For example  with the \s-1PDL\s0 module we can write the
Perl code \f(CW\*(C`$x = $y + $z\*(C'\fR, where \f(CW$y\fR and \f(CW$z\fR are large datasets
(e.g. 2048x2048 images), and get the result in only a fraction of a second.
.PP
\&\s-1PDL\s0 variables (or 'ndarrays' as they have come to be known)
support a wide range of fundamental data types \- arrays can be bytes,
short integers (signed or unsigned), long integers, floats or
double precision floats. And because of the Object-Oriented nature
of \s-1PDL\s0 new customised datatypes can be derived from them.
.PP
As well as the \s-1PDL\s0 modules, that can be used by normal Perl programs, PerlDL
comes with a command line Perl shell, called 'perldl', which supports command
line editing. In combination with the various \s-1PDL\s0 graphics modules this allows
data to be easily played with and visualised.
.SS "Help"
.IX Subsection "Help"
\&\s-1PDL\s0 contains extensive documentation, available both within the
\&\fIperldl\fR or \fIpdl2\fR shells and from the command line, using the \f(CW\*(C`pdldoc\*(C'\fR program.
For further information try either of:
.PP
.Vb 2
\& pdl> help help
\& $ pdldoc
.Ve
.PP
\&\s-1HTML\s0 copies of the documentation should also be available.
To find their location, try the following:
.PP
.Vb 1
\& pdl> foreach ( map{"$_/PDL/HtmlDocs"}@INC ) { p "$_\en" if \-d $_ }
.Ve
.SS "Perl Datatypes and how \s-1PDL\s0 extends them"
.IX Subsection "Perl Datatypes and how PDL extends them"
The fundamental Perl data structures are scalar variables, e.g. \f(CW$x\fR,
which can hold numbers or strings, lists or arrays of scalars, e.g. \f(CW@x\fR,
and associative arrays/hashes of scalars, e.g. \f(CW%x\fR.
.PP
Perl v5 introduces to Perl data structures and objects. A simple
scalar variable \f(CW$x\fR now be a user-defined data type or full blown
object (it actually holds a reference (a smart \*(L"pointer\*(R") to this
but that is not relevant for ordinary use of perlDL)
.PP
The fundamental idea behind perlDL is to allow \f(CW$x\fR to hold a whole 1D
spectrum, or a 2D image, a 3D data cube, and so on up to large
N\-dimensional data sets. These can be manipulated all at once, e.g.
\&\f(CW\*(C`$x = $y + 2\*(C'\fR does a vector operation on each value in the
spectrum/image/etc.
.PP
You may well ask: "Why not just store a spectrum as a simple Perl \f(CW@x\fR
style list with each pixel being a list item?"  The two key answers to
this are \fImemory\fR and \fIspeed\fR.  Because we know our spectrum consists of
pure numbers we can compactly store them in a single block of memory
corresponding to a C style numeric array. This takes up a \s-1LOT\s0 less
memory than the equivalent Perl list. It is then easy to pass this
block of memory to a fast addition routine, or to any other C function
which deals with arrays.  As a result perlDL is very fast \-\-\- for example
one can multiply a 2048*2048 image in exactly the same time as it
would take in C or \s-1FORTRAN\s0 (0.1 sec on my \s-1SPARC\s0). A further advantage
of this is that for simple operations (e.g. \f(CW\*(C`$x += 2\*(C'\fR) one can manipulate
the whole array without caring about its dimensionality.
.PP
I find when using perlDL it is most useful to think of standard Perl
\&\f(CW@x\fR variables as \*(L"lists\*(R" of generic \*(L"things\*(R" and \s-1PDL\s0 variables like
\&\f(CW$x\fR as \*(L"arrays\*(R" which can be contained in lists or hashes. Quite
often in my perlDL scripts I have \f(CW@x\fR contain a list of spectra, or a
list of images (or even a mix!). Or perhaps one could have a hash
(e.g.  \f(CW%x\fR) of images... the only limit is memory!
.PP
perlDL variables support a range of data types \- arrays can be bytes,
short integers (signed or unsigned), long integers, floats or
double precision floats.
.SS "Usage"
.IX Subsection "Usage"
PerlDL is loaded into your Perl script using this command:
.PP
.Vb 1
\& use PDL;  # in Perl scripts: use the standard perlDL modules
.Ve
.PP
There are also a lot of extension modules, e.g. 
PDL::Graphics::TriD. 
Most of these (but not all as sometimes it is not appropriate) follow
a standard convention. If you say:
.PP
.Vb 1
\& use PDL::Graphics::TriD;
.Ve
.PP
You import everything in a standard list from the module. Sometimes
you might want to import nothing (e.g. if you want to use \s-1OO\s0 syntax
all the time and save the import tax). For these you say:
.PP
.Vb 1
\& use PDL::Graphics::TriD qw();
.Ve
.PP
And the empty \f(CW\*(C`qw()\*(C'\fR  quotes are recognised as meaning 'nothing'.
You can also specify a list of functions to import in the normal
Perl way.
.PP
There is also an interactive shell, \f(CW\*(C`perldl\*(C'\fR or \f(CW\*(C`pdl2\*(C'\fR, see \fIperldl\fR
or pdl2 for details.
.SS "To create a new \s-1PDL\s0 variable"
.IX Subsection "To create a new PDL variable"
Here are some ways of creating a \s-1PDL\s0 variable:
.PP
.Vb 10
\& $x = pdl [1..10];             # 1D array
\& $x = pdl (1,2,3,4);           # Ditto
\& $x = pdl \*(Aq[1 2 3 4]\*(Aq;         # Ditto
\& $y = pdl [[1,2,3],[4,5,6]];   # 2D 3x2 array
\& $y = pdl \*(Aq[1 2 3; 4 5 6]\*(Aq;    # Ditto
\& $y = pdl q[1,2,3; 4,5,6];     # Ditto
\& $y = pdl <<NEWPDL             # Ditto
\&   [1 2 3]
\&   [4 5 6]
\& NEWPDL
\& $c = pdl q[1 \-2];             # 2\-element ndarray containing 1 and \-2
\& $c = pdl q[1 \- 2];            # 2\-element ndarray containing 1 and \-2
\& $y = pdl 42                   # 0\-dimensional scalar
\& $c = pdl $x;                  # Make a new copy
\& 
\& $d = byte [1..10];            # See "Type conversion"
\& $e = zeroes(3,2,4);           # 3x2x4 zero\-filled array
\& 
\& $c = rfits $file;             # Read FITS file
\& 
\& @x = ( pdl(42), zeroes(3,2,4), rfits($file) ); # Is a LIST of PDL variables!
.Ve
.PP
The \fBpdl()\fR function is used to initialise a \s-1PDL\s0 variable from a scalar,
list, list reference, another \s-1PDL\s0 variable, or a properly formatted string.
.PP
In addition all \s-1PDL\s0 functions automatically convert normal Perl scalars
to \s-1PDL\s0 variables on-the-fly.
.PP
(also see \*(L"Type Conversion\*(R" and \*(L"Input/Output\*(R" sections below)
.SS "Arithmetic (and boolean expressions)"
.IX Subsection "Arithmetic (and boolean expressions)"
.Vb 1
\& $x = $y + 2; $x++; $x = $y / $c; # Etc.
\&
\& $c=sqrt($x); $d = log10($y+100); # Etc
\&
\& $e = $x>42; # Vector conditional
\&
\& $e = 42*($x>42) + $x*($x<=42); # Cap top
\&
\& $y = $x\->log10 unless any ($x <= 0); # avoid floating point error
\&
\& $x = $x / ( max($x) \- min($x) );
\&
\& $f = where($x, $x > 10); # where returns an ndarray of elements for
\&                          # which the condition is true
\&
\& print $x; # $x in string context prints it in a N\-dimensional format
.Ve
.PP
(and other Perl operators/functions)
.PP
When using ndarrays in conditional expressions (i.e. \f(CW\*(C`if\*(C'\fR, \f(CW\*(C`unless\*(C'\fR and
\&\f(CW\*(C`while\*(C'\fR constructs) only ndarrays with exactly one element are allowed, e.g.
.PP
.Vb 2
\& $x = pdl (1,0,0,1);
\& print "is set" if $x\->index(2);
.Ve
.PP
Note that the boolean operators return in general multi-element
ndarrays. Therefore, the following will raise an error
.PP
.Vb 1
\& print "is ok" if $x > 3;
.Ve
.PP
since \f(CW\*(C`$x > 3\*(C'\fR is an ndarray with 4 elements. Rather use 
all or any
to test if all or any of the elements fulfill the condition:
.PP
.Vb 2
\& print "some are > 3" if any $x>3;
\& print "can\*(Aqt take logarithm" unless all $x>0;
.Ve
.PP
There are also many predefined functions, which are described on other
man pages. Check PDL::Index.
.SS "Matrix functions"
.IX Subsection "Matrix functions"
\&\f(CW\*(Aqx\*(Aq\fR is hijacked as the matrix multiplication operator. e.g.
\&\f(CW\*(C`$c = $x x $y\*(C'\fR;
.PP
perlDL is row-major not column major so this is actually
\&\f(CW\*(C`c(i,j) = sum_k x(k,j) y(i,k)\*(C'\fR \- but when matrices are printed the
results will look right. Just remember the indices are reversed.
e.g.:
.PP
.Vb 6
\& $x = [                   $y = [
\&       [ 1  2  3  0]            [1 1]
\&       [ 1 \-1  2  7]            [0 2]
\&       [ 1  0  0  1]            [0 2]
\&      ]                         [1 1]
\&                               ]
\&
\& gives $c = [
\&             [ 1 11]
\&             [ 8 10]
\&             [ 2  2]
\&            ]
.Ve
.PP
Note: \fBtranspose()\fR 
does what it says and is a convenient way
to turn row vectors into column vectors.
.SS "How to write a simple function"
.IX Subsection "How to write a simple function"
.Vb 5
\& sub dotproduct {
\&     my ($x,$y) = @_;
\&     return sum($x*$y) ;
\& }
\& 1;
.Ve
.PP
If put in file dotproduct.pdl would be autoloaded if you
are using PDL::AutoLoader (see below).
.PP
Of course, this function is already available as the 
inner
function, see PDL::Primitive.
.SS "Type Conversion"
.IX Subsection "Type Conversion"
Default for \fBpdl()\fR is double. Conversions are:
.PP
.Vb 3
\& $x = float($y);
\& $c = long($d);   # "long" is generally a 4 byte int
\& $d = byte($x);
.Ve
.PP
Also \fBdouble()\fR, \fBshort()\fR, \fBushort()\fR, \fBindx()\fR.
.PP
.Vb 5
\&  NOTE: The indx() routine is a special integer type that
\&  is the correct size for a PDL index value (dimension size,
\&  index, or offest) which can be either a 32bit (long) or
\&  64bit (longlong) quantity depending on whether the perl
\&  is built with 32bit or 64bit support.
.Ve
.PP
These routines also automatically convert Perl lists to
allow the convenient shorthand:
.PP
.Vb 2
\& $x = byte [[1..10],[1..10]];  # Create 2D byte array
\& $x = float [1..1000];         # Create 1D float array
.Ve
.PP
etc.
.SS "Printing"
.IX Subsection "Printing"
Automatically expands array in N\-dimensional format:
.PP
.Vb 1
\& print $x;
\&
\& $y = "Answer is = $x ";
.Ve
.SS "Sections"
.IX Subsection "Sections"
\&\s-1PDL\s0 has very powerful multidimensional slicing and sectioning
operators; see the \fBPDL::Slices\fR\|(3) man page for details;
we'll describe the most important one here.
.PP
\&\s-1PDL\s0 shows its Perl/C heritage in that arrays are zero-offset.  Thus a
100x100 image has indices \f(CW\*(C`0..99,0..99\*(C'\fR.  (The convention is that the
\&\fIcenter\fR of pixel (0,0) is at coordinate (0.0,0.0). All \s-1PDL\s0 graphics
functions conform to this definition and hide away the unit offsets
of, for example, the \s-1PGPLOT FORTRAN\s0 library.
.PP
Following the usual convention coordinate (0,0) is displayed
at the bottom left when displaying an image. It appears at the
top left when using "\f(CW\*(C`print $x\*(C'\fR" etc.
.PP
Simple sectioning uses a syntax extension to Perl,
PDL::NiceSlice, that allows you to specify subranges
via a null-method modifier to a \s-1PDL:\s0
.PP
.Vb 1
\&  $g = $f\->($x1:$x2,$y1:$y2,($z1)); # Take subsection
.Ve
.PP
Here, \f(CW$f\fR is a 3\-dimensional variable, and \f(CW$g\fR gets a planar
cutout that is defined by the limits \f(CW$x1\fR, \f(CW$x2\fR, \f(CW$y1\fR, \f(CW$y2\fR, at the location
\&\f(CW$z1\fR.  The parenthesis around \f(CW$z1\fR cause the trivial index to be omitted \*(--
otherwise \f(CW$g\fR would be three-dimensional with a third dimension of order 1.
.PP
You can put \s-1PDL\s0 slices on either side of the element-wise assignment 
operator \f(CW\*(C`.=\*(C'\fR, like so:
.PP
.Vb 2
\&  # Set part of $bigimage to values from $smallimage
\&  $bigimage\->($xa:$xb,$ya:$yb) .= $smallimage;
.Ve
.PP
Some other miscellany:
.PP
.Vb 1
\& $c  = nelem($x); # Number of pixels
\&
\& $val = at($object, $x,$y,$z...)    # Pixel value at position, as a Perl scalar
\& $val = $object\->at($x,$y,$z...)    # equivalent (method syntax OK)
\&
\& $y = xvals($x); # Fill array with X\-coord values (also yvals(), zvals(),
\&                 # axisvals($x,$axis) and rvals() for radial distance
\&                 # from centre).
.Ve
.SS "Input/Output"
.IX Subsection "Input/Output"
The \f(CW\*(C`PDL::IO\*(C'\fR modules implement several useful \s-1IO\s0 format functions.
It would be too much to give examples of each, but you can find a nice
overview at \s-1PDL::IO\s0. Here is a sample of some of the
supported \s-1IO\s0 formats in \s-1PDL.\s0
.IP "PDL::IO::Misc" 8
.IX Item "PDL::IO::Misc"
Ascii, \s-1FITS\s0 and \s-1FIGARO/NDF IO\s0 routines.
.IP "PDL::IO::FastRaw" 8
.IX Item "PDL::IO::FastRaw"
Using the raw data types of your machine, an unportable but blindingly
fast \s-1IO\s0 format. Also supports memory mapping to conserve memory as
well as get more speed.
.IP "PDL::IO::FlexRaw" 8
.IX Item "PDL::IO::FlexRaw"
General raw data formats. Like FastRaw, only better.
.IP "PDL::IO::Browser" 8
.IX Item "PDL::IO::Browser"
A Curses browser for arrays.
.IP "PDL::IO::Pnm" 8
.IX Item "PDL::IO::Pnm"
Portaple bitmap and pixmap support.
.IP "PDL::IO::Pic" 8
.IX Item "PDL::IO::Pic"
Using the previous module and netpbm, makes it possible to easily
write \s-1GIF,\s0 jpeg and whatever with simple commands.
.SS "Graphics"
.IX Subsection "Graphics"
The philosophy behind perlDL is to make it work with a variety of
existing graphics libraries since no single package will satisfy all
needs and all people and this allows one to work with packages one
already knows and likes.  Obviously there will be some overlaps in
functionality and some lack of consistency and uniformity. However
this allows \s-1PDL\s0 to keep up with a rapidly developing field \- the
latest \s-1PDL\s0 modules provide interfaces to OpenGL and \s-1VRML\s0 graphics!
.IP "PDL::Graphics::PGPLOT" 4
.IX Item "PDL::Graphics::PGPLOT"
\&\s-1PGPLOT\s0 provides a simple library for line graphics and image display.
.Sp
There is an easy interface to this in the internal module
PDL::Graphics::PGPLOT, which
calls routines in the separately available
\&\s-1PGPLOT\s0 top-level module.
.IP "PDL::Graphics::PLplot" 4
.IX Item "PDL::Graphics::PLplot"
PLplot provides a simple library for creating graphics with multiple
output drivers, including a direct-to-ndarray driver.
.Sp
This module provides both high-level and low-level functionality built
on PLplot. The low-level commands are pretty much direct bindings to
PLplot's C interface. Read more at PDL::Graphics::PLplot.
.IP "PDL::Graphics::IIS" 4
.IX Item "PDL::Graphics::IIS"
Many astronomers like to use SAOimage and Ximtool (or there
derivations/clones). These are useful free widgets for inspection and
visualisation of images. (They are not provided with perlDL but can
easily be obtained from their official sites off the Net.)
.Sp
The PDL::Graphics::IIS 
package provides allows one to display images
in these (\*(L"\s-1IIS\*(R"\s0 is the name of an ancient item of image display
hardware whose protocols these tools conform to.)
.IP "PDL::Graphics::TriD" 4
.IX Item "PDL::Graphics::TriD"
See PDL::Graphics::TriD, this is a collection
of 3D routines for OpenGL and (soon) \s-1VRML\s0 and other 3D formats which
allow 3D point, line, and surface plots from \s-1PDL.\s0
.SS "Autoloading"
.IX Subsection "Autoloading"
See PDL::AutoLoader. This allows one to autoload functions
on demand, in a way perhaps familiar to users of MatLab.
.PP
One can also write \s-1PDL\s0 extensions as normal Perl modules.
.SS "\s-1PDL\s0 shells"
.IX Subsection "PDL shells"
The Perl script \f(CW\*(C`pdl2\*(C'\fR (or \f(CW\*(C`perldl\*(C'\fR) provides a simple command line interface
to \s-1PDL.\s0  If the latest Readlines/ReadKey modules have been installed \f(CW\*(C`pdl2\*(C'\fR
detects this and enables command line recall and editing.
See the man page for details.
.PP
e.g.:
.PP
.Vb 10
\& % perldl
\& perlDL shell v1.354
\&  PDL comes with ABSOLUTELY NO WARRANTY. For details, see the file
\&  \*(AqCOPYING\*(Aq in the PDL distribution. This is free software and you
\&  are welcome to redistribute it under certain conditions, see
\&  the same file for details.
\& ReadLines, NiceSlice, MultiLines  enabled
\& Reading PDL/default.perldlrc...
\& Found docs database /home/pdl/dev/lib/perl5/site_perl/PDL/pdldoc.db
\& Type \*(Aqhelp\*(Aq for online help
\& Type \*(Aqdemo\*(Aq for online demos
\& Loaded PDL v2.4.9_003 (supports bad values)
\& pdl> $x = rfits \*(Aqm51.fits\*(Aq
\& Reading IMAGE data...
\& BITPIX =  32  size = 147456 pixels 
\& Reading  589824  bytes
\& BSCALE =  &&  BZERO = 
\&
\& pdl> use PDL::Graphics::PGPLOT;
\& pdl> imag $x
\& Displaying 384 x 384 image from 40 to 761, using 84 colors (16\-99)...
.Ve
.PP
You can also run it from the Perl debugger (\f(CW\*(C`perl \-MPDL \-d \-e 1\*(C'\fR)
if you want.
.PP
Miscellaneous shell features:
.IP "p" 4
.IX Item "p"
The shell aliases \f(CW\*(C`p\*(C'\fR to be a convenient short form of \f(CW\*(C`print\*(C'\fR, e.g.
.Sp
.Vb 6
\&   pdl> p ones 5,3
\&   [
\&    [1 1 1 1 1]
\&    [1 1 1 1 1]
\&    [1 1 1 1 1]
\&   ]
.Ve
.IP "Initialization" 4
.IX Item "Initialization"
The files \f(CW\*(C`~/.perldlrc\*(C'\fR and \f(CW\*(C`local.perldlrc\*(C'\fR (in the current
directory) are sourced if found. This allows the user to have global
and local \s-1PDL\s0 code for startup.
.IP "Help" 4
.IX Item "Help"
Type 'help'! One can search the \s-1PDL\s0 documentation, and look up documentation
on any function.
.IP "Escape" 4
.IX Item "Escape"
Any line starting with the \f(CW\*(C`#\*(C'\fR character is treated as a shell
escape. This character is configurable by setting the Perl variable
\&\f(CW$PERLDL_ESCAPE\fR. This could, for example, be set in \f(CW\*(C`~/.perldlrc\*(C'\fR.
.SS "Overload operators"
.IX Subsection "Overload operators"
The following builtin Perl operators and functions have been overloaded
to work on \s-1PDL\s0 variables:
.PP
.Vb 2
\& + \- * / > < >= <= << >> & | ^ == != <=> ** % ! ~
\& sin log abs atan2 sqrt cos exp
.Ve
.PP
[All the unary functions (sin etc.) may be used with \fBinplace()\fR \- see
\&\*(L"Memory\*(R" below.]
.SS "Object-Orientation and perlDL"
.IX Subsection "Object-Orientation and perlDL"
\&\s-1PDL\s0 operations are available as functions and methods.
Thus one can derive new types of object, to represent
custom data classes.
.PP
By using overloading one can make mathematical operators
do whatever you please, and \s-1PDL\s0 has some built-in tricks
which allow existing \s-1PDL\s0 functions to work unchanged, even
if the underlying data representation is vastly changed!
See PDL::Objects
.SS "Memory usage and references"
.IX Subsection "Memory usage and references"
Messing around with really huge data arrays may require some care.
perlDL provides many facilities to let you perform operations on big
arrays without generating extra copies though this does require a bit
more thought and care from the programmer.
.PP
\&\s-1NOTE:\s0 On some most systems it is better to configure Perl (during the
build options) to use the system \f(CW\*(C`malloc()\*(C'\fR function rather than Perl's
built-in one. This is because Perl's one is optimised for speed rather
than consumption of virtual memory \- this can result in a factor of
two improvement in the amount of memory storage you can use.
The Perl malloc in 5.004 and later does have a number of compile-time
options you can use to tune the behaviour.
.IP "Simple arithmetic" 4
.IX Item "Simple arithmetic"
If \f(CW$x\fR is a big image (e.g. occupying 10MB) then the command
.Sp
.Vb 1
\& $x = $x + 1;
.Ve
.Sp
eats up another 10MB of memory. This is because
the expression \f(CW\*(C`$x+1\*(C'\fR creates a temporary copy of \f(CW$x\fR to hold the
result, then \f(CW$x\fR is assigned a reference to that.
After this, the original \f(CW$x\fR is destroyed so there is no \fIpermanent\fR
memory waste. But on a small machine, the growth in the memory footprint
can be considerable.
It is obviously done
this way so \f(CW\*(C`$c=$x+1\*(C'\fR works as expected.
.Sp
Also if one says:
.Sp
.Vb 2
\& $y = $x;     # $y and $x now point to same data
\& $x = $x + 1;
.Ve
.Sp
Then \f(CW$y\fR and \f(CW$x\fR end up being different, as one naively expects,
because a new reference is created and \f(CW$x\fR is assigned to it.
.Sp
However if \f(CW$x\fR was a huge memory hog (e.g. a 3D volume) creating a copy
of it may not be a good thing. One can avoid this memory overhead in
the above example by saying:
.Sp
.Vb 1
\& $x++;
.Ve
.Sp
The operations \f(CW\*(C`++,+=,\-\-,\-=\*(C'\fR, etc. all call a special \*(L"in-place\*(R"
version of the arithmetic subroutine. This means no more memory is
needed \- the downside of this is that if \f(CW\*(C`$y=$x\*(C'\fR then \f(CW$y\fR is also
incremented. To force a copy explicitly:
.Sp
.Vb 1
\& $y = pdl $x; # Real copy
.Ve
.Sp
or, alternatively, perhaps better style:
.Sp
.Vb 1
\& $y = $x\->copy;
.Ve
.IP "Functions" 4
.IX Item "Functions"
Most functions, e.g. \f(CW\*(C`log()\*(C'\fR, return a result which is a transformation
of their argument. This makes for good programming practice. However many
operations can be done \*(L"in-place\*(R" and this may be required when large
arrays are in use and memory is at a premium. For these circumstances
the operator \fBinplace()\fR 
is provided which prevents the extra copy and
allows the argument to be modified. e.g.:
.Sp
.Vb 2
\& $x = log($array);          # $array unaffected
\& log( inplace($bigarray) ); # $bigarray changed in situ
.Ve
.Sp
\&\s-1WARNINGS:\s0
.RS 4
.IP "1." 4
The usual caveats about duplicate references apply.
.IP "2." 4
Obviously when used with some functions which can not be applied
in situ (e.g. \f(CW\*(C`convolve()\*(C'\fR) unexpected effects may occur! We try to
indicate \f(CW\*(C`inplace()\*(C'\fR\-safe functions in the documentation.
.IP "3." 4
Type conversions, such as\f(CW\*(C`float()\*(C'\fR, may cause hidden copying.
.RE
.RS 4
.RE
.SS "Ensuring ndarrayness"
.IX Subsection "Ensuring ndarrayness"
If you have written a simple function and
you don't want it to blow up in your face if you pass it a simple
number rather than a \s-1PDL\s0 variable. Simply call the function
\&\fBtopdl()\fR first to make it safe. e.g.:
.PP
.Vb 1
\& sub myfiddle { my $pdl = topdl(shift); $pdl\->fiddle_foo(...); ... }
.Ve
.PP
\&\f(CW\*(C`topdl()\*(C'\fR does \s-1NOT\s0 perform a copy if a pdl variable is passed \- it
just falls through \- which is obviously the desired behaviour. The
routine is not of course necessary in normal user defined functions
which do not care about internals.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) Karl Glazebrook (kgb@aaoepp.aao.gov.au), Tuomas J. Lukka,
(lukka@husc.harvard.edu) and Christian Soeller (c.soeller@auckland.ac.nz) 1997.
All rights reserved. There is no warranty. You are allowed to copy this
on the same terms as Perl itself.
