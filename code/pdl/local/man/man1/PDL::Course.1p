.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "COURSE 1"
.TH COURSE 1 "2022-02-14" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PDL::Course \- A journey through PDL's documentation, from beginner to advanced.
.SH "AUTHOR, DATE"
.IX Header "AUTHOR, DATE"
This is written by David Mertens with edits by Daniel Carrera.
.SH "Preface"
.IX Header "Preface"
\&\s-1PDL\s0's documentation is extensive. Some sections cover deep core magic
while others cover more usual topics like \s-1IO\s0 and numerical computation.
How are these related? Where should you begin?
.PP
This document is an attempt to pull all the key \s-1PDL\s0 documentation
together in a coherent study course, starting from the beginner level,
up to the expert.
.PP
I've broken down everything by level of expertise, and within expertise
I've covered documentation, library, and workflow modules. The
documentation modules are useful for what they tell you; the library
modules are useful for the functions that they define for you; the
workflow modules are useful for the way that they allow you to get your
work done in new and different ways.
.SH "Introductory"
.IX Header "Introductory"
If you are new to \s-1PDL,\s0 these documentation modules will get
you started down the right path for using \s-1PDL.\s0
.SS "Documentation"
.IX Subsection "Documentation"
Modules that tell you how to start using \s-1PDL.\s0  Many of these
are library modules technically, but they are included when
you \f(CW\*(C`use PDL\*(C'\fR, so I've included them for their documentation.
.PP
After the first three, most of the docs listed below are rather
dry. Perhaps they would be better summarized by tables or better
synopses. You should at least scan through them to
familiarize yourself with the basic capabilities of \s-1PDL.\s0
.IP "\(bu" 4
PDL::Philosophy, PDL::QuickStart
.Sp
A couple of brief introductions to \s-1PDL.\s0 The second one is a bit more
hands-on. If you are new to \s-1PDL,\s0 you should start with these.
.IP "\(bu" 4
PDL::Basic
.Sp
Covers basic ndarray-creation routines like \f(CW\*(C`sequence\*(C'\fR,
\&\f(CW\*(C`rvals\*(C'\fR, and \f(CW\*(C`logxvals\*(C'\fR to name a random few.  Also covers
\&\f(CW\*(C`hist\*(C'\fR and \f(CW\*(C`transpose\*(C'\fR.
.IP "\(bu" 4
PDL::Ufunc
.Sp
Explains a large collection of built-in functions which, given an
N\-dimension ndarray, will create an ndarray with N\-1 dimensions.
.IP "\(bu" 4
PDL::NiceSlice
.Sp
\&\s-1PDL\s0 came of age right around the turn of the millennium and
NiceSlice came on the scene slightly after that.  Some of
the docs still haven't caught up.  NiceSlice is the 'modern'
way to slice and dice your ndarrays.  Read the Synopsis, then
scroll down to The New Slicing Syntax.  After you've read to
the bottom, return to and read the stuff at the top.
.IP "\(bu" 4
PDL::Primitive
.Sp
Defines a whole slew of useful built-in functions.  These
are the sorts of things that beginners are likely to write to
the list and say, \*(L"How do I do xxx?\*(R"  You would be well
on your way to learning the ropes after you've gotten through
this document.
.IP "\(bu" 4
Selections from PDL::Core
.Sp
Like PDL::Primitive, defines a large set of useful functions.
Unfortunately, some of the functions are quite esoteric, but
are mixed in with the rest of the simple and easy ones.  Skim
the whole document, skipping over the complicated functions
for now.  I would point out in particular the function
\&\f(CW\*(C`approx\*(C'\fR.
.SS "Workflow"
.IX Subsection "Workflow"
.IP "\(bu" 4
The perldl or pdl2 Shell
.Sp
The Perldl Shell is a \s-1REPL\s0 (Read-Evaluate-Print-Loop, in other words,
a prompt or shell) that allows you to work with \s-1PDL\s0 (or any Perl, for
that matter) in 'real time', loading data from files, plotting,
manipulating... Anything you can do in a script, you can do in the \s-1PDL\s0
Shell, with instant feedback!
.SS "Libraries"
.IX Subsection "Libraries"
.IP "\(bu" 4
\&\s-1PDL\s0
.Sp
The main workhorse module. You'll include this in nearly every \s-1PDL\s0
program you write.
.SH "Normal Usage"
.IX Header "Normal Usage"
The sorts of modules that you'll likely use on a normal basis in scripts
or from within the perldl shell.  Some of these modules you may never
use, but you should still be aware that they exist, just in case you
need their functionality.
.SS "Documentation"
.IX Subsection "Documentation"
.IP "\(bu" 4
PDL::Slices
.Sp
In addition to explaining the original slicing and dicing functions \-
for which you can usually use PDL::NiceSlice \- this also covers
many dimension-handling functions such as \f(CW\*(C`mv\*(C'\fR, \f(CW\*(C`xchg\*(C'\fR, and
\&\f(CW\*(C`reorder\*(C'\fR.  This also thoroughly documents the \f(CW\*(C`range\*(C'\fR function, which
can be very powerful, and covers a number of internal functions, which
can probably be skipped.
.IP "\(bu" 4
PDL::Indexing
.Sp
This covers a lot of the deeper conceptual ground that you'll
need to grasp to really use \s-1PDL\s0 to its full potential.  It gets
more complex as you go along, so don't be troubled if you find
yourself loosing interest half way through.  However, reading
this document all the way through will bring you much closer to
\&\s-1PDL\s0 enlightenment.
.IP "\(bu" 4
\&\s-1PDL::IO\s0
.Sp
\&\s-1PDL\s0 has quite a few \s-1IO\s0 modules, most of which are discussed
in this summary module.
.IP "\(bu" 4
PDL::Tips
.Sp
A collection of some of Tuomas's ideas for making good use of \s-1PDL.\s0
.IP "\(bu" 4
PDL::BadValues
.Sp
Explains what bad values are and how and why they are implemented.
.IP "\(bu" 4
Selections from Inline::Pdlpp
.Sp
Although writing \s-1PDL::PP\s0 code is considered an Advanced topic, and is
covered in the next section, you should be aware that it is possible 
(and surprisingly simple) to write PDL-aware code.  You needn't read
the whole thing at this point, but to get some feel for how it works,
you should read everything up through the first example.  A copy of this
documentation is contained in PDL::PP\-Inline.
.IP "\(bu" 4
PDL::Objects
.Sp
Explains how to subclass an ndarray object.
.IP "\(bu" 4
PDL::Index
.Sp
This was discussed in the Preface. It is an automatically generated
file that lists all of the \s-1PDL\s0 modules on your computer. There are many
modules that may be on your machine but which are not documented here,
such as bindings to the \s-1FFTW\s0 library, or \s-1GSL.\s0 Give it a read!
.SS "Libraries"
.IX Subsection "Libraries"
.IP "\(bu" 4
\&\s-1PDL::FFT\s0
.Sp
\&\s-1PDL\s0's own Fast Fourier Transform.  If you have \s-1FFTW,\s0 then you
should probably make use of it; this is \s-1PDL\s0's internal
implementation and should always be available.
.IP "\(bu" 4
\&\s-1GSL\s0
.Sp
\&\s-1PDL\s0 does not have bindings for every sub-library in the \s-1GNU\s0 Scientific
Library, but it has quite a few. If you have \s-1GSL\s0 installed on your
machine then chances are decent that your \s-1PDL\s0 has the \s-1GSL\s0 bindings.
For a full list of the \s-1GSL\s0 bindings, check PDL::Index.
.IP "\(bu" 4
PDL::Func
.Sp
A somewhat uniform interface to the different interpolation modules in \s-1PDL.\s0
.IP "\(bu" 4
PDL::Bad
.Sp
Includes some basic bad-value functionality, including functions
to query if an ndarray has bad values (\f(CW\*(C`isbad\*(C'\fR) and functions to
set certain elements as bad (\f(CW\*(C`setbadat\*(C'\fR and \f(CW\*(C`setbadif\*(C'\fR).  Among
other places, bad values are used in PDL::Graphics::PLplot's
xyplot to make a gap in a line plot.
.IP "\(bu" 4
PDL::DiskCache
.Sp
A cool module that allows you to tie a Perl array to a collection of
files on your disk, which will be loaded into and out of memory as
ndarrays. If you find yourself writing scripts to process many data files,
especially if that data processing is not necessarily in sequential
order, you should consider using PDL::DiskCache.
.IP "\(bu" 4
PDL::Char
.Sp
A \s-1PDL\s0 subclass that allows you to store and manipulate collections
of fixed-length character strings using \s-1PDL.\s0
.IP "\(bu" 4
PDL::Image2D
.Sp
A whole collection of methods for manipulating images whose image data
are stored in an ndarray.  These include methods for convolutions
(smoothing), polygon fills, scaling, rotation, and warping, among
others.
.IP "\(bu" 4
PDL::ImageND
.Sp
Contains a few functions that are conceptually related to image
processing, but which can be defined for higher-dimensional data.  For
examples this module defines high-dimensional convolution and
interpolation, among others.
.IP "\(bu" 4
PDL::ImageRGB
.Sp
Defines some useful functions for working with \s-1RBG\s0 image data.  It's
not very feature-full, but it may have something you need, and if not,
you can always add more!
.IP "\(bu" 4
PDL::Transform
.Sp
Creates the transform class, which allows you to create various
coordinate transforms.  For example, if you data is a collection of
Cartesian coordinates, you could create a transform object to convert
them to Spherical-Polar coordinates (although many such standard
coordinate transformations are predefined for you, in this case it's
called \f(CW\*(C`t_spherical\*(C'\fR).
.IP "\(bu" 4
PDL::Opt::Simplex
.Sp
This package states that it \*(L"implements the commonly used simplex
optimization algorithm.\*(R" I'm going to assume that if you need this
algorithm then you already know what it is.
.IP "\(bu" 4
PDL::Math
.Sp
A collection of fairly standard math functions, like the inverse 
trigonometric functions, hyperbolic functions and their inverses, and
others.  This module is included in the standard call to \f(CW\*(C`use PDL\*(C'\fR, but
not in the Lite versions.
.IP "\(bu" 4
PDL::Matrix
.Sp
Provides a few functions that use the standard mathematical Matrix
notation of row-column indexing rather than the PDL-standard column-row.
It appears that this module has not been heavily tested with other
modules, so although it should work with other modules, don't be
surprised if something breaks when you use it (and feel free to offer
any fixes that you may develop).
.IP "\(bu" 4
PDL::MatrixOps
.Sp
Provides many standard matrix operations for ndarrays, such as computing
eigenvalues, inverting square matrices, LU-decomposition, and solving
a system of linear equations.  Though it is not built on PDL::Matrix,
it should generally work with that module.  Also, the methods
provided by this module do not depend on external libraries such as
Slatec or \s-1GSL.\s0
.IP "\(bu" 4
PDL::Reduce
.Sp
Implements an interface to all the functions that return ndarrays with
one less dimension (for example, \f(CW\*(C`sumover\*(C'\fR), such that they can be
called by supplying their name, as a string.
.SS "Workflow"
.IX Subsection "Workflow"
.IP "\(bu" 4
PDL::AutoLoader
.Sp
Enables Matlab-style autoloading.  When you call an unknown
function, instead of complaining and croaking, \s-1PDL\s0 will go hunt
around in the directories you specify in search of a like-named
file.  Particularly useful when used with the Perldl Shell.
.IP "\(bu" 4
PDL::Dbg
.Sp
Declares the \f(CW\*(C`px\*(C'\fR function, which can be handy for debugging your
\&\s-1PDL\s0 scripts and/or perldl shell commands.
.IP "\(bu" 4
PDL::Options
.Sp
Suppose you define a powerful, versatile function.  Chances are good
that you'll accept the arguments in the form of a hash or hashref.  Now
you face the problem of processing that hashref.  PDL::Options
assists you in writing code to process those options.  (You'd think
Perl would have tons of these sorts of modules lying around, but I
couldn't find any.)  Note this module does not depend on \s-1PDL\s0 for its
usage or installation.
.IP "\(bu" 4
PDL::pdldoc
.Sp
Ever fired-up the perldl shell just to look up the help for a particular
function?  You can use \f(CW\*(C`pdldoc\*(C'\fR instead.  This shell script extracts
information from the help index without needing to start the perldl
shell.
.SH "Advanced Usage"
.IX Header "Advanced Usage"
The sorts of modules and documentation that you'll use if you write
modules that use \s-1PDL,\s0 or if you work on \s-1PDL\s0 maintenance.  These modules
can be difficult to use, but enable you to tackle some of your harder
problems.
.IP "\(bu" 4
PDL::Lite, PDL::LiteF
.Sp
Lite-weight replacements for \f(CW\*(C`use PDL\*(C'\fR, from the standpoint of
namespace pollution and load time.
.IP "\(bu" 4
Inline::Pdlpp
.Sp
This was mentioned earlier.  Before you begin reading about \s-1PDL::PP\s0
(next), you should remind yourself about how to use this.
Inline::Pdlpp will help you experiment with \s-1PDL::PP\s0 without having
to go through the trouble of building a module and constructing
makefiles (but see PDL::pptemplate for help on that).
.IP "\(bu" 4
\&\s-1PDL::PP\s0
.Sp
The \s-1PDL\s0 Pre-Processor, which vastly simplifies making you
C or Fortran code play with Perl and ndarrays.  Most of \s-1PDL\s0's
basic functionality is written using \s-1PDL::PP,\s0 so if you're
thinking about how you might integrate some numerical
library written in C, look no further.
.IP "\(bu" 4
PDL::pptemplate
.Sp
A script that automates the creation of modules that use \s-1PDL::PP\s0,
which should make your life as a module author a bit simpler.
.IP "\(bu" 4
PDL::CallExt
.Sp
Allows you to call functions using external shared
libraries.  This is an alternative to using \s-1PDL::PP\s0.
The major difference between \s-1PDL::PP\s0 and PDL::CallExt is
that the former will handle broadcasting over implicit broadcast
dimensions for you, whereas PDL::CallExt simply calls an
external function.  \s-1PDL::PP\s0 is generally the recommended
way to interface your code with \s-1PDL,\s0 but it wouldn't be Perl
if there wasn't another way to do it.
.IP "\(bu" 4
PDL::Config
.Sp
Defines the \f(CW%PDL::Config\fR hash, which has lots of useful
information pertinent to your \s-1PDL\s0 build.
.IP "\(bu" 4
PDL::Doc
.Sp
Explanation of the \s-1PDL\s0 documentation conventions, and an
interface to the \s-1PDL\s0 Documentation parser.  Following these
guidelines when writing documentation for \s-1PDL\s0 functions will
ensure that your wonderful documentation is accessible from
the perldl shell and from calls to \f(CW\*(C`barf\*(C'\fR.  (Did you notice
that \f(CW\*(C`barf\*(C'\fR used your documentation?  Time to reread
PDL::Core...)
.IP "\(bu" 4
PDL::Exporter
.Sp
A simple replacement for the standard Exporter module.
The only major difference is that the default imported modules
are those marked ':Func'.
.IP "\(bu" 4
PDL::Types
.Sp
Defines some useful functions for getting an ndarray's type, as well as
getting information about that type.
.SH "Expert Usage"
.IX Header "Expert Usage"
.IP "\(bu" 4
PDL::Core::Dev
.Sp
Provides some decently useful functions that are pretty
much only needed by the \s-1PDL\s0 Porters.
.IP "\(bu" 4
\&\s-1PDL::API\s0
.Sp
Explains how to make an ndarray \fIby hand\fR, from Perl or your
C source code, using the \s-1PDL API.\s0
.IP "\(bu" 4
PDL::Internals
.Sp
Explains the nitty-gritty of the \s-1PDL\s0 data structures.  After reading
this (a few times :), you should be able to create an ndarray completely
from scratch (i.e. without using the \s-1PDL API\s0).  Put a little
differently, if you want to understand how \s-1PDL::PP\s0 works, you'll need
to read this.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2010 David Mertens (dcmertens.perl@gmail.com). You can
distribute and/or modify this document under the same terms as the
current Perl license.
.PP
See: http://dev.perl.org/licenses/
