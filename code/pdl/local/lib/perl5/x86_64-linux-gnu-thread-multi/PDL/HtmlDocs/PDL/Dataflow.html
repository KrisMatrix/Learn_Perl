<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::Dataflow -- description of the dataflow implementation and philosophy</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#TWO-WAY">TWO-WAY</a>
    <ul>
      <li><a href="#Type-conversions">Type conversions</a></li>
    </ul>
  </li>
  <li><a href="#ONE-WAY">ONE-WAY</a></li>
  <li><a href="#LAZY-EVALUATION">LAZY EVALUATION</a></li>
  <li><a href="#FAMILIES">FAMILIES</a></li>
  <li><a href="#EVENTS">EVENTS</a></li>
  <li><a href="#TRANSFORMATIONS">TRANSFORMATIONS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Dataflow -- description of the dataflow implementation and philosophy</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>        pdl&gt; $x = zeroes(10);
        pdl&gt; $y = $x-&gt;slice(&quot;2:4:2&quot;);
        pdl&gt; $y ++;
        pdl&gt; print $x;
        [0 0 1 0 1 0 0 0 0 0]</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>As of 2.079, this is now a description of the current implementation, together with some design thoughts from its original author, Tuomas Lukka.</p>

<p>Two-directional dataflow (which implements <code>-&gt;slice()</code> etc.) is fully functional, as shown in the SYNOPSIS. One-way is implemented, but with restrictions.</p>

<h1 id="TWO-WAY">TWO-WAY</h1>

<p>Just about any function which returns some subset of the values in some ndarray will make a binding. <code>$y</code> has become effectively a window to some sub-elements of <code>$x</code>. You can also define your own routines that do different types of subsets. If you don&#39;t want <code>$y</code> to be a window to <code>$x</code>, you must do</p>

<pre><code>        $y = $x-&gt;slice(&quot;some parts&quot;)-&gt;sever;</code></pre>

<p>The <code>sever</code> destroys the <code>slice</code> transform, thereby turning off all dataflow between the two ndarrays.</p>

<h2 id="Type-conversions">Type conversions</h2>

<p>This works, thanks to a two-way flowing transform that implements type-conversions, particularly for supplied outputs of the &quot;wrong&quot; type for the given transform:</p>

<pre><code>  pdl&gt; $a_bad = pdl double, &#39;[1 BAD 3]&#39;;
  pdl&gt; $b_float = zeroes float, 3;
  pdl&gt; $a_bad-&gt;assgn($b_float); # could be written as $b_float .= $a_bad
  pdl&gt; p $b_float-&gt;badflag;
  1
  pdl&gt; p $b_float;
  [1 BAD 3]</code></pre>

<h1 id="ONE-WAY">ONE-WAY</h1>

<p>You need to explicitly turn on one-way dataflow on an ndarray to activate it for non-flowing operations, so</p>

<pre><code>        pdl&gt; $x = pdl 2,3,4;
        pdl&gt; $x-&gt;doflow;
        pdl&gt; $y = $x * 2;
        pdl&gt; print $y;
        [4 6 8]
        pdl&gt; $x-&gt;set(0,5);
        pdl&gt; print $y;
        [10 6 8]</code></pre>

<p>It is not possible to turn on backwards dataflow (such as is used by <code>slice</code>-type operations), because there is no general way for PDL (or maths, in fact) to know how to reverse most operations - consider <code>$z = $x * $y</code>, then adding one to <code>$z</code>.</p>

<p>Consider the following code:</p>

<pre><code>        $u = sequence(3,3); $u-&gt;doflow;
        $v = ones(3,3); $v-&gt;doflow;
        $w = $u + $v; $w-&gt;doflow; # must turn on for each
        $y = $w + 1; $y-&gt;doflow;
        $x = $w-&gt;diagonal(0,1);
        $x += 50;
        $z = $w + 2;</code></pre>

<p>What do $y and $z contain now?</p>

<pre><code>        pdl&gt; p $y
        [
         [52  3  4]
         [ 5 56  7]
         [ 8  9 60]
        ]
        pdl&gt; p $z
        [
         [53  4  5]
         [ 6 57  8]
         [ 9 10 61]
        ]</code></pre>

<p>What about when $u is changed and a recalculation is triggered? A problem arises, in that PDL currently (as of 2.079) disallows (see <i>pdlapi.c</i>), for normal transforms, output ndarrays with flow, or output ndarrays with any parent with dataflow. So <code>$u++</code> throws an exception. But it is currently possible to use <code>set</code>, which is a sort of micro-transform that calls (in the C API) <code>PDL.set</code> to mutate the data, then <code>PDL.changed</code> to trigger flow updates:</p>

<pre><code>        pdl&gt; $u-&gt;set(1,1,90)
        pdl&gt; p $y
        [
         [ 2  3  4]
         [ 5 92  7]
         [ 8  9 10]
        ]</code></pre>

<p>You&#39;ll notice that while the setting of <code>1,1</code> (the middle) of $u updated $y, the changes to $y that resulted from adding 50 to the diagonal (via $x, and two-way flow) got lost. This is one-way flow.</p>

<h1 id="LAZY-EVALUATION">LAZY EVALUATION</h1>

<p>In one-way flow context like the above, with:</p>

<pre><code>        pdl&gt; $y = $x * 2;</code></pre>

<p>nothing will have been calculated at this point. Even the memory for the contents of $y has not been allocated. Only the command</p>

<pre><code>        pdl&gt; print $y</code></pre>

<p>will actually cause $y to be calculated. This is important to bear in mind when doing performance measurements and benchmarks as well as when tracking errors.</p>

<p>There is an explanation for this behaviour: it may save cycles but more importantly, imagine the following:</p>

<pre><code>        pdl&gt; $x = pdl 2,3,4; $x-&gt;doflow;
        pdl&gt; $y = pdl 5,6,7; $y-&gt;doflow;
        pdl&gt; $c = $x + $y;
        pdl&gt; $x-&gt;setdims([4]);
        pdl&gt; $y-&gt;setdims([4]);
        pdl&gt; print $c;</code></pre>

<p>Now, if $c were evaluated between the two resizes, an error condition of incompatible sizes would occur.</p>

<p>What happens in the current version is that resizing $x raises a flag in $c: &quot;PDL_PARENTDIMSCHANGED&quot; and $y just raises the same flag again. When $c is next evaluated, the flags are checked and it is found that a recalculation is needed.</p>

<p>Of course, lazy evaluation can sometimes make debugging more painful because errors may occur somewhere where you&#39;d not expect them.</p>

<h1 id="FAMILIES">FAMILIES</h1>

<p>This is one of the more intricate concepts of dataflow. In order to make dataflow work like you&#39;d expect, a rather strange concept must be introduced: families. Let us make a diagram of the one-way flow example - it uses a hypergraph because the transforms (with <code>+</code>) are connectors between ndarrays (with <code>*</code>):</p>

<pre><code>       u*   *v
         \ /
          +(plus)
          |
   1*     *w
     \   /|\
      \ / | \
 (plus)+  |  +(diagonal)
       |  |  |
      y*  |  *x
          |
          | *1
          |/
          +(plus)
          |
         z*</code></pre>

<p>This is what PDL actually has in memory after the first three lines. When $x is changed, $w changes due to <code>diagonal</code> being a two-way operation.</p>

<p>If you want flow from $w, you opt in using <code>$w-&gt;doflow</code> (as shown in this scenario). If you didn&#39;t, then don&#39;t enable it. If you have it but want to stop it, call <code>$ndarray-&gt;sever</code>. That will destroy the ndarray&#39;s <code>trans_parent</code> (here, a node marked with <code>+</code>), and as you can visually tell, will stop changes flowing thereafter. If you want to leave the flow operating, but get a copy of the ndarray at that point, use <code>$ndarray-&gt;copy</code> - it will have the same data at that moment, but have no flow relationships.</p>

<h1 id="EVENTS">EVENTS</h1>

<p>There is the start of a mechanism to bind events onto changed data, intended to allow this to work:</p>

<pre><code>        pdl&gt; $x = pdl 2,3,4
        pdl&gt; $y = $x + 1;
        pdl&gt; $c = $y * 2;
        pdl&gt; $c-&gt;bind( sub { print &quot;A now: $x, C now: $c\n&quot; } )
        pdl&gt; PDL::dowhenidle();
        A now: [2,3,4], C now: [6 8 10]
        pdl&gt; $x-&gt;set(0,1);
        pdl&gt; $x-&gt;set(1,1);
        pdl&gt; PDL::dowhenidle();
        A now: [1,1,4], C now: [4 4 10]</code></pre>

<p>This hooks into PDL&#39;s <code>magic</code> which resembles Perl&#39;s, but does not currently operate.</p>

<p>There would be many kinds of uses for this feature: self-updating charts, for instance. It is not yet fully clear whether it would be most useful to queue up changes (useful for doing asynchronously, e.g. when idle), or to activate things immediately.</p>

<p>In the 2022 era of both GPUs and multiple cores, it is a pity that Perl&#39;s dominant model remains single-threaded on CPU, but PDL can use multi-cores for CPU processing (albeit controlled in a single-threaded style) - see <a href="./ParallelCPU.html">PDL::ParallelCPU</a>. It is planned that PDL will gain the ability to use GPUs, and there might be a way to hook that up albeit probably with an event loop to &quot;subscribe&quot; to GPU events.</p>

<h1 id="TRANSFORMATIONS">TRANSFORMATIONS</h1>

<p>PDL implements nearly everything (except for XS oddities like <code>set</code>) using transforms which connect ndarrays. This includes data transformations like addition, &quot;slicing&quot; to access/operate on subsets, and data-type conversions (which have two-way dataflow, see <a href="#Type-conversions">&quot;Type conversions&quot;</a>).</p>

<p>This does not currently include a resizing transformation, and <code>setdims</code> mutates its input. This is intended to change.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright(C) 1997 Tuomas J. Lukka (lukka@fas.harvard.edu). Same terms as the rest of PDL.</p>


</body>

</html>


