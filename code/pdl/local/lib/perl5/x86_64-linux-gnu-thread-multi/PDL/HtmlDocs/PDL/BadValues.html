<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::BadValues - Discussion of bad value support in PDL</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#What-are-bad-values-and-why-should-I-bother-with-them">What are bad values and why should I bother with them?</a></li>
      <li><a href="#A-quick-overview">A quick overview</a></li>
      <li><a href="#Bad-values-and-boolean-operators">Bad values and boolean operators</a></li>
    </ul>
  </li>
  <li><a href="#IMPLEMENTATION-DETAILS">IMPLEMENTATION DETAILS</a>
    <ul>
      <li><a href="#Default-bad-values">Default bad values</a></li>
      <li><a href="#How-do-I-change-a-routine-to-handle-bad-values">How do I change a routine to handle bad values?</a></li>
    </ul>
  </li>
  <li><a href="#WHAT-ABOUT-DOCUMENTATION">WHAT ABOUT DOCUMENTATION?</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::BadValues - Discussion of bad value support in PDL</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<h2 id="What-are-bad-values-and-why-should-I-bother-with-them">What are bad values and why should I bother with them?</h2>

<p>Sometimes it&#39;s useful to be able to specify a certain value is &#39;bad&#39; or &#39;missing&#39;; for example CCDs used in astronomy produce 2D images which are not perfect since certain areas contain invalid data due to imperfections in the detector. Whilst PDL&#39;s powerful index routines and all the complicated business with dataflow, slices, etc etc mean that these regions can be ignored in processing, it&#39;s awkward to do. It would be much easier to be able to say <code>$c = $x + $y</code> and leave all the hassle to the computer.</p>

<p>If you&#39;re not interested in this, then you may (rightly) be concerned with how this affects the speed of PDL, since the overhead of checking for a bad value at each operation can be large. Because of this, the code has been written to be as fast as possible - particularly when operating on ndarrays which do not contain bad values. In fact, you should notice essentially no speed difference when working with ndarrays which do not contain bad values.</p>

<p>You may also ask &#39;well, my computer supports IEEE NaN, so I already have this&#39;. They are different things; a bad value signifies &quot;leave this out of processing&quot;, whereas NaN is the result of a mathematically-invalid operation.</p>

<p>Many routines, such as <code>y=sin(x)</code>, will propagate NaN&#39;s without the user having to code differently, but routines such as <code>qsort</code>, or finding the median of an array, need to be re-coded to handle bad values. For floating-point datatypes, <code>NaN</code> and <code>Inf</code> can be used to flag bad values, but by default special values are used (<a href="#Default-bad-values">Default bad values</a>).</p>

<p>There is one default bad value for each datatype, but as of PDL 2.040, you can have different bad values for separate ndarrays of the same type.</p>

<p>You can use <code>NaN</code> as the bad value for any floating-point type, including complex.</p>

<h2 id="A-quick-overview">A quick overview</h2>

<pre><code> pdl&gt; $x = sequence(4,3);
 pdl&gt; p $x
 [
  [ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]
 ]
 pdl&gt; $x = $x-&gt;setbadif( $x % 3 == 2 )
 pdl&gt; p $x
 [
  [  0   1 BAD   3]
  [  4 BAD   6   7]
  [BAD   9  10 BAD]
 ]
 pdl&gt; $x *= 3
 pdl&gt; p $x
 [
  [  0   3 BAD   9]
  [ 12 BAD  18  21]
  [BAD  27  30 BAD]
 ]
 pdl&gt; p $x-&gt;sum
 120</code></pre>

<p><code>demo bad</code> within <a>perldl</a> or <a>pdl2</a> gives a demonstration of some of the things possible with bad values. These are also available on PDL&#39;s web-site, at <i>http://pdl.perl.org/demos/</i>. See <a href="./Bad.html">PDL::Bad</a> for useful routines for working with bad values and <i>t/bad.t</i> to see them in action.</p>

<p>To find out if a routine supports bad values, use the <code>badinfo</code> command in <a>perldl</a> or <a href="./pdl2.html">pdl2</a> or the <code>-b</code> option to <a>pdldoc</a>.</p>

<p>Each ndarray contains a flag - accessible via <code>$pdl-&gt;badflag</code> - to say whether there&#39;s any bad data present:</p>

<ul>

<li><p>If <b>false/0</b>, which means there&#39;s no bad data here, the code supplied by the <code>Code</code> option to <code>pp_def()</code> is executed.</p>

</li>
<li><p>If <b>true/1</b>, then this says there <i>MAY</i> be bad data in the ndarray, so use the code in the <code>BadCode</code> option (assuming that the <code>pp_def()</code> for this routine has been updated to have a BadCode key). You get all the advantages of broadcasting, as with the <code>Code</code> option, but it will run slower since you are going to have to handle the presence of bad values.</p>

</li>
</ul>

<p>If you create an ndarray, it will have its bad-value flag set to 0. To change this, use <code>$pdl-&gt;badflag($new_bad_status)</code>, where <code>$new_bad_status</code> can be 0 or 1. When a routine creates an ndarray, its bad-value flag will depend on the input ndarrays: unless over-ridden (see the <code>CopyBadStatusCode</code> option to <code>pp_def</code>), the bad-value flag will be set true if any of the input ndarrays contain bad values. To check that an ndarray really contains bad data, use the <code>check_badflag</code> method.</p>

<p><i>NOTE</i>: propagation of the badflag</p>

<p>If you change the badflag of an ndarray, this change is propagated to all the <i>children</i> of an ndarray, so</p>

<pre><code>   pdl&gt; $x = zeroes(20,30);
   pdl&gt; $y = $x-&gt;slice(&#39;0:10,0:10&#39;);
   pdl&gt; $c = $y-&gt;slice(&#39;,(2)&#39;);
   pdl&gt; print &quot;&gt;&gt;c: &quot;, $c-&gt;badflag, &quot;\n&quot;;
   &gt;&gt;c: 0
   pdl&gt; $x-&gt;badflag(1);
   pdl&gt; print &quot;&gt;&gt;c: &quot;, $c-&gt;badflag, &quot;\n&quot;;
   &gt;&gt;c: 1</code></pre>

<p>This is also propagated to the parents of an ndarray, so</p>

<pre><code>   pdl&gt; print &quot;&gt;&gt;a: &quot;, $x-&gt;badflag, &quot;\n&quot;;
   &gt;&gt;a: 1
   pdl&gt; $c-&gt;badflag(0);
   pdl&gt; print &quot;&gt;&gt;a: &quot;, $x-&gt;badflag, &quot;\n&quot;;
   &gt;&gt;a: 0</code></pre>

<p>There&#39;s also the issue of what happens if you change the badvalue of an ndarray - should these propagate to children/parents (yes) or whether you should only be able to change the badvalue at the &#39;top&#39; level - i.e. those ndarrays which do not have parents.</p>

<p>The <code>orig_badvalue()</code> method returns the compile-time value for a given datatype. It works on ndarrays, PDL::Type objects, and numbers - eg</p>

<pre><code>  $pdl-&gt;orig_badvalue(), byte-&gt;orig_badvalue(), and orig_badvalue(4).</code></pre>

<p>To get the current bad value, use the <code>badvalue()</code> method - it has the same syntax as <code>orig_badvalue()</code>.</p>

<p>To change the current bad value, supply the new number to badvalue - eg</p>

<pre><code>  $pdl-&gt;badvalue(2.3), byte-&gt;badvalue(2), badvalue(5,-3e34). </code></pre>

<p><i>Note</i>: the value is silently converted to the correct C type, and returned - i.e. <code>byte-&gt;badvalue(-26)</code> returns 230 on my Linux machine.</p>

<p>Note that changes to the bad value are <i>NOT</i> propagated to previously-created ndarrays - they will still have the bad flag set, but suddenly the elements that were bad will become &#39;good&#39;, but containing the old bad value. See discussion below.</p>

<h2 id="Bad-values-and-boolean-operators">Bad values and boolean operators</h2>

<p>For those boolean operators in <a href="./Ops.html">PDL::Ops</a>, evaluation on a bad value returns the bad value. This:</p>

<pre><code> $mask = $img &gt; $thresh;</code></pre>

<p>correctly propagates bad values. This will omit any bad values, but return a bad value if there are no good ones:</p>

<pre><code> $bool = any( $img &gt; $thresh );</code></pre>

<p>As of 2.077, a bad value used as a boolean will throw an exception.</p>

<p>When using one of the &#39;projection&#39; functions in <a href="./Ufunc.html">PDL::Ufunc</a> - such as <a href="./Ufunc.html#orover">orover</a> - bad values are skipped over (see the documentation of these functions for the current handling of the case when all elements are bad).</p>

<h1 id="IMPLEMENTATION-DETAILS">IMPLEMENTATION DETAILS</h1>

<p>A new flag has been added to the state of an ndarray - <code>PDL_BADVAL</code>. If unset, then the ndarray does not contain bad values, and so all the support code can be ignored. If set, it does not guarantee that bad values are present, just that they should be checked for.</p>

<p>The <code>pdl_trans</code> structure has been extended to include an integer value, <code>bvalflag</code>, which acts as a switch to tell the code whether to handle bad values or not. This value is set if any of the input ndarrays have their <code>PDL_BADVAL</code> flag set (although this code can be replaced by setting <code>FindBadStateCode</code> in pp_def).</p>

<h2 id="Default-bad-values">Default bad values</h2>

<p>The default bad values are now stored in a structure within the Core PDL structure - <code>PDL.bvals</code> (eg <i>Basic/Core/pdlcore.h.PL</i>); see also <code>typedef badvals</code> in <i>Basic/Core/pdl.h.PL</i> and the BOOT code of <i>Basic/Core/Core.xs.PL</i> where the values are initialised to (hopefully) sensible values. See <a href="./Bad.html#badvalue">&quot;badvalue&quot; in PDL::Bad</a> and <a href="./Bad.html#orig_badvalue">&quot;orig_badvalue&quot; in PDL::Bad</a> for read/write routines to the values.</p>

<p>The default/original bad values are set to the C type&#39;s maximum (unsigned integers) or the minimum (floating-point and signed integers).</p>

<h2 id="How-do-I-change-a-routine-to-handle-bad-values">How do I change a routine to handle bad values?</h2>

<p>See <a href="./PP.html#BadCode">&quot;BadCode&quot; in PDL::PP</a> and <a href="./PP.html#HandleBad">&quot;HandleBad&quot; in PDL::PP</a>.</p>

<p>If you have a routine that you want to be able to use as in-place, look at the routines in <i>bad.pd</i> (or <i>ops.pd</i>) which use the <code>in-place</code> option to see how the bad flag is propagated to children using the <code>xxxBadStatusCode</code> options. I decided not to automate this as rules would be a little complex, since not every in-place op will need to propagate the badflag (eg unary functions).</p>

<p>This all means that you can change</p>

<pre><code>   Code =&gt; &#39;$a() = $b() + $c();&#39;</code></pre>

<p>to</p>

<pre><code>   BadCode =&gt; &#39;if ( $ISBAD(b()) || $ISBAD(c()) ) { 
                 $SETBAD(a()); 
               } else {
                 $a() = $b() + $c();
               }&#39;</code></pre>

<p>leaving Code as it is. PP::PDLCode will then create code something like</p>

<pre><code>   if ( __trans-&gt;bvalflag ) {
        broadcastloop over BadCode
   } else { 
        broadcastloop over Code
   }</code></pre>

<h1 id="WHAT-ABOUT-DOCUMENTATION">WHAT ABOUT DOCUMENTATION?</h1>

<p>One of the strengths of PDL is its on-line documentation. The aim is to use this system to provide information on how/if a routine supports bad values: in many cases <code>pp_def()</code> contains all the information anyway, so the function-writer doesn&#39;t need to do anything at all! For the cases when this is not sufficient, there&#39;s the <code>BadDoc</code> option. For code written at the Perl level - i.e. in a .pm file - use the <code>=for bad</code> pod directive.</p>

<p>This information will be available via man/pod2man/html documentation. It&#39;s also accessible from the <code>perldl</code> or <code>pdl2</code> shells - using the <code>badinfo</code> command - and the <code>pdldoc</code> shell command - using the <code>-b</code> option.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) Doug Burke (djburke@cpan.org), 2000, 2006.</p>

<p>The per-ndarray bad value support is by Heiko Klein (2006).</p>


</body>

</html>


