<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::Func - interpolation, integration, &amp; gradient estimation (differentiation) of functions</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#INTERPOLATION-AND-MORE">INTERPOLATION AND MORE</a>
    <ul>
      <li><a href="#Boundary-conditions-for-the-Hermite-routines">Boundary conditions for the Hermite routines</a></li>
      <li><a href="#Errors">Errors</a></li>
    </ul>
  </li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#init">init</a></li>
      <li><a href="#set">set</a></li>
      <li><a href="#get">get</a></li>
      <li><a href="#scheme">scheme</a></li>
      <li><a href="#status">status</a></li>
      <li><a href="#routine">routine</a></li>
      <li><a href="#attributes">attributes</a></li>
      <li><a href="#interpolate">interpolate</a></li>
      <li><a href="#gradient">gradient</a></li>
      <li><a href="#integrate">integrate</a></li>
    </ul>
  </li>
  <li><a href="#TODO">TODO</a></li>
  <li><a href="#HISTORY">HISTORY</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Func - interpolation, integration, &amp; gradient estimation (differentiation) of functions</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use PDL::Func;
 use PDL::Math;

 # somewhat pointless way to estimate cos and sin,
 # but is shows that you can broadcast if you want to
 # (and the library lets you)
 #
 my $obj = PDL::Func-&gt;init( Interpolate =&gt; &quot;Hermite&quot; );
 # 
 my $x = pdl( 0 .. 45 ) * 4 * 3.14159 / 180;
 my $y = cat( sin($x), cos($x) );
 $obj-&gt;set( x =&gt; $x, y =&gt; $y, bc =&gt; &quot;simple&quot; );
 #
 my $xi = pdl( 0.5, 1.5, 2.5 );
 my $yi = $obj-&gt;interpolate( $xi );
 #
 print &quot;sin( $xi ) equals &quot;, $yi-&gt;slice(&#39;:,(0)&#39;), &quot;\n&quot;;
 sin( [0.5 1.5 2.5] ) equals  [0.87759844 0.070737667 -0.80115622]
 #
 print &quot;cos( $xi ) equals &quot;, $yi-&gt;slice(&#39;:,(1)&#39;), &quot;\n&quot;;
 cos( [0.5 1.5 2.5] ) equals  [ 0.4794191 0.99768655 0.59846449]
 #
 print sin($xi), &quot;\n&quot;, cos($xi), &quot;\n&quot;;
 [0.47942554 0.99749499 0.59847214]
 [0.87758256 0.070737202 -0.80114362]</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module aims to contain useful functions. Honest.</p>

<h1 id="INTERPOLATION-AND-MORE">INTERPOLATION AND MORE</h1>

<p>This module aims to provide a relatively-uniform interface to the various interpolation methods available to PDL. The idea is that a different interpolation scheme can be used just by changing an attribute of a <code>PDL::Func</code> object. Some interpolation schemes (as exemplified by the SLATEC library) also provide additional functionality, such as integration and gradient estimation.</p>

<p>Throughout this documentation, <code>$x</code> and <code>$y</code> refer to the function to be interpolated whilst <code>$xi</code> and <code>$yi</code> are the interpolated values.</p>

<p>The available types, or <i>schemes</i>, of interpolation are listed below. Also given are the valid attributes for each scheme: the flag value indicates whether it can be set (s), got (g), and if it is required (r) for the method to work.</p>

<dl>

<dt id="Interpolate-Linear">Interpolate =&gt; Linear</dt>
<dd>

<p>An extravagent way of calling the linear interpolation routine <a href="./Primitive.html#interpolate">PDL::Primitive::interpolate</a>.</p>

<p>The valid attributes are:</p>

<pre><code> Attribute    Flag  Description
 x            sgr   x positions of data
 y            sgr   function values at x positions
 err          g     error flag</code></pre>

</dd>
<dt id="Interpolate-Hermite">Interpolate =&gt; Hermite</dt>
<dd>

<p>Use the piecewice cubic Hermite interpolation routines from the SLATEC library. Only available if <a>PDL::Slatec</a> is installed.</p>

<p>The valid attributes are:</p>

<pre><code> Attribute    Flag  Description
 x            sgr   x positions of data
 y            sgr   function values at x positions
 bc           sgr   boundary conditions
 g            g     estimated gradient at x positions
 err          g     error flag</code></pre>

<p>Given the initial set of points <code>(x,y)</code>, an estimate of the gradient is made at these points, using the given boundary conditions. The gradients are stored in the <code>g</code> attribute, accessible via:</p>

<pre><code> $gradient = $obj-&gt;get( &#39;g&#39; );</code></pre>

<p>However, as this gradient is only calculated &#39;at the last moment&#39;, <code>g</code> will only contain data <i>after</i> one of <code>interpolate</code>, <code>gradient</code>, or <code>integrate</code> is used.</p>

</dd>
</dl>

<h2 id="Boundary-conditions-for-the-Hermite-routines">Boundary conditions for the Hermite routines</h2>

<p>If your data is monotonic, and you are not too bothered about edge effects, then the default value of <code>bc</code> of <code>simple</code> is for you. Otherwise, take a look at the description of <a>PDL::Slatec::chic</a> and use a hash reference for the <code>bc</code> attribute, with the following keys:</p>

<dl>

<dt id="monotonic">monotonic</dt>
<dd>

<p>0 if the interpolant is to be monotonic in each interval (so the gradient will be 0 at each switch point), otherwise the gradient is calculated using a 3-point difference formula at switch points. If &gt; 0 then the interpolant is forced to lie close to the data, if &lt; 0 no such control is imposed. Default = <b>0</b>.</p>

</dd>
<dt id="start">start</dt>
<dd>

<p>A perl list of one or two elements. The first element defines how the boundary condition for the start of the array is to be calculated; it has a range of <code>-5 .. 5</code>, as given for the <code>ic</code> parameter of <a>chic</a>. The second element, only used if options 2, 1, -1, or 2 are chosen, contains the value of the <code>vc</code> parameter. Default = <b>[ 0 ]</b>.</p>

</dd>
<dt id="end">end</dt>
<dd>

<p>As for <code>start</code>, but for the end of the data.</p>

</dd>
</dl>

<p>An example would be</p>

<pre><code> $obj-&gt;set( bc =&gt; { start =&gt; [ 1, 0 ], end =&gt; [ 1, -1 ] } )</code></pre>

<p>which sets the first derivative at the first point to 0, and at the last point to -1.</p>

<h2 id="Errors">Errors</h2>

<p>The <code>status</code> method provides a simple mechanism to check if the previous method was successful. If the function returns an error flag, then it is stored in the <code>err</code> attribute. To find out which routine was used, use the <code>routine</code> method.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="init">init</h2>

<pre><code> $obj = PDL::Func-&gt;init( Interpolate =&gt; &quot;Hermite&quot;, x =&gt; $x, y =&gt; $y );
 $obj = PDL::Func-&gt;init( { x =&gt; $x, y =&gt; $y } );</code></pre>

<p>Create a PDL::Func object, which can interpolate, and possibly integrate and calculate gradients of a dataset.</p>

<p>If not specified, the value of Interpolate is taken to be <code>Linear</code>, which means the interpolation is performed by <a href="./Primitive.html#interpolate">PDL::Primitive::interpolate</a>. A value of <code>Hermite</code> uses piecewise cubic Hermite functions, which also allows the integral and gradient of the data to be estimated.</p>

<p>Options can either be provided directly to the method, as in the first example, or within a hash reference, as shown in the second example.</p>

<h2 id="set">set</h2>

<pre><code> my $nset = $obj-&gt;set( x =&gt; $newx, y =&gt; $newy );
 my $nset = $obj-&gt;set( { x =&gt; $newx, y =&gt; $newy } );</code></pre>

<p>Set attributes for a PDL::Func object.</p>

<p>The return value gives the number of the supplied attributes which were actually set.</p>

<h2 id="get">get</h2>

<pre><code> my $x         = $obj-&gt;get( x );
 my ( $x, $y ) = $obj-&gt;get( qw( x y ) );</code></pre>

<p>Get attributes from a PDL::Func object.</p>

<p>Given a list of attribute names, return a list of their values; in scalar mode return a scalar value. If the supplied list contains an unknown attribute, <code>get</code> returns a value of <code>undef</code> for that attribute.</p>

<h2 id="scheme">scheme</h2>

<pre><code> my $scheme = $obj-&gt;scheme;</code></pre>

<p>Return the type of interpolation of a PDL::Func object.</p>

<p>Returns either <code>Linear</code> or <code>Hermite</code>.</p>

<h2 id="status">status</h2>

<pre><code> my $status = $obj-&gt;status;</code></pre>

<p>Returns the status of a PDL::Func object.</p>

<p>This method provides a high-level indication of the success of the last method called (except for <code>get</code> which is ignored). Returns <b>1</b> if everything is okay, <b>0</b> if there has been a serious error, and <b>-1</b> if there was a problem which was not serious. In the latter case, <code>$obj-&gt;get(&quot;err&quot;)</code> may provide more information, depending on the particular scheme in use.</p>

<h2 id="routine">routine</h2>

<pre><code> my $name = $obj-&gt;routine;</code></pre>

<p>Returns the name of the last routine called by a PDL::Func object.</p>

<p>This is mainly useful for decoding the value stored in the <code>err</code> attribute.</p>

<h2 id="attributes">attributes</h2>

<pre><code> $obj-&gt;attributes;
 PDL::Func-&gt;attributes;</code></pre>

<p>Print out the flags for the attributes of a PDL::Func object.</p>

<p>Useful in case the documentation is just too opaque!</p>

<pre><code> PDL::Func-&gt;attributes;
 Flags  Attribute
  SGR    x
  SGR    y
  G      err</code></pre>

<h2 id="interpolate">interpolate</h2>

<pre><code> my $yi = $obj-&gt;interpolate( $xi );</code></pre>

<p>Returns the interpolated function at a given set of points (PDL::Func).</p>

<p>A status value of -1, as returned by the <code>status</code> method, means that some of the <code>$xi</code> points lay outside the range of the data. The values for these points were calculated by extrapolation (the details depend on the scheme being used).</p>

<h2 id="gradient">gradient</h2>

<pre><code> my $gi          = $obj-&gt;gradient( $xi );
 my ( $yi, $gi ) = $obj-&gt;gradient( $xi );</code></pre>

<p>Returns the derivative and, optionally, the interpolated function for the <code>Hermite</code> scheme (PDL::Func).</p>

<h2 id="integrate">integrate</h2>

<pre><code> my $ans = $obj-&gt;integrate( index =&gt; pdl( 2, 5 ) );
 my $ans = $obj-&gt;integrate( x =&gt; pdl( 2.3, 4.5 ) );</code></pre>

<p>Integrate the function stored in the PDL::Func object, if the scheme is <code>Hermite</code>.</p>

<p>The integration can either be between points of the original <code>x</code> array (<code>index</code>), or arbitrary x values (<code>x</code>). For both cases, a two element ndarray should be given, to specify the start and end points of the integration.</p>

<dl>

<dt id="index">index</dt>
<dd>

<p>The values given refer to the indices of the points in the <code>x</code> array.</p>

</dd>
<dt id="x">x</dt>
<dd>

<p>The array contains the actual values to integrate between.</p>

</dd>
</dl>

<p>If the <code>status</code> method returns a value of -1, then one or both of the integration limits did not lie inside the <code>x</code> array. <i>Caveat emptor</i> with the result in such a case.</p>

<h1 id="TODO">TODO</h1>

<p>It should be relatively easy to provide an interface to other interpolation routines, such as those provided by the Gnu Scientific Library (GSL), or the B-spline routines in the SLATEC library.</p>

<p>In the documentation, the methods are preceded by <code>PDL::Func::</code> to avoid clashes with functions such as <code>set</code> when using the <code>help</code> or <code>apropos</code> commands within <i>perldl</i> or <i>pdl2</i>.</p>

<h1 id="HISTORY">HISTORY</h1>

<p>Amalgamated <code>PDL::Interpolate</code> and <code>PDL::Interpolate::Slatec</code> to form <code>PDL::Func</code>. Comments greatly appreciated on the current implementation, as it is not too sensible.</p>

<p>Thanks to Robin Williams, Halld&oacute;r Olafsson, and Vince McIntyre.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) 2000,2001 Doug Burke (dburke@cfa.harvard.edu). All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation as described in the file COPYING in the PDL distribution.</p>


</body>

</html>


