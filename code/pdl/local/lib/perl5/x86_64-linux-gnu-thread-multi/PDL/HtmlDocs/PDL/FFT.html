<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::FFT - FFTs for PDL</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DATA-TYPES">DATA TYPES</a></li>
  <li><a href="#FREQUENCIES">FREQUENCIES</a></li>
  <li><a href="#ALTERNATIVE-FFT-PACKAGES">ALTERNATIVE FFT PACKAGES</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#fft">fft</a></li>
      <li><a href="#ifft">ifft</a></li>
      <li><a href="#realfft">realfft()</a></li>
      <li><a href="#realifft">realifft()</a></li>
      <li><a href="#fftnd">fftnd()</a></li>
      <li><a href="#ifftnd">ifftnd()</a></li>
      <li><a href="#fftconvolve">fftconvolve()</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::FFT - FFTs for PDL</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>!!!!!!!!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! As of PDL-2.006_04, the direction of the FFT/IFFT has been reversed to match the usage in the FFTW library and the convention in use generally. !!!!!!!!!!!!!!!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>

<p>FFTs for PDL. These work for arrays of any dimension, although ones with small prime factors are likely to be the quickest. The forward FFT is unnormalized while the inverse FFT is normalized so that the IFFT of the FFT returns the original values.</p>

<p>For historical reasons, these routines work in-place and do not recognize the in-place flag. That should be fixed.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>        use PDL::FFT qw/:Func/;

        fft($real, $imag);
        ifft($real, $imag);
        realfft($real);
        realifft($real);

        fftnd($real,$imag);
        ifftnd($real,$imag);

        $kernel = kernctr($image,$smallk);
        fftconvolve($image,$kernel);</code></pre>

<h1 id="DATA-TYPES">DATA TYPES</h1>

<p>The underlying C library upon which this module is based performs FFTs on both single precision and double precision floating point ndarrays. The PP functions are defined to only take those data types. Therefore, if you pass in an ndarray of integer datatype (byte, short, ushort, long) to any of the routines in PDL::FFT, your data will be promoted to a double-precision ndarray. If you pass in a float, the single-precision FFT will be performed.</p>

<h1 id="FREQUENCIES">FREQUENCIES</h1>

<p>For even-sized input arrays, the frequencies are packed like normal for FFTs (where N is the size of the array and D is the physical step size between elements):</p>

<pre><code> 0, 1/ND, 2/ND, ..., (N/2-1)/ND, 1/2D, -(N/2-1)/ND, ..., -1/ND.</code></pre>

<p>which can easily be obtained (taking the Nyquist frequency to be positive) using</p>

<p><code>$kx = $real-&gt;xlinvals(-($N/2-1)/$N/$D,1/2/$D)-&gt;rotate(-($N/2 -1));</code></p>

<p>For odd-sized input arrays the Nyquist frequency is not directly acessible, and the frequencies are</p>

<pre><code> 0, 1/ND, 2/ND, ..., (N/2-0.5)/ND, -(N/2-0.5)/ND, ..., -1/ND.</code></pre>

<p>which can easily be obtained using</p>

<p><code>$kx = $real-&gt;xlinvals(-($N/2-0.5)/$N/$D,($N/2-0.5)/$N/$D)-&gt;rotate(-($N-1)/2);</code></p>

<h1 id="ALTERNATIVE-FFT-PACKAGES">ALTERNATIVE FFT PACKAGES</h1>

<p>Various other modules - such as <a>PDL::FFTW3</a> and <a>PDL::Slatec</a> - contain FFT routines. However, unlike PDL::FFT, these modules are optional, and so may not be installed.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="fft">fft</h2>

<pre><code>  Signature: ([io]real(n); [io]imag(n))</code></pre>

<p>Complex 1-D FFT of the &quot;real&quot; and &quot;imag&quot; arrays [inplace]. A single cfloat/cdouble input ndarray can also be used.</p>

<pre><code>  fft($real,$imag);
  fft($complex);</code></pre>

<p>fft does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="ifft">ifft</h2>

<pre><code>  Signature: ([io]real(n); [io]imag(n))</code></pre>

<p>Complex inverse 1-D FFT of the &quot;real&quot; and &quot;imag&quot; arrays [inplace]. A single cfloat/cdouble input ndarray can also be used.</p>

<pre><code>  ifft($real,$imag);
  ifft($complex);</code></pre>

<p>ifft does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="realfft">realfft()</h2>

<p>One-dimensional FFT of real function [inplace].</p>

<p>The real part of the transform ends up in the first half of the array and the imaginary part of the transform ends up in the second half of the array.</p>

<pre><code>        realfft($real);</code></pre>

<h2 id="realifft">realifft()</h2>

<p>Inverse of one-dimensional realfft routine [inplace].</p>

<pre><code>        realifft($real);</code></pre>

<h2 id="fftnd">fftnd()</h2>

<p>N-dimensional FFT over all pdl dims of input (inplace)</p>

<pre><code>        fftnd($real,$imag);</code></pre>

<h2 id="ifftnd">ifftnd()</h2>

<p>N-dimensional inverse FFT over all pdl dims of input (inplace)</p>

<pre><code>        ifftnd($real,$imag);</code></pre>

<h2 id="fftconvolve">fftconvolve()</h2>

<p>N-dimensional convolution with periodic boundaries (FFT method)</p>

<pre><code>        $kernel = kernctr($image,$smallk);
        fftconvolve($image,$kernel);</code></pre>

<p>fftconvolve works inplace, and returns an error array in kernel as an accuracy check -- all the values in it should be negligible.</p>

<p>See also <a href="./ImageND.html#convolveND">PDL::ImageND::convolveND</a>, which performs speed-optimized convolution with a variety of boundary conditions.</p>

<p>The sizes of the image and the kernel must be the same. <a href="./ImageND.html#kernctr">kernctr</a> centres a small kernel to emulate the behaviour of the direct convolution routines.</p>

<p>The speed cross-over between using straight convolution (<a href="./Image2D.html#conv2d">PDL::Image2D::conv2d()</a>) and these fft routines is for kernel sizes roughly 7x7.</p>

<h1 id="BUGS">BUGS</h1>

<p>Where the source is marked `FIX&#39;, could re-implement using phase-shift factors on the transforms and some real-space bookkeeping, to save some temporary space and redundant transforms.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>This file copyright (C) 1997, 1998 R.J.R. Williams (rjrw@ast.leeds.ac.uk), Karl Glazebrook (kgb@aaoepp.aao.gov.au), Tuomas J. Lukka, (lukka@husc.harvard.edu). All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


