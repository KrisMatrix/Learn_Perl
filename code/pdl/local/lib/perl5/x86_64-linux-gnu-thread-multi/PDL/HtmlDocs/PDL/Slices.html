<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::Slices -- Indexing, slicing, and dicing</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#index">index</a></li>
      <li><a href="#index1d">index1d</a></li>
      <li><a href="#index2d">index2d</a></li>
      <li><a href="#indexNDb">indexNDb</a></li>
      <li><a href="#indexND">indexND</a></li>
      <li><a href="#rangeb">rangeb</a></li>
      <li><a href="#range">range</a></li>
      <li><a href="#rld">rld</a></li>
      <li><a href="#rle">rle</a></li>
      <li><a href="#rlevec">rlevec</a></li>
      <li><a href="#rldvec">rldvec</a></li>
      <li><a href="#rleseq">rleseq</a></li>
      <li><a href="#rldseq">rldseq</a></li>
      <li><a href="#rleND">rleND</a></li>
      <li><a href="#rldND">rldND</a></li>
      <li><a href="#xchg">xchg</a></li>
      <li><a href="#reorder">reorder</a></li>
      <li><a href="#mv">mv</a></li>
      <li><a href="#using">using</a></li>
      <li><a href="#diagonal">diagonal</a></li>
      <li><a href="#lags">lags</a></li>
      <li><a href="#splitdim">splitdim</a></li>
      <li><a href="#rotate">rotate</a></li>
      <li><a href="#broadcastI">broadcastI</a></li>
      <li><a href="#unbroadcast">unbroadcast</a></li>
      <li><a href="#dice">dice</a></li>
      <li><a href="#dice_axis">dice_axis</a></li>
      <li><a href="#slice">slice</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Slices -- Indexing, slicing, and dicing</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  use PDL;
  $x = ones(3,3);
  $y = $x-&gt;slice(&#39;-1:0,(1)&#39;);
  $c = $x-&gt;dummy(2);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This package provides many of the powerful PerlDL core index manipulation routines. These routines mostly allow two-way data flow, so you can modify your data in the most convenient representation. For example, you can make a 1000x1000 unit matrix with</p>

<pre><code> $x = zeroes(1000,1000);
 $x-&gt;diagonal(0,1) ++;</code></pre>

<p>which is quite efficient. See <a href="./Indexing.html">PDL::Indexing</a> and <a href="./Tips.html">PDL::Tips</a> for more examples.</p>

<p>Slicing is so central to the PDL language that a special compile-time syntax has been introduced to handle it compactly; see <a href="./NiceSlice.html">PDL::NiceSlice</a> for details.</p>

<p>PDL indexing and slicing functions usually include two-way data flow, so that you can separate the actions of reshaping your data structures and modifying the data themselves. Two special methods, <a href="#copy">&quot;copy&quot;</a> and <a href="#sever">&quot;sever&quot;</a>, help you control the data flow connection between related variables.</p>

<pre><code> $y = $x-&gt;slice(&quot;1:3&quot;); # Slice maintains a link between $x and $y.
 $y += 5;               # $x is changed!</code></pre>

<p>If you want to force a physical copy and no data flow, you can copy or sever the slice expression:</p>

<pre><code> $y = $x-&gt;slice(&quot;1:3&quot;)-&gt;copy;
 $y += 5;               # $x is not changed.

 $y = $x-&gt;slice(&quot;1:3&quot;)-&gt;sever;
 $y += 5;               # $x is not changed.</code></pre>

<p>The difference between <code>sever</code> and <code>copy</code> is that sever acts on (and returns) its argument, while copy produces a disconnected copy. If you say</p>

<pre><code> $y = $x-&gt;slice(&quot;1:3&quot;);
 $c = $y-&gt;sever;</code></pre>

<p>then the variables <code>$y</code> and <code>$c</code> point to the same object but with <code>-&gt;copy</code> they would not.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="index">index</h2>

<pre><code>  Signature: (a(n); indx ind(); [oca] c())</code></pre>

<p><code>index</code>, <code>index1d</code>, and <code>index2d</code> provide rudimentary index indirection.</p>

<pre><code> $c = index($source,$ind);
 $c = index1d($source,$ind);
 $c = index2d($source2,$ind1,$ind2);</code></pre>

<p>use the <code>$ind</code> variables as indices to look up values in <code>$source</code>. The three routines broadcast slightly differently.</p>

<ul>

<li><p><code>index</code> uses direct broadcasting for 1-D indexing across the 0 dim of <code>$source</code>. It can broadcast over source broadcast dims or index broadcast dims, but not (easily) both: If <code>$source</code> has more than 1 dimension and <code>$ind</code> has more than 0 dimensions, they must agree in a broadcasting sense.</p>

</li>
<li><p><code>index1d</code> uses a single active dim in <code>$ind</code> to produce a list of indexed values in the 0 dim of the output - it is useful for collapsing <code>$source</code> by indexing with a single row of values along <code>$source</code>&#39;s 0 dimension. The output has the same number of dims as <code>$source</code>. The 0 dim of the output has size 1 if <code>$ind</code> is a scalar, and the same size as the 0 dim of <code>$ind</code> if it is not. If <code>$ind</code> and <code>$source</code> both have more than 1 dim, then all dims higher than 0 must agree in a broadcasting sense.</p>

</li>
<li><p><code>index2d</code> works like <code>index</code> but uses separate ndarrays for X and Y coordinates. For more general N-dimensional indexing, see the <a href="./NiceSlice.html">PDL::NiceSlice</a> syntax or <a href="./Slices.html">PDL::Slices</a> (in particular <code>slice</code>, <code>indexND</code>, and <code>range</code>).</p>

</li>
</ul>

<p>These functions are two-way, i.e. after</p>

<pre><code> $c = $x-&gt;index(pdl[0,5,8]);
 $c .= pdl [0,2,4];</code></pre>

<p>the changes in <code>$c</code> will flow back to <code>$x</code>.</p>

<p><code>index</code> provids simple broadcasting: multiple-dimensioned arrays are treated as collections of 1-D arrays, so that</p>

<pre><code> $x = xvals(10,10)+10*yvals(10,10);
 $y = $x-&gt;index(3);
 $c = $x-&gt;index(9-xvals(10));</code></pre>

<p>puts a single column from <code>$x</code> into <code>$y</code>, and puts a single element from each column of <code>$x</code> into <code>$c</code>. If you want to extract multiple columns from an array in one operation, see <a href="#dice">&quot;dice&quot;</a> or <a href="#indexND">&quot;indexND&quot;</a>.</p>

<p>index barfs if any of the index values are bad.</p>

<h2 id="index1d">index1d</h2>

<pre><code>  Signature: (a(n); indx ind(m); [oca] c(m))</code></pre>

<p><code>index</code>, <code>index1d</code>, and <code>index2d</code> provide rudimentary index indirection.</p>

<pre><code> $c = index($source,$ind);
 $c = index1d($source,$ind);
 $c = index2d($source2,$ind1,$ind2);</code></pre>

<p>use the <code>$ind</code> variables as indices to look up values in <code>$source</code>. The three routines broadcast slightly differently.</p>

<ul>

<li><p><code>index</code> uses direct broadcasting for 1-D indexing across the 0 dim of <code>$source</code>. It can broadcast over source broadcast dims or index broadcast dims, but not (easily) both: If <code>$source</code> has more than 1 dimension and <code>$ind</code> has more than 0 dimensions, they must agree in a broadcasting sense.</p>

</li>
<li><p><code>index1d</code> uses a single active dim in <code>$ind</code> to produce a list of indexed values in the 0 dim of the output - it is useful for collapsing <code>$source</code> by indexing with a single row of values along <code>$source</code>&#39;s 0 dimension. The output has the same number of dims as <code>$source</code>. The 0 dim of the output has size 1 if <code>$ind</code> is a scalar, and the same size as the 0 dim of <code>$ind</code> if it is not. If <code>$ind</code> and <code>$source</code> both have more than 1 dim, then all dims higher than 0 must agree in a broadcasting sense.</p>

</li>
<li><p><code>index2d</code> works like <code>index</code> but uses separate ndarrays for X and Y coordinates. For more general N-dimensional indexing, see the <a href="./NiceSlice.html">PDL::NiceSlice</a> syntax or <a href="./Slices.html">PDL::Slices</a> (in particular <code>slice</code>, <code>indexND</code>, and <code>range</code>).</p>

</li>
</ul>

<p>These functions are two-way, i.e. after</p>

<pre><code> $c = $x-&gt;index(pdl[0,5,8]);
 $c .= pdl [0,2,4];</code></pre>

<p>the changes in <code>$c</code> will flow back to <code>$x</code>.</p>

<p><code>index</code> provids simple broadcasting: multiple-dimensioned arrays are treated as collections of 1-D arrays, so that</p>

<pre><code> $x = xvals(10,10)+10*yvals(10,10);
 $y = $x-&gt;index(3);
 $c = $x-&gt;index(9-xvals(10));</code></pre>

<p>puts a single column from <code>$x</code> into <code>$y</code>, and puts a single element from each column of <code>$x</code> into <code>$c</code>. If you want to extract multiple columns from an array in one operation, see <a href="#dice">&quot;dice&quot;</a> or <a href="#indexND">&quot;indexND&quot;</a>.</p>

<p>index1d propagates BAD index elements to the output variable.</p>

<h2 id="index2d">index2d</h2>

<pre><code>  Signature: (a(na,nb); indx inda(); indx indb(); [oca] c())</code></pre>

<p><code>index</code>, <code>index1d</code>, and <code>index2d</code> provide rudimentary index indirection.</p>

<pre><code> $c = index($source,$ind);
 $c = index1d($source,$ind);
 $c = index2d($source2,$ind1,$ind2);</code></pre>

<p>use the <code>$ind</code> variables as indices to look up values in <code>$source</code>. The three routines broadcast slightly differently.</p>

<ul>

<li><p><code>index</code> uses direct broadcasting for 1-D indexing across the 0 dim of <code>$source</code>. It can broadcast over source broadcast dims or index broadcast dims, but not (easily) both: If <code>$source</code> has more than 1 dimension and <code>$ind</code> has more than 0 dimensions, they must agree in a broadcasting sense.</p>

</li>
<li><p><code>index1d</code> uses a single active dim in <code>$ind</code> to produce a list of indexed values in the 0 dim of the output - it is useful for collapsing <code>$source</code> by indexing with a single row of values along <code>$source</code>&#39;s 0 dimension. The output has the same number of dims as <code>$source</code>. The 0 dim of the output has size 1 if <code>$ind</code> is a scalar, and the same size as the 0 dim of <code>$ind</code> if it is not. If <code>$ind</code> and <code>$source</code> both have more than 1 dim, then all dims higher than 0 must agree in a broadcasting sense.</p>

</li>
<li><p><code>index2d</code> works like <code>index</code> but uses separate ndarrays for X and Y coordinates. For more general N-dimensional indexing, see the <a href="./NiceSlice.html">PDL::NiceSlice</a> syntax or <a href="./Slices.html">PDL::Slices</a> (in particular <code>slice</code>, <code>indexND</code>, and <code>range</code>).</p>

</li>
</ul>

<p>These functions are two-way, i.e. after</p>

<pre><code> $c = $x-&gt;index(pdl[0,5,8]);
 $c .= pdl [0,2,4];</code></pre>

<p>the changes in <code>$c</code> will flow back to <code>$x</code>.</p>

<p><code>index</code> provids simple broadcasting: multiple-dimensioned arrays are treated as collections of 1-D arrays, so that</p>

<pre><code> $x = xvals(10,10)+10*yvals(10,10);
 $y = $x-&gt;index(3);
 $c = $x-&gt;index(9-xvals(10));</code></pre>

<p>puts a single column from <code>$x</code> into <code>$y</code>, and puts a single element from each column of <code>$x</code> into <code>$c</code>. If you want to extract multiple columns from an array in one operation, see <a href="#dice">&quot;dice&quot;</a> or <a href="#indexND">&quot;indexND&quot;</a>.</p>

<p>index2d barfs if either of the index values are bad.</p>

<h2 id="indexNDb">indexNDb</h2>

<pre><code>  Backwards-compatibility alias for indexND</code></pre>

<h2 id="indexND">indexND</h2>

<pre><code>  Find selected elements in an N-D ndarray, with optional boundary handling</code></pre>

<pre><code>  $out = $source-&gt;indexND( $index, [$method] )

  $source = 10*xvals(10,10) + yvals(10,10);
  $index  = pdl([[2,3],[4,5]],[[6,7],[8,9]]);
  print $source-&gt;indexND( $index );

  [
   [23 45]
   [67 89]
  ]</code></pre>

<p>IndexND collapses <code>$index</code> by lookup into <code>$source</code>. The 0th dimension of <code>$index</code> is treated as coordinates in <code>$source</code>, and the return value has the same dimensions as the rest of <code>$index</code>. The returned elements are looked up from <code>$source</code>. Dataflow works -- propagated assignment flows back into <code>$source</code>.</p>

<p>IndexND and IndexNDb were originally separate routines but they are both now implemented as a call to <a href="#range">&quot;range&quot;</a>, and have identical syntax to one another.</p>

<p>SEE ALSO:</p>

<p><a href="./Primitive.html#whichND">&quot;whichND&quot; in PDL::Primitive</a> returns N-D indices into a multidimensional PDL, suitable for feeding to this.</p>

<h2 id="rangeb">rangeb</h2>

<pre><code>  Signature: (P(); C(); pdl *ind_pdl; SV *size; SV *boundary_sv)</code></pre>

<p>Engine for <a href="#range">&quot;range&quot;</a></p>

<p>Same calling convention as <a href="#range">&quot;range&quot;</a>, but you must supply all parameters. <code>rangeb</code> is marginally faster as it makes a direct PP call, avoiding the perl argument-parsing step.</p>

<h2 id="range">range</h2>

<p>Extract selected chunks from a source ndarray, with boundary conditions</p>

<pre><code>        $out = $source-&gt;range($index,[$size,[$boundary]])</code></pre>

<p>Returns elements or rectangular slices of the original ndarray, indexed by the <code>$index</code> ndarray. <code>$source</code> is an N-dimensional ndarray, and <code>$index</code> is an ndarray whose first dimension has size up to N. Each row of <code>$index</code> is treated as coordinates of a single value or chunk from <code>$source</code>, specifying the location(s) to extract.</p>

<p>If you specify a single index location, then range is essentially an expensive slice, with controllable boundary conditions.</p>

<p><b>INPUTS</b></p>

<p><code>$index</code> and <code>$size</code> can be ndarrays or array refs such as you would feed to <a href="./Core.html#zeroes">zeroes</a> and its ilk. If <code>$index</code>&#39;s 0th dimension has size higher than the number of dimensions in <code>$source</code>, then <code>$source</code> is treated as though it had trivial dummy dimensions of size 1, up to the required size to be indexed by <code>$index</code> -- so if your source array is 1-D and your index array is a list of 3-vectors, you get two dummy dimensions of size 1 on the end of your source array.</p>

<p>You can extract single elements or N-D rectangular ranges from <code>$source</code>, by setting <code>$size</code>. If <code>$size</code> is undef or zero, then you get a single sample for each row of <code>$index</code>. This behavior is similar to <a href="#indexNDb">&quot;indexNDb&quot;</a>, which is in fact implemented as a call to <a href="#range">&quot;range&quot;</a>.</p>

<p>If <code>$size</code> is positive then you get a range of values from <code>$source</code> at each location, and the output has extra dimensions allocated for them. <code>$size</code> can be a scalar, in which case it applies to all dimensions, or an N-vector, in which case each element is applied independently to the corresponding dimension in <code>$source</code>. See below for details.</p>

<p><code>$boundary</code> is a number, string, or list ref indicating the type of boundary conditions to use when ranges reach the edge of <code>$source</code>. If you specify no boundary conditions the default is to forbid boundary violations on all axes. If you specify exactly one boundary condition, it applies to all axes. If you specify more (as elements of a list ref, or as a packed string, see below), then they apply to dimensions in the order in which they appear, and the last one applies to all subsequent dimensions. (This is less difficult than it sounds; see the examples below).</p>

<dl>

<dt id="synonyms:-f-forbid-default">0 (synonyms: &#39;f&#39;,&#39;forbid&#39;) <b>(default)</b></dt>
<dd>

<p>Ranges are not allowed to cross the boundary of the original PDL. Disallowed ranges throw an error. The errors are thrown at evaluation time, not at the time of the range call (this is the same behavior as <a href="#slice">&quot;slice&quot;</a>).</p>

</dd>
<dt id="synonyms:-t-truncate">1 (synonyms: &#39;t&#39;,&#39;truncate&#39;)</dt>
<dd>

<p>Values outside the original ndarray get BAD if you&#39;ve got bad value support compiled into your PDL and set the badflag for the source PDL; or 0 if you haven&#39;t (you must set the badflag if you want BADs for out of bound values, otherwise you get 0). Reverse dataflow works OK for the portion of the child that is in-bounds. The out-of-bounds part of the child is reset to (BAD|0) during each dataflow operation, but execution continues.</p>

</dd>
<dt id="synonyms:-e-x-extend">2 (synonyms: &#39;e&#39;,&#39;x&#39;,&#39;extend&#39;)</dt>
<dd>

<p>Values that would be outside the original ndarray point instead to the nearest allowed value within the ndarray. See the CAVEAT below on mappings that are not single valued.</p>

</dd>
<dt id="synonyms:-p-periodic">3 (synonyms: &#39;p&#39;,&#39;periodic&#39;)</dt>
<dd>

<p>Periodic boundary conditions apply: the numbers in $index are applied, strict-modulo the corresponding dimensions of $source. This is equivalent to duplicating the $source ndarray throughout N-D space. See the CAVEAT below about mappings that are not single valued.</p>

</dd>
<dt id="synonyms:-m-mirror">4 (synonyms: &#39;m&#39;,&#39;mirror&#39;)</dt>
<dd>

<p>Mirror-reflection periodic boundary conditions apply. See the CAVEAT below about mappings that are not single valued.</p>

</dd>
</dl>

<p>The boundary condition identifiers all begin with unique characters, so you can feed in multiple boundary conditions as either a list ref or a packed string. (The packed string is marginally faster to run). For example, the four expressions [0,1], [&#39;forbid&#39;,&#39;truncate&#39;], [&#39;f&#39;,&#39;t&#39;], and &#39;ft&#39; all specify that violating the boundary in the 0th dimension throws an error, and all other dimensions get truncated.</p>

<p>If you feed in a single string, it is interpreted as a packed boundary array if all of its characters are valid boundary specifiers (e.g. &#39;pet&#39;), but as a single word-style specifier if they are not (e.g. &#39;forbid&#39;).</p>

<p><b>OUTPUT</b></p>

<p>The output broadcasts over both <code>$index</code> and <code>$source</code>. Because implicit broadcasting can happen in a couple of ways, a little thought is needed. The returned dimension list is stacked up like this:</p>

<pre><code>   (index broadcast dims), (index dims (size)), (source broadcast dims)</code></pre>

<p>The first few dims of the output correspond to the extra dims of <code>$index</code> (beyond the 0 dim). They allow you to pick out individual ranges from a large, broadcasted collection.</p>

<p>The middle few dims of the output correspond to the size dims specified in <code>$size</code>, and contain the range of values that is extracted at each location in <code>$source</code>. Every nonzero element of <code>$size</code> is copied to the dimension list here, so that if you feed in (for example) <code>$size = [2,0,1]</code> you get an index dim list of <code>(2,1)</code>.</p>

<p>The last few dims of the output correspond to extra dims of <code>$source</code> beyond the number of dims indexed by <code>$index</code>. These dims act like ordinary broadcast dims, because adding more dims to <code>$source</code> just tacks extra dims on the end of the output. Each source broadcast dim ranges over the entire corresponding dim of <code>$source</code>.</p>

<p><b>Dataflow</b>: Dataflow is bidirectional.</p>

<p><b>Examples</b>: Here are basic examples of <code>range</code> operation, showing how to get ranges out of a small matrix. The first few examples show extraction and selection of individual chunks. The last example shows how to mark loci in the original matrix (using dataflow).</p>

<pre><code> pdl&gt; $src = 10*xvals(10,5)+yvals(10,5)
 pdl&gt; print $src-&gt;range([2,3])    # Cut out a single element
 23
 pdl&gt; print $src-&gt;range([2,3],1)  # Cut out a single 1x1 block
 [
  [23]
 ]
 pdl&gt; print $src-&gt;range([2,3], [2,1]) # Cut a 2x1 chunk
 [
  [23 33]
 ]
 pdl&gt; print $src-&gt;range([[2,3]],[2,1]) # Trivial list of 1 chunk
 [
  [
   [23]
   [33]
  ]
 ]
 pdl&gt; print $src-&gt;range([[2,3],[0,1]], [2,1])   # two 2x1 chunks
 [
  [
   [23  1]
   [33 11]
  ]
 ]
 pdl&gt; # A 2x2 collection of 2x1 chunks
 pdl&gt; print $src-&gt;range([[[1,1],[2,2]],[[2,3],[0,1]]],[2,1])
 [
  [
   [
    [11 22]
    [23  1]
   ]
   [
    [21 32]
    [33 11]
   ]
  ]
 ]
 pdl&gt; $src = xvals(5,3)*10+yvals(5,3)
 pdl&gt; print $src-&gt;range(3,1)  # Broadcast over y dimension in $src
 [
  [30]
  [31]
  [32]
 ]

 pdl&gt; $src = zeroes(5,4);
 pdl&gt; $src-&gt;range(pdl([2,3],[0,1]),pdl(2,1)) .= xvals(2,2,1) + 1
 pdl&gt; print $src
 [
  [0 0 0 0 0]
  [2 2 0 0 0]
  [0 0 0 0 0]
  [0 0 1 1 0]
 ]</code></pre>

<p><b>CAVEAT</b>: It&#39;s quite possible to select multiple ranges that intersect. In that case, modifying the ranges doesn&#39;t have a guaranteed result in the original PDL -- the result is an arbitrary choice among the valid values. For some things that&#39;s OK; but for others it&#39;s not. In particular, this doesn&#39;t work:</p>

<pre><code>    pdl&gt; $photon_list = new PDL::RandVar-&gt;sample(500)-&gt;reshape(2,250)*10
    pdl&gt; $histogram = zeroes(10,10)
    pdl&gt; $histogram-&gt;range($photon_list,1)++;  #not what you wanted</code></pre>

<p>The reason is that if two photons land in the same bin, then that bin doesn&#39;t get incremented twice. (That may get fixed in a later version...)</p>

<p><b>PERMISSIVE RANGING</b>: If <code>$index</code> has too many dimensions compared to <code>$source</code>, then $source is treated as though it had dummy dimensions of size 1, up to the required number of dimensions. These virtual dummy dimensions have the usual boundary conditions applied to them.</p>

<p>If the 0 dimension of <code>$index</code> is ludicrously large (if its size is more than 5 greater than the number of dims in the source PDL) then range will insist that you specify a size in every dimension, to make sure that you know what you&#39;re doing. That catches a common error with range usage: confusing the initial dim (which is usually small) with another index dim (perhaps of size 1000).</p>

<p>If the index variable is Empty, then range() always returns the Empty PDL. If the index variable is not Empty, indexing it always yields a boundary violation. All non-barfing conditions are treated as truncation, since there are no actual data to return.</p>

<p><b>EFFICIENCY</b>: Because <code>range</code> isn&#39;t an affine transformation (it involves lookup into a list of N-D indices), it is somewhat memory-inefficient for long lists of ranges, and keeping dataflow open is much slower than for affine transformations (which don&#39;t have to copy data around).</p>

<p>Doing operations on small subfields of a large range is inefficient because the engine must flow the entire range back into the original PDL with every atomic perl operation, even if you only touch a single element. One way to speed up such code is to sever your range, so that PDL doesn&#39;t have to copy the data with each operation, then copy the elements explicitly at the end of your loop. Here&#39;s an example that labels each region in a range sequentially, using many small operations rather than a single xvals assignment:</p>

<pre><code>  ### How to make a collection of small ops run fast with range...
  $x =  $data-&gt;range($index, $sizes, $bound)-&gt;sever;
  $aa = $data-&gt;range($index, $sizes, $bound);
  $x($_ - 1) .= $_ for 1..$x-&gt;nelem;    # Lots of little ops
  $aa .= $x;</code></pre>

<p><code>range</code> is a perl front-end to a PP function, <code>rangeb</code>. Calling <code>rangeb</code> is marginally faster but requires that you include all arguments.</p>

<p>DEVEL NOTES</p>

<p>* index broadcast dimensions are effectively clumped internally. This makes it easier to loop over the index array but a little more brain-bending to tease out the algorithm.</p>

<p>rangeb processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rld">rld</h2>

<pre><code>  Signature: (indx a(n); b(n); [o]c(m))</code></pre>

<p>Run-length decode a vector</p>

<p>Given a vector <code>$x</code> of the numbers of instances of values <code>$y</code>, run-length decode to <code>$c</code>.</p>

<pre><code> rld($x,$y,$c=null);</code></pre>

<p>rld does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rle">rle</h2>

<pre><code>  Signature: (c(n); indx [o]a(m); [o]b(m))</code></pre>

<p>Run-length encode a vector</p>

<p>Given vector <code>$c</code>, generate a vector <code>$x</code> with the number of each element, and a vector <code>$y</code> of the unique values. New in PDL 2.017, only the elements up to the first instance of <code>0</code> in <code>$x</code> are returned, which makes the common use case of a 1-dimensional <code>$c</code> simpler. For broadcast operation, <code>$x</code> and <code>$y</code> will be large enough to hold the largest row of <code>$y</code>, and only the elements up to the first instance of <code>0</code> in each row of <code>$x</code> should be considered.</p>

<pre><code> $c = floor(4*random(10));
 rle($c,$x=null,$y=null);
 #or
 ($x,$y) = rle($c);

 #for $c of shape [10, 4]:
 $c = floor(4*random(10,4));
 ($x,$y) = rle($c);

 #to see the results of each row one at a time:
 foreach (0..$c-&gt;dim(1)-1){
  my ($as,$bs) = ($x(:,($_)),$y(:,($_)));
  my ($ta,$tb) = where($as,$bs,$as!=0); #only the non-zero elements of $x
  print $c(:,($_)) . &quot; rle==&gt; &quot; , ($ta,$tb) , &quot;\trld==&gt; &quot; . rld($ta,$tb) . &quot;\n&quot;;
 }

 # the inverse of (chance of all 6 3d6 rolls being &gt;= each possible sum)
 ($nrolls, $ndice, $dmax) = (6, 3, 6);
 ($x, $x1) = (allaxisvals(($dmax) x $ndice)+1)-&gt;sumover-&gt;flat-&gt;qsort-&gt;rle;
 $y = $x-&gt;cumusumover;
 $yprob1x = $y-&gt;slice(&#39;-1:0&#39;)-&gt;double / $y-&gt;slice(&#39;(-1)&#39;);
 $z = cat($x1, 1 / $yprob1x**$nrolls)-&gt;transpose;</code></pre>

<p>rle does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rlevec">rlevec</h2>

<pre><code>  Signature: (c(M,N); indx [o]a(N); [o]b(M,N))</code></pre>

<p>Run-length encode a set of vectors.</p>

<p>Higher-order rle(), for use with qsortvec().</p>

<p>Given set of vectors $c, generate a vector $a with the number of occurrences of each element (where an &quot;element&quot; is a vector of length $M ocurring in $c), and a set of vectors $b containing the unique values. As for rle(), only the elements up to the first instance of 0 in $a should be considered.</p>

<p>Can be used together with clump() to run-length encode &quot;values&quot; of arbitrary dimensions. Can be used together with rotate(), cat(), append(), and qsortvec() to count N-grams over a 1d PDL.</p>

<p>See also: <a href="#rle">&quot;rle&quot;</a>, <a href="./Ufunc.html#qsortvec">&quot;qsortvec&quot; in PDL::Ufunc</a>, <a href="./Primitive.html#uniqvec">&quot;uniqvec&quot; in PDL::Primitive</a> Contributed by Bryan Jurish &lt;moocow@cpan.org&gt;.</p>

<p>rlevec does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rldvec">rldvec</h2>

<pre><code>  Signature: (indx a(N); b(M,N); [o]c(M,N))</code></pre>

<p>Run-length decode a set of vectors, akin to a higher-order rld().</p>

<p>Given a vector $a() of the number of occurrences of each row, and a set $c() of row-vectors each of length $M, run-length decode to $c().</p>

<p>Can be used together with clump() to run-length decode &quot;values&quot; of arbitrary dimensions.</p>

<p>See also: <a href="#rld">&quot;rld&quot;</a>. Contributed by Bryan Jurish &lt;moocow@cpan.org&gt;.</p>

<p>rldvec does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rleseq">rleseq</h2>

<pre><code>  Signature: (c(N); indx [o]a(N); [o]b(N))</code></pre>

<p>Run-length encode a vector of subsequences.</p>

<p>Given a vector of $c() of concatenated variable-length, variable-offset subsequences, generate a vector $a containing the length of each subsequence and a vector $b containing the subsequence offsets. As for rle(), only the elements up to the first instance of 0 in $a should be considered.</p>

<p>See also <a href="#rle">&quot;rle&quot;</a>. Contributed by Bryan Jurish &lt;moocow@cpan.org&gt;.</p>

<p>rleseq does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rldseq">rldseq</h2>

<pre><code>  Signature: (indx a(N); b(N); [o]c(M))</code></pre>

<p>Run-length decode a subsequence vector.</p>

<p>Given a vector $a() of sequence lengths and a vector $b() of corresponding offsets, decode concatenation of subsequences to $c(), as for:</p>

<pre><code> $c = null;
 $c = $c-&gt;append($b($_)+sequence($a-&gt;type,$a($_))) foreach (0..($N-1));</code></pre>

<p>See also: <a href="#rld">&quot;rld&quot;</a>. Contributed by Bryan Jurish &lt;moocow@cpan.org&gt;.</p>

<p>rldseq does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rleND">rleND</h2>

<pre><code>  Signature: (data(@vdims,N); int [o]counts(N); [o]elts(@vdims,N))</code></pre>

<p>Run-length encode a set of (sorted) n-dimensional values.</p>

<p>Generalization of rle() and vv_rlevec(): given set of values $data, generate a vector $counts with the number of occurrences of each element (where an &quot;element&quot; is a matrix of dimensions @vdims ocurring as a sequential run over the final dimension in $data), and a set of vectors $elts containing the elements which begin a run. Really just a wrapper for clump() and rlevec().</p>

<p>See also: <a href="#rle">&quot;rle&quot;</a>, <a href="#rlevec">&quot;rlevec&quot;</a>. Contributed by Bryan Jurish &lt;moocow@cpan.org&gt;.</p>

<h2 id="rldND">rldND</h2>

<pre><code>  Signature: (int counts(N); elts(@vdims,N); [o]data(@vdims,N);)</code></pre>

<p>Run-length decode a set of (sorted) n-dimensional values.</p>

<p>Generalization of rld() and rldvec(): given a vector $counts() of the number of occurrences of each @vdims-dimensioned element, and a set $elts() of @vdims-dimensioned elements, run-length decode to $data().</p>

<p>Really just a wrapper for clump() and rldvec().</p>

<p>See also: <a href="#rld">&quot;rld&quot;</a>, <a href="#rldvec">&quot;rldvec&quot;</a>. Contributed by Bryan Jurish &lt;moocow@cpan.org&gt;.</p>

<h2 id="xchg">xchg</h2>

<pre><code>  Signature: (P(); C(); PDL_Indx n1; PDL_Indx n2)</code></pre>

<p>exchange two dimensions</p>

<p>Negative dimension indices count from the end.</p>

<p>The command</p>

<pre><code> $y = $x-&gt;xchg(2,3);</code></pre>

<p>creates <code>$y</code> to be like <code>$x</code> except that the dimensions 2 and 3 are exchanged with each other i.e.</p>

<pre><code> $y-&gt;at(5,3,2,8) == $x-&gt;at(5,3,8,2)</code></pre>

<p>xchg does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="reorder">reorder</h2>

<p>Re-orders the dimensions of a PDL based on the supplied list.</p>

<p>Similar to the <a href="#xchg">&quot;xchg&quot;</a> method, this method re-orders the dimensions of a PDL. While the <a href="#xchg">&quot;xchg&quot;</a> method swaps the position of two dimensions, the reorder method can change the positions of many dimensions at once.</p>

<pre><code> # Completely reverse the dimension order of a 6-Dim array.
 $reOrderedPDL = $pdl-&gt;reorder(5,4,3,2,1,0);</code></pre>

<p>The argument to reorder is an array representing where the current dimensions should go in the new array. In the above usage, the argument to reorder <code>(5,4,3,2,1,0)</code> indicates that the old dimensions (<code>$pdl</code>&#39;s dims) should be re-arranged to make the new pdl (<code>$reOrderPDL</code>) according to the following:</p>

<pre><code>   Old Position   New Position
   ------------   ------------
   5              0
   4              1
   3              2
   2              3
   1              4
   0              5</code></pre>

<p>You do not need to specify all dimensions, only a complete set starting at position 0. (Extra dimensions are left where they are). This means, for example, that you can reorder() the X and Y dimensions of an image, and not care whether it is an RGB image with a third dimension running across color plane.</p>

<p>Example:</p>

<pre><code> pdl&gt; $x = sequence(5,3,2);       # Create a 3-d Array
 pdl&gt; p $x
 [
  [
   [ 0  1  2  3  4]
   [ 5  6  7  8  9]
   [10 11 12 13 14]
  ]
  [
   [15 16 17 18 19]
   [20 21 22 23 24]
   [25 26 27 28 29]
  ]
 ]
 pdl&gt; p $x-&gt;reorder(2,1,0); # Reverse the order of the 3-D PDL
 [
  [
   [ 0 15]
   [ 5 20]
   [10 25]
  ]
  [
   [ 1 16]
   [ 6 21]
   [11 26]
  ]
  [
   [ 2 17]
   [ 7 22]
   [12 27]
  ]
  [
   [ 3 18]
   [ 8 23]
   [13 28]
  ]
  [
   [ 4 19]
   [ 9 24]
   [14 29]
  ]
 ]</code></pre>

<p>The above is a simple example that could be duplicated by calling <code>$x-&gt;xchg(0,2)</code>, but it demonstrates the basic functionality of reorder.</p>

<p>As this is an index function, any modifications to the result PDL will change the parent.</p>

<h2 id="mv">mv</h2>

<pre><code>  Signature: (P(); C(); PDL_Indx n1; PDL_Indx n2)</code></pre>

<p>move a dimension to another position</p>

<p>The command</p>

<pre><code> $y = $x-&gt;mv(4,1);</code></pre>

<p>creates <code>$y</code> to be like <code>$x</code> except that the dimension 4 is moved to the place 1, so:</p>

<pre><code> $y-&gt;at(1,2,3,4,5,6) == $x-&gt;at(1,5,2,3,4,6);</code></pre>

<p>The other dimensions are moved accordingly. Negative dimension indices count from the end.</p>

<p>mv does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="using">using</h2>

<p>Returns array of column numbers requested</p>

<pre><code> line $pdl-&gt;using(1,2);</code></pre>

<p>Plot, as a line, column 1 of <code>$pdl</code> vs. column 2</p>

<pre><code> pdl&gt; $pdl = rcols(&quot;file&quot;);
 pdl&gt; line $pdl-&gt;using(1,2);</code></pre>

<h2 id="diagonal">diagonal</h2>

<pre><code>  Signature: (P(); C(); PDL_Indx whichdims[])</code></pre>

<p>Returns the multidimensional diagonal over the specified dimensions.</p>

<p>The diagonal is placed at the first (by number) dimension that is diagonalized. The other diagonalized dimensions are removed. So if <code>$x</code> has dimensions <code>(5,3,5,4,6,5)</code> then after</p>

<pre><code> $d = $x-&gt;diagonal(dim1, dim2,...)</code></pre>

<pre><code> $y = $x-&gt;diagonal(0,2,5);</code></pre>

<p>the ndarray <code>$y</code> has dimensions <code>(5,3,4,6)</code> and <code>$y-&gt;at(2,1,0,1)</code> refers to <code>$x-&gt;at(2,1,2,0,1,2)</code>.</p>

<p>NOTE: diagonal doesn&#39;t handle broadcastids correctly. XXX FIX</p>

<pre><code> pdl&gt; $x = zeroes(3,3,3);
 pdl&gt; ($y = $x-&gt;diagonal(0,1))++;
 pdl&gt; p $x
 [
  [
   [1 0 0]
   [0 1 0]
   [0 0 1]
  ]
  [
   [1 0 0]
   [0 1 0]
   [0 0 1]
  ]
  [
   [1 0 0]
   [0 1 0]
   [0 0 1]
  ]
 ]</code></pre>

<p>diagonal does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="lags">lags</h2>

<pre><code>  Signature: (P(); C(); PDL_Indx nthdim;PDL_Indx step;PDL_Indx n)</code></pre>

<p>Returns an ndarray of lags to parent.</p>

<p>Usage:</p>

<pre><code>  $lags = $x-&gt;lags($nthdim,$step,$nlags);</code></pre>

<p>I.e. if <code>$x</code> contains</p>

<pre><code> [0,1,2,3,4,5,6,7]</code></pre>

<p>then</p>

<pre><code> $y = $x-&gt;lags(0,2,2);</code></pre>

<p>is a (5,2) matrix</p>

<pre><code> [2,3,4,5,6,7]
 [0,1,2,3,4,5]</code></pre>

<p>This order of returned indices is kept because the function is called &quot;lags&quot; i.e. the nth lag is n steps behind the original.</p>

<p><code>$step</code> and <code>$nlags</code> must be positive. <code>$nthdim</code> can be negative and will then be counted from the last dim backwards in the usual way (-1 = last dim).</p>

<p>lags does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="splitdim">splitdim</h2>

<pre><code>  Signature: (P(); C(); PDL_Indx nthdim;PDL_Indx nsp)</code></pre>

<p>Splits a dimension in the parent ndarray (opposite of <a href="./Core.html#clump">clump</a>). As of 2.076, throws exception if non-divisible <code>nsp</code> given, and can give negative <code>nthdim</code> which then counts backwards.</p>

<p>After</p>

<pre><code> $y = $x-&gt;splitdim(2,3);</code></pre>

<p>the expression</p>

<pre><code> $y-&gt;at(6,4,m,n,3,6) == $x-&gt;at(6,4,m+3*n)</code></pre>

<p>is always true (<code>m</code> has to be less than 3).</p>

<p>splitdim does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rotate">rotate</h2>

<pre><code>  Signature: (x(n); indx shift(); [oca]y(n))</code></pre>

<p>Shift vector elements along with wrap. Flows data back&amp;forth.</p>

<p>rotate does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="broadcastI">broadcastI</h2>

<pre><code>  Signature: (P(); C(); PDL_Indx id; PDL_Indx whichdims[])</code></pre>

<p>internal</p>

<p>Put some dimensions to a broadcastid.</p>

<pre><code> $y = $x-&gt;broadcastI(0,1,5); # broadcast over dims 1,5 in id 1</code></pre>

<p>broadcastI does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="unbroadcast">unbroadcast</h2>

<pre><code>  Signature: (P(); C(); PDL_Indx atind)</code></pre>

<p>All broadcasted dimensions are made real again.</p>

<p>See [TBD Doc] for details and examples.</p>

<p>unbroadcast does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="dice">dice</h2>

<p>Dice rows/columns/planes out of a PDL using indexes for each dimension.</p>

<p>This function can be used to extract irregular subsets along many dimension of a PDL, e.g. only certain rows in an image, or planes in a cube. This can of course be done with the usual dimension tricks but this saves having to figure it out each time!</p>

<p>This method is similar in functionality to the <a href="#slice">&quot;slice&quot;</a> method, but <a href="#slice">&quot;slice&quot;</a> requires that contiguous ranges or ranges with constant offset be extracted. ( i.e. <a href="#slice">&quot;slice&quot;</a> requires ranges of the form <code>1,2,3,4,5</code> or <code>2,4,6,8,10</code>). Because of this restriction, <a href="#slice">&quot;slice&quot;</a> is more memory efficient and slightly faster than dice</p>

<pre><code> $slice = $data-&gt;dice([0,2,6],[2,1,6]); # Dicing a 2-D array</code></pre>

<p>The arguments to dice are arrays (or 1D PDLs) for each dimension in the PDL. These arrays are used as indexes to which rows/columns/cubes,etc to dice-out (or extract) from the <code>$data</code> PDL.</p>

<p>Use <code>X</code> to select all indices along a given dimension (compare also <a href="./Core.html#mslice">mslice</a>). As usual (in slicing methods) trailing dimensions can be omitted implying <code>X</code>&#39;es for those.</p>

<pre><code> pdl&gt; $x = sequence(10,4)
 pdl&gt; p $x
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [10 11 12 13 14 15 16 17 18 19]
  [20 21 22 23 24 25 26 27 28 29]
  [30 31 32 33 34 35 36 37 38 39]
 ]
 pdl&gt; p $x-&gt;dice([1,2],[0,3]) # Select columns 1,2 and rows 0,3
 [
  [ 1  2]
  [31 32]
 ]
 pdl&gt; p $x-&gt;dice(X,[0,3])
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [30 31 32 33 34 35 36 37 38 39]
 ]
 pdl&gt; p $x-&gt;dice([0,2,5])
 [
  [ 0  2  5]
  [10 12 15]
  [20 22 25]
  [30 32 35]
 ]</code></pre>

<p>As this is an index function, any modifications to the slice will change the parent (use the <code>.=</code> operator).</p>

<h2 id="dice_axis">dice_axis</h2>

<p>Dice rows/columns/planes from a single PDL axis (dimension) using index along a specified axis</p>

<p>This function can be used to extract irregular subsets along any dimension, e.g. only certain rows in an image, or planes in a cube. This can of course be done with the usual dimension tricks but this saves having to figure it out each time!</p>

<pre><code> $slice = $data-&gt;dice_axis($axis,$index);</code></pre>

<pre><code> pdl&gt; $x = sequence(10,4)
 pdl&gt; $idx = pdl(1,2)
 pdl&gt; p $x-&gt;dice_axis(0,$idx) # Select columns
 [
  [ 1  2]
  [11 12]
  [21 22]
  [31 32]
 ]
 pdl&gt; $t = $x-&gt;dice_axis(1,$idx) # Select rows
 pdl&gt; $t.=0
 pdl&gt; p $x
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [ 0  0  0  0  0  0  0  0  0  0]
  [ 0  0  0  0  0  0  0  0  0  0]
  [30 31 32 33 34 35 36 37 38 39]
 ]</code></pre>

<p>The trick to using this is that the index selects elements along the dimensions specified, so if you have a 2D image <code>axis=0</code> will select certain <code>X</code> values - i.e. extract columns</p>

<p>As this is an index function, any modifications to the slice will change the parent.</p>

<h2 id="slice">slice</h2>

<pre><code>  Signature: (P(); C(); pdl_slice_args *arglist)</code></pre>

<pre><code>  $slice = $data-&gt;slice([2,3],&#39;x&#39;,[2,2,0],&quot;-1:1:-1&quot;, &quot;*3&quot;);</code></pre>

<p>Extract rectangular slices of an ndarray, from a string specifier, an array ref specifier, or a combination.</p>

<p><code>slice</code> is the main method for extracting regions of PDLs and manipulating their dimensionality. You can call it directly or via the <a href="./NiceSlice.html">NiceSlice</a> source prefilter that extends Perl syntax to include array slicing.</p>

<p><code>slice</code> can extract regions along each dimension of a source PDL, subsample or reverse those regions, dice each dimension by selecting a list of locations along it, or basic PDL indexing routine. The selected subfield remains connected to the original PDL via dataflow. In most cases this neither allocates more memory nor slows down subsequent operations on either of the two connected PDLs.</p>

<p>You pass in a list of arguments. Each term in the list controls the disposition of one axis of the source PDL and/or returned PDL. Each term can be a string-format cut specifier, a list ref that gives the same information without recourse to string manipulation, or a PDL with up to 1 dimension giving indices along that axis that should be selected.</p>

<p>If you want to pass in a single string specifier for the entire operation, you can pass in a comma-delimited list as the first argument. <code>slice</code> detects this condition and splits the string into a regular argument list. This calling style is fully backwards compatible with <code>slice</code> calls from before PDL 2.006.</p>

<p><b>STRING SYNTAX</b></p>

<p>If a particular argument to <code>slice</code> is a string, it is parsed as a selection, an affine slice, or a dummy dimension depending on the form. Leading or trailing whitespace in any part of each specifier is ignored (though it is not ignored within numbers).</p>

<dl>

<dt id="or-X----keep"><code>&#39;&#39;</code>, <code>:</code>, or <code>X</code> -- keep</dt>
<dd>

<p>The empty string, <code>:</code>, or <code>X</code> cause the entire corresponding dimension to be kept unchanged.</p>

</dd>
<dt id="n----selection"><code>&lt;n&gt;</code> -- selection</dt>
<dd>

<p>A single number alone causes a single index to be selected from the corresponding dimension. The dimension is kept (and reduced to size 1) in the output.</p>

</dd>
<dt id="n----selection-and-collapse"><code>(&lt;n&gt;)</code> -- selection and collapse</dt>
<dd>

<p>A single number in parenthesis causes a single index to be selected from the corresponding dimension. The dimension is discarded (completely eliminated) in the output.</p>

</dd>
<dt id="n:m----select-an-inclusive-range"><code>&lt;n&gt;:&lt;m&gt;</code> -- select an inclusive range</dt>
<dd>

<p>Two numbers separated by a colon selects a range of values from the corresponding axis, e.g. <code>3:4</code> selects elements 3 and 4 along the corresponding axis, and reduces that axis to size 2 in the output. Both numbers are regularized so that you can address the last element of the axis with an index of <code> -1 </code>. If, after regularization, the two numbers are the same, then exactly one element gets selected (just like the <code>&lt;n&gt;</code> case). If, after regulariation, the second number is lower than the first, then the resulting slice counts down rather than up -- e.g. <code>-1:0</code> will return the entire axis, in reversed order.</p>

</dd>
<dt id="n:m:s----select-a-range-with-explicit-step"><code>&lt;n&gt;:&lt;m&gt;:&lt;s&gt;</code> -- select a range with explicit step</dt>
<dd>

<p>If you include a third parameter, it is the stride of the extracted range. For example, <code>0:-1:2</code> will sample every other element across the complete dimension. Specifying a stride of 1 prevents autoreversal -- so to ensure that your slice is *always* forward you can specify, e.g., <code>2:$n:1</code>. In that case, an &quot;impossible&quot; slice gets an Empty PDL (with 0 elements along the corresponding dimension), so you can generate an Empty PDL with a slice of the form <code>2:1:1</code>.</p>

</dd>
<dt id="n----insert-a-dummy-dimension"><code>*&lt;n&gt;</code> -- insert a dummy dimension</dt>
<dd>

<p>Dummy dimensions aren&#39;t present in the original source and are &quot;mocked up&quot; to match dimensional slots, by repeating the data in the original PDL some number of times. An asterisk followed by a number produces a dummy dimension in the output, for example <code>*2</code> will generate a dimension of size 2 at the corresponding location in the output dim list. Omitting the number (and using just an asterisk) inserts a dummy dimension of size 1.</p>

</dd>
</dl>

<p><b>ARRAY REF SYNTAX</b></p>

<p>If you feed in an ARRAY ref as a slice term, then it can have 0-3 elements. The first element is the start of the slice along the corresponding dim; the second is the end; and the third is the stepsize. Different combinations of inputs give the same flexibility as the string syntax.</p>

<dl>

<dt id="keep-dim-intact"><code>[]</code> - keep dim intact</dt>
<dd>

<p>An empty ARRAY ref keeps the entire corresponding dim</p>

</dd>
<dt id="X---keep-dim-intact"><code>[ &#39;X&#39; ]</code> - keep dim intact</dt>
<dd>

</dd>
<dt id="n---generate-a-dummy-dim-of-size-n"><code>[ &#39;*&#39;,$n ]</code> - generate a dummy dim of size $n</dt>
<dd>

<p>If $n is missing, you get a dummy dim of size 1.</p>

</dd>
<dt id="dex-0---collapse-and-discard-dim"><code>[ $dex, , 0 ]</code> - collapse and discard dim</dt>
<dd>

<p><code>$dex</code> must be a single value. It is used to index the source, and the corresponding dimension is discarded.</p>

</dd>
<dt id="start-end---collect-inclusive-slice"><code>[ $start, $end ]</code> - collect inclusive slice</dt>
<dd>

<p>In the simple two-number case, you get a slice that runs up or down (as appropriate) to connect $start and $end.</p>

</dd>
<dt id="start-end-inc---collect-inclusive-slice"><code>[ $start, $end, $inc ]</code> - collect inclusive slice</dt>
<dd>

<p>The three-number case works exactly like the three-number string case above.</p>

</dd>
</dl>

<p><b>PDL args for dicing</b></p>

<p>If you pass in a 0- or 1-D PDL as a slicing argument, the corresponding dimension is &quot;diced&quot; -- you get one position along the corresponding dim, per element of the indexing PDL, e.g. <code>$x-&gt;slice( pdl(3,4,9))</code> gives you elements 3, 4, and 9 along the 0 dim of <code>$x</code>.</p>

<p>Because dicing is not an affine transformation, it is slower than direct slicing even though the syntax is convenient.</p>

<pre><code> $x-&gt;slice(&#39;1:3&#39;);  #  return the second to fourth elements of $x
 $x-&gt;slice(&#39;3:1&#39;);  #  reverse the above
 $x-&gt;slice(&#39;-2:1&#39;); #  return last-but-one to second elements of $x

 $x-&gt;slice([1,3]);  # Same as above three calls, but using array ref syntax
 $x-&gt;slice([3,1]);
 $x-&gt;slice([-2,1]);</code></pre>

<p>slice does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h1 id="BUGS">BUGS</h1>

<p>For the moment, you can&#39;t slice one of the zero-length dims of an empty ndarray. It is not clear how to implement this in a way that makes sense.</p>

<p>Many types of index errors are reported far from the indexing operation that caused them. This is caused by the underlying architecture: slice() sets up a mapping between variables, but that mapping isn&#39;t tested for correctness until it is used (potentially much later).</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) 1997 Tuomas J. Lukka. Contributions by Craig DeForest, deforest@boulder.swri.edu. Documentation contributions by David Mertens. All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


