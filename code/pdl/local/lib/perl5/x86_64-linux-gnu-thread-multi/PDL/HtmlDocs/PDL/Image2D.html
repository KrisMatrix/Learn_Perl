<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::Image2D - Miscellaneous 2D image processing functions</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#conv2d">conv2d</a></li>
      <li><a href="#med2d">med2d</a></li>
      <li><a href="#med2df">med2df</a></li>
      <li><a href="#box2d">box2d</a></li>
      <li><a href="#patch2d">patch2d</a></li>
      <li><a href="#patchbad2d">patchbad2d</a></li>
      <li><a href="#max2d_ind">max2d_ind</a></li>
      <li><a href="#centroid2d">centroid2d</a></li>
      <li><a href="#crop">crop</a></li>
      <li><a href="#cc8compt">cc8compt</a></li>
      <li><a href="#cc4compt">cc4compt</a></li>
      <li><a href="#ccNcompt">ccNcompt</a></li>
      <li><a href="#polyfill">polyfill</a></li>
      <li><a href="#pnpoly">pnpoly</a></li>
      <li><a href="#polyfillv">polyfillv</a></li>
      <li><a href="#rot2d">rot2d</a></li>
      <li><a href="#bilin2d">bilin2d</a></li>
      <li><a href="#rescale2d">rescale2d</a></li>
      <li><a href="#fitwarp2d">fitwarp2d</a></li>
      <li><a href="#applywarp2d">applywarp2d</a></li>
      <li><a href="#warp2d">warp2d</a></li>
      <li><a href="#warp2d_kernel">warp2d_kernel</a></li>
    </ul>
  </li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Image2D - Miscellaneous 2D image processing functions</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Miscellaneous 2D image processing functions - for want of anywhere else to put them.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use PDL::Image2D;</code></pre>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="conv2d">conv2d</h2>

<pre><code>  Signature: (a(m,n); kern(p,q); [o]b(m,n); int opt)</code></pre>

<p>2D convolution of an array with a kernel (smoothing)</p>

<p>For large kernels, using a FFT routine, such as <a href="./FFT.html#fftconvolve">fftconvolve()</a> in <code>PDL::FFT</code>, will be quicker.</p>

<pre><code> $new = conv2d $old, $kernel, {OPTIONS}</code></pre>

<pre><code> $smoothed = conv2d $image, ones(3,3), {Boundary =&gt; Reflect}</code></pre>

<pre><code> Boundary - controls what values are assumed for the image when kernel
            crosses its edge:
            =&gt; Default   - periodic boundary conditions
                           (i.e. wrap around axis)
            =&gt; Reflect   - reflect at boundary
            =&gt; Truncate  - truncate at boundary
            =&gt; Replicate - repeat boundary pixel values</code></pre>

<p>Unlike the FFT routines, conv2d is able to process bad values.</p>

<h2 id="med2d">med2d</h2>

<pre><code>  Signature: (a(m,n); kern(p,q); [o]b(m,n); double [t]tmp(pq); int opt)</code></pre>

<p>2D median-convolution of an array with a kernel (smoothing)</p>

<p>Note: only points in the kernel &gt;0 are included in the median, other points are weighted by the kernel value (medianing lots of zeroes is rather pointless)</p>

<pre><code> $new = med2d $old, $kernel, {OPTIONS}</code></pre>

<pre><code> $smoothed = med2d $image, ones(3,3), {Boundary =&gt; Reflect}</code></pre>

<pre><code> Boundary - controls what values are assumed for the image when kernel
            crosses its edge:
            =&gt; Default   - periodic boundary conditions (i.e. wrap around axis)
            =&gt; Reflect   - reflect at boundary
            =&gt; Truncate  - truncate at boundary
            =&gt; Replicate - repeat boundary pixel values</code></pre>

<p>Bad values are ignored in the calculation. If all elements within the kernel are bad, the output is set bad.</p>

<h2 id="med2df">med2df</h2>

<pre><code>  Signature: (a(m,n); [o]b(m,n); int __p_size; int __q_size; int opt)</code></pre>

<p>2D median-convolution of an array in a pxq window (smoothing)</p>

<p>Note: this routine does the median over all points in a rectangular window and is not quite as flexible as <code>med2d</code> in this regard but slightly faster instead</p>

<pre><code> $new = med2df $old, $xwidth, $ywidth, {OPTIONS}</code></pre>

<pre><code> $smoothed = med2df $image, 3, 3, {Boundary =&gt; Reflect}</code></pre>

<pre><code> Boundary - controls what values are assumed for the image when kernel
            crosses its edge:
            =&gt; Default   - periodic boundary conditions (i.e. wrap around axis)
            =&gt; Reflect   - reflect at boundary
            =&gt; Truncate  - truncate at boundary
            =&gt; Replicate - repeat boundary pixel values</code></pre>

<p>med2df does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="box2d">box2d</h2>

<pre><code>  Signature: (a(n,m); [o] b(n,m); int wx; int wy; int edgezero)</code></pre>

<p>fast 2D boxcar average</p>

<pre><code>  $smoothim = $im-&gt;box2d($wx,$wy,$edgezero=1);</code></pre>

<p>The edgezero argument controls if edge is set to zero (edgezero=1) or just keeps the original (unfiltered) values.</p>

<p><code>box2d</code> should be updated to support similar edge options as <code>conv2d</code> and <code>med2d</code> etc.</p>

<p>Boxcar averaging is a pretty crude way of filtering. For serious stuff better filters are around (e.g., use <a href="#conv2d">&quot;conv2d&quot;</a> with the appropriate kernel). On the other hand it is fast and computational cost grows only approximately linearly with window size.</p>

<p>box2d does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="patch2d">patch2d</h2>

<pre><code>  Signature: (a(m,n); int bad(m,n); [o]b(m,n))</code></pre>

<p>patch bad pixels out of 2D images using a mask</p>

<pre><code> $patched = patch2d $data, $bad;</code></pre>

<p><code>$bad</code> is a 2D mask array where 1=bad pixel 0=good pixel. Pixels are replaced by the average of their non-bad neighbours; if all neighbours are bad, the original data value is copied across.</p>

<p>This routine does not handle bad values - use <a href="#patchbad2d">&quot;patchbad2d&quot;</a> instead</p>

<h2 id="patchbad2d">patchbad2d</h2>

<pre><code>  Signature: (a(m,n); [o]b(m,n))</code></pre>

<p>patch bad pixels out of 2D images containing bad values</p>

<pre><code> $patched = patchbad2d $data;</code></pre>

<p>Pixels are replaced by the average of their non-bad neighbours; if all neighbours are bad, the output is set bad. If the input ndarray contains <i>no</i> bad values, then a straight copy is performed (see <a href="#patch2d">&quot;patch2d&quot;</a>).</p>

<p>patchbad2d handles bad values. The output ndarray <i>may</i> contain bad values, depending on the pattern of bad values in the input ndarray.</p>

<h2 id="max2d_ind">max2d_ind</h2>

<pre><code>  Signature: (a(m,n); [o]val(); int [o]x(); int[o]y())</code></pre>

<p>Return value/position of maximum value in 2D image</p>

<p>Contributed by Tim Jeness</p>

<p>Bad values are excluded from the search. If all pixels are bad then the output is set bad.</p>

<h2 id="centroid2d">centroid2d</h2>

<pre><code>  Signature: (im(m,n); x(); y(); box(); [o]xcen(); [o]ycen())</code></pre>

<p>Refine a list of object positions in 2D image by centroiding in a box</p>

<p><code>$box</code> is the full-width of the box, i.e. the window is <code>+/- $box/2</code>.</p>

<p>Bad pixels are excluded from the centroid calculation. If all elements are bad (or the pixel sum is 0 - but why would you be centroiding something with negatives in...) then the output values are set bad.</p>

<h2 id="crop">crop</h2>

<p>Return bounding box of given mask in an <code>indx</code> ndarray, so it can broadcast. Use other operations (such as <a href="./Bad.html#isgood">&quot;isgood&quot; in PDL::Bad</a>, or <a href="./Primitive.html#eqvec">&quot;eqvec&quot; in PDL::Primitive</a> with a colour vector) to create a mask suitable for your application.</p>

<pre><code>  $x1x2y1y2 = crop($image);</code></pre>

<h2 id="cc8compt">cc8compt</h2>

<p>Connected 8-component labeling of a binary image.</p>

<p>Connected 8-component labeling of 0,1 image - i.e. find separate segmented objects and fill object pixels with object number. 8-component labeling includes all neighboring pixels. This is just a front-end to ccNcompt. See also <a href="#cc4compt">&quot;cc4compt&quot;</a>.</p>

<pre><code> $segmented = cc8compt( $image &gt; $threshold );</code></pre>

<h2 id="cc4compt">cc4compt</h2>

<p>Connected 4-component labeling of a binary image.</p>

<p>Connected 4-component labeling of 0,1 image - i.e. find separate segmented objects and fill object pixels with object number. 4-component labling does not include the diagonal neighbors. This is just a front-end to ccNcompt. See also <a href="#cc8compt">&quot;cc8compt&quot;</a>.</p>

<pre><code> $segmented = cc4compt( $image &gt; $threshold );</code></pre>

<h2 id="ccNcompt">ccNcompt</h2>

<pre><code>  Signature: (a(m,n); int+ [o]b(m,n); int con)</code></pre>

<p>Connected component labeling of a binary image.</p>

<p>Connected component labeling of 0,1 image - i.e. find separate segmented objects and fill object pixels with object number. See also <a href="#cc4compt">&quot;cc4compt&quot;</a> and <a href="#cc8compt">&quot;cc8compt&quot;</a>.</p>

<p>The connectivity parameter must be 4 or 8.</p>

<pre><code> $segmented = ccNcompt( $image &gt; $threshold, 4);

 $segmented2 = ccNcompt( $image &gt; $threshold, 8);</code></pre>

<p>where the second parameter specifies the connectivity (4 or 8) of the labeling.</p>

<p>ccNcompt ignores the bad-value flag of the input ndarrays. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="polyfill">polyfill</h2>

<p>fill the area of the given polygon with the given colour.</p>

<p>This function works inplace, i.e. modifies <code>im</code>.</p>

<pre><code>  polyfill($im,$ps,$colour,[\%options]);</code></pre>

<p>The default method of determining which points lie inside of the polygon used is not as strict as the method used in <a href="#pnpoly">&quot;pnpoly&quot;</a>. Often, it includes vertices and edge points. Set the <code>Method</code> option to change this behaviour.</p>

<p>Method - Set the method used to determine which points lie in the polygon. =&gt; Default - internal PDL algorithm =&gt; pnpoly - use the <a href="#pnpoly">&quot;pnpoly&quot;</a> algorithm</p>

<pre><code>  # Make a convex 3x3 square of 1s in an image using the pnpoly algorithm
  $ps = pdl([3,3],[3,6],[6,6],[6,3]);
  polyfill($im,$ps,1,{&#39;Method&#39; =&gt;&#39;pnpoly&#39;});</code></pre>

<h2 id="pnpoly">pnpoly</h2>

<p>&#39;points in a polygon&#39; selection from a 2-D ndarray</p>

<pre><code>  $mask = $img-&gt;pnpoly($ps);

  # Old style, do not use
  $mask = pnpoly($x, $y, $px, $py);</code></pre>

<p>For a closed polygon determined by the sequence of points in {$px,$py} the output of pnpoly is a mask corresponding to whether or not each coordinate (x,y) in the set of test points, {$x,$y}, is in the interior of the polygon. This is the &#39;points in a polygon&#39; algorithm from <a href="http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html">http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html</a> and vectorized for PDL by Karl Glazebrook.</p>

<pre><code>  # define a 3-sided polygon (a triangle)
  $ps = pdl([3, 3], [20, 20], [34, 3]);

  # $tri is 0 everywhere except for points in polygon interior
  $tri = $img-&gt;pnpoly($ps);

  With the second form, the x and y coordinates must also be specified.
  B&lt; I&lt;THIS IS MAINTAINED FOR BACKWARD COMPATIBILITY ONLY&gt; &gt;.

  $px = pdl( 3, 20, 34 );
  $py = pdl( 3, 20,  3 );
  $x = $img-&gt;xvals;      # get x pixel coords
  $y = $img-&gt;yvals;      # get y pixel coords

  # $tri is 0 everywhere except for points in polygon interior
  $tri = pnpoly($x,$y,$px,$py);</code></pre>

<h2 id="polyfillv">polyfillv</h2>

<p>return the (dataflowed) area of an image described by a polygon</p>

<pre><code>  polyfillv($im,$ps,[\%options]);</code></pre>

<p>The default method of determining which points lie inside of the polygon used is not as strict as the method used in <a href="#pnpoly">&quot;pnpoly&quot;</a>. Often, it includes vertices and edge points. Set the <code>Method</code> option to change this behaviour.</p>

<p>Method - Set the method used to determine which points lie in the polygon. =&gt; Default - internal PDL algorithm =&gt; pnpoly - use the <a href="#pnpoly">&quot;pnpoly&quot;</a> algorithm</p>

<pre><code>  # increment intensity in area bounded by $poly using the pnpoly algorithm
  $im-&gt;polyfillv($poly,{&#39;Method&#39;=&gt;&#39;pnpoly&#39;})++; # legal in perl &gt;= 5.6

  # compute average intensity within area bounded by $poly using the default algorithm
  $av = $im-&gt;polyfillv($poly)-&gt;avg;</code></pre>

<h2 id="rot2d">rot2d</h2>

<pre><code>  Signature: (im(m,n); float angle(); bg(); int aa(); [o] om(p,q))</code></pre>

<p>rotate an image by given <code>angle</code></p>

<pre><code>  # rotate by 10.5 degrees with antialiasing, set missing values to 7
  $rot = $im-&gt;rot2d(10.5,7,1);</code></pre>

<p>This function rotates an image through an <code>angle</code> between -90 and + 90 degrees. Uses/doesn&#39;t use antialiasing depending on the <code>aa</code> flag. Pixels outside the rotated image are set to <code>bg</code>.</p>

<p>Code modified from pnmrotate (Copyright Jef Poskanzer) with an algorithm based on &quot;A Fast Algorithm for General Raster Rotation&quot; by Alan Paeth, Graphics Interface &#39;86, pp. 77-81.</p>

<p>Use the <code>rotnewsz</code> function to find out about the dimension of the newly created image</p>

<pre><code>  ($newcols,$newrows) = rotnewsz $oldn, $oldm, $angle;</code></pre>

<p><a href="./Transform.html">PDL::Transform</a> offers a more general interface to distortions, including rotation, with various types of sampling; but rot2d is faster.</p>

<p>rot2d ignores the bad-value flag of the input ndarrays. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="bilin2d">bilin2d</h2>

<pre><code>  Signature: (Int(n,m); O(q,p))</code></pre>

<p>Bilinearly maps the first ndarray in the second. The interpolated values are actually added to the second ndarray which is supposed to be larger than the first one.</p>

<p>bilin2d ignores the bad-value flag of the input ndarrays. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rescale2d">rescale2d</h2>

<pre><code>  Signature: (Int(m,n); O(p,q))</code></pre>

<p>The first ndarray is rescaled to the dimensions of the second (expanding or meaning values as needed) and then added to it in place. Nothing useful is returned.</p>

<p>If you want photometric accuracy or automatic FITS header metadata tracking, consider using <a href="./Transform.html#map">PDL::Transform::map</a> instead: it does these things, at some speed penalty compared to rescale2d.</p>

<p>rescale2d ignores the bad-value flag of the input ndarrays. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="fitwarp2d">fitwarp2d</h2>

<p>Find the best-fit 2D polynomial to describe a coordinate transformation.</p>

<pre><code>  ( $px, $py ) = fitwarp2d( $x, $y, $u, $v, $nf, { options } )</code></pre>

<p>Given a set of points in the output plane (<code>$u,$v</code>), find the best-fit (using singular-value decomposition) 2D polynomial to describe the mapping back to the image plane (<code>$x,$y</code>). The order of the fit is controlled by the <code>$nf</code> parameter (the maximum power of the polynomial is <code>$nf - 1</code>), and you can restrict the terms to fit using the <code>FIT</code> option.</p>

<p><code>$px</code> and <code>$py</code> are <code>np</code> by <code>np</code> element ndarrays which describe a polynomial mapping (of order <code>np-1</code>) from the <i>output</i> <code>(u,v)</code> image to the <i>input</i> <code>(x,y)</code> image:</p>

<pre><code>  x = sum(j=0,np-1) sum(i=0,np-1) px(i,j) * u^i * v^j
  y = sum(j=0,np-1) sum(i=0,np-1) py(i,j) * u^i * v^j</code></pre>

<p>The transformation is returned for the reverse direction (ie output to input image) since that is what is required by the <a href="#warp2d">warp2d()</a> routine. The <a href="#applywarp2d">applywarp2d()</a> routine can be used to convert a set of <code>$u,$v</code> points given <code>$px</code> and <code>$py</code>.</p>

<p>Options:</p>

<pre><code>  FIT     - which terms to fit? default ones(byte,$nf,$nf)</code></pre>

<dl>

<dt id="FIT">FIT</dt>
<dd>

<p><code>FIT</code> allows you to restrict which terms of the polynomial to fit: only those terms for which the FIT ndarray evaluates to true will be evaluated. If a 2D ndarray is sent in, then it is used for the x and y polynomials; otherwise <code>$fit-&gt;slice(&quot;:,:,(0)&quot;)</code> will be used for <code>$px</code> and <code>$fit-&gt;slice(&quot;:,:,(1)&quot;)</code> will be used for <code>$py</code>.</p>

</dd>
</dl>

<p>The number of points must be at least equal to the number of terms to fit (<code>$nf*$nf</code> points for the default value of <code>FIT</code>).</p>

<pre><code>  # points in original image
  $x = pdl( 0,   0, 100, 100 );
  $y = pdl( 0, 100, 100,   0 );
  # get warped to these positions
  $u = pdl( 10, 10, 90, 90 );
  $v = pdl( 10, 90, 90, 10 );
  #
  # shift of origin + scale x/y axis only
  $fit = byte( [ [1,1], [0,0] ], [ [1,0], [1,0] ] );
  ( $px, $py ) = fitwarp2d( $x, $y, $u, $v, 2, { FIT =&gt; $fit } );
  print &quot;px = ${px}py = $py&quot;;
  px =
  [
   [-12.5  1.25]
   [    0     0]
  ]
  py =
  [
   [-12.5     0]
   [ 1.25     0]
  ]
  #
  # Compared to allowing all 4 terms
  ( $px, $py ) = fitwarp2d( $x, $y, $u, $v, 2 );
  print &quot;px = ${px}py = $py&quot;;
  px =
  [
   [         -12.5           1.25]
   [  1.110223e-16 -1.1275703e-17]
  ]
  py =
  [
   [         -12.5  1.6653345e-16]
   [          1.25 -5.8546917e-18]
  ]

  # A higher-degree polynomial should not affect the answer much, but
  # will require more control points

  $x = $x-&gt;glue(0,pdl(50,12.5, 37.5, 12.5, 37.5));
  $y = $y-&gt;glue(0,pdl(50,12.5, 37.5, 37.5, 12.5));
  $u = $u-&gt;glue(0,pdl(73,20,40,20,40));
  $v = $v-&gt;glue(0,pdl(29,20,40,40,20));
  ( $px3, $py3 ) = fitwarp2d( $x, $y, $u, $v, 3 );
  print &quot;px3 =${px3}py3 =$py3&quot;;
  px3 =
  [
   [-6.4981162e+08       71034917     -726498.95]
   [      49902244     -5415096.7      55945.388]
   [    -807778.46      88457.191     -902.51612]
  ]
  py3 =
  [
   [-6.2732159e+08       68576392     -701354.77]
   [      48175125     -5227679.8      54009.114]
   [    -779821.18      85395.681     -871.27997]
  ]

  #This illustrates an important point about singular value
  #decompositions that are used in fitwarp2d: like all SVDs, the
  #rotation matrices are not unique, and so the $px and $py returned
  #by fitwarp2d are not guaranteed to be the &quot;simplest&quot; solution.
  #They do still work, though:

  ($x3,$y3) = applywarp2d($px3,$py3,$u,$v);
  print approx $x3,$x,1e-4;
  [1 1 1 1 1 1 1 1 1]
  print approx $y3,$y;
  [1 1 1 1 1 1 1 1 1]</code></pre>

<h2 id="applywarp2d">applywarp2d</h2>

<p>Transform a set of points using a 2-D polynomial mapping</p>

<pre><code>  ( $x, $y ) = applywarp2d( $px, $py, $u, $v )</code></pre>

<p>Convert a set of points (stored in 1D ndarrays <code>$u,$v</code>) to <code>$x,$y</code> using the 2-D polynomial with coefficients stored in <code>$px</code> and <code>$py</code>. See <a href="#fitwarp2d">fitwarp2d()</a> for more information on the format of <code>$px</code> and <code>$py</code>.</p>

<h2 id="warp2d">warp2d</h2>

<pre><code>  Signature: (img(m,n); double px(np,np); double py(np,np); [o] warp(m,n); { options })</code></pre>

<p>Warp a 2D image given a polynomial describing the <i>reverse</i> mapping.</p>

<pre><code>  $out = warp2d( $img, $px, $py, { options } );</code></pre>

<p>Apply the polynomial transformation encoded in the <code>$px</code> and <code>$py</code> ndarrays to warp the input image <code>$img</code> into the output image <code>$out</code>.</p>

<p>The format for the polynomial transformation is described in the documentation for the <a href="#fitwarp2d">fitwarp2d()</a> routine.</p>

<p>At each point <code>x,y</code>, the closest 16 pixel values are combined with an interpolation kernel to calculate the value at <code>u,v</code>. The interpolation is therefore done in the image, rather than Fourier, domain. By default, a <code>tanh</code> kernel is used, but this can be changed using the <code>KERNEL</code> option discussed below (the choice of kernel depends on the frequency content of the input image).</p>

<p>The routine is based on the <code>warping</code> command from the Eclipse data-reduction package - see http://www.eso.org/eclipse/ - and for further details on image resampling see Wolberg, G., &quot;Digital Image Warping&quot;, 1990, IEEE Computer Society Press ISBN 0-8186-8944-7).</p>

<p>Currently the output image is the same size as the input one, which means data will be lost if the transformation reduces the pixel scale. This will (hopefully) be changed soon.</p>

<pre><code>  $img = rvals(byte,501,501);
  imag $img, { JUSTIFY =&gt; 1 };
  #
  # use a not-particularly-obvious transformation:
  #   x = -10 + 0.5 * $u - 0.1 * $v
  #   y = -20 + $v - 0.002 * $u * $v
  #
  $px  = pdl( [ -10, 0.5 ], [ -0.1, 0 ] );
  $py  = pdl( [ -20, 0 ], [ 1, 0.002 ] );
  $wrp = warp2d( $img, $px, $py );
  #
  # see the warped image
  imag $warp, { JUSTIFY =&gt; 1 };</code></pre>

<p>The options are:</p>

<pre><code>  KERNEL - default value is tanh
  NOVAL  - default value is 0</code></pre>

<p><code>KERNEL</code> is used to specify which interpolation kernel to use (to see what these kernels look like, use the <a href="#warp2d_kernel">warp2d_kernel()</a> routine). The options are:</p>

<dl>

<dt id="tanh">tanh</dt>
<dd>

<p>Hyperbolic tangent: the approximation of an ideal box filter by the product of symmetric tanh functions.</p>

</dd>
<dt id="sinc">sinc</dt>
<dd>

<p>For a correctly sampled signal, the ideal filter in the fourier domain is a rectangle, which produces a <code>sinc</code> interpolation kernel in the spatial domain:</p>

<pre><code>  sinc(x) = sin(pi * x) / (pi * x)</code></pre>

<p>However, it is not ideal for the <code>4x4</code> pixel region used here.</p>

</dd>
<dt id="sinc2">sinc2</dt>
<dd>

<p>This is the square of the sinc function.</p>

</dd>
<dt id="lanczos">lanczos</dt>
<dd>

<p>Although defined differently to the <code>tanh</code> kernel, the result is very similar in the spatial domain. The Lanczos function is defined as</p>

<pre><code>  L(x) = sinc(x) * sinc(x/2)  if abs(x) &lt; 2
       = 0                       otherwise</code></pre>

</dd>
<dt id="hann">hann</dt>
<dd>

<p>This kernel is derived from the following function:</p>

<pre><code>  H(x) = a + (1-a) * cos(2*pi*x/(N-1))  if abs(x) &lt; 0.5*(N-1)
       = 0                                 otherwise</code></pre>

<p>with <code>a = 0.5</code> and N currently equal to 2001.</p>

</dd>
<dt id="hamming">hamming</dt>
<dd>

<p>This kernel uses the same <code>H(x)</code> as the Hann filter, but with <code>a = 0.54</code>.</p>

</dd>
</dl>

<p><code>NOVAL</code> gives the value used to indicate that a pixel in the output image does not map onto one in the input image.</p>

<h2 id="warp2d_kernel">warp2d_kernel</h2>

<p>Return the specified kernel, as used by <a href="#warp2d">&quot;warp2d&quot;</a></p>

<pre><code>  ( $x, $k ) = warp2d_kernel( $name )</code></pre>

<p>The valid values for <code>$name</code> are the same as the <code>KERNEL</code> option of <a href="#warp2d">warp2d()</a>.</p>

<pre><code>  line warp2d_kernel( &quot;hamming&quot; );</code></pre>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Copyright (C) Karl Glazebrook 1997 with additions by Robin Williams (rjrw@ast.leeds.ac.uk), Tim Jeness (timj@jach.hawaii.edu), and Doug Burke (burke@ifa.hawaii.edu).</p>

<p>All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


