<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::Graphics::Limits - derive limits for display purposes</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#limits">limits</a>
        <ul>
          <li><a href="#Data-Sets">Data Sets</a></li>
          <li><a href="#Errors">Errors</a></li>
          <li><a href="#Data-Transformation">Data Transformation</a></li>
          <li><a href="#Range-Algorithms">Range Algorithms</a></li>
          <li><a href="#User-Specified-Limits">User Specified Limits</a></li>
          <li><a href="#Return-Values">Return Values</a></li>
          <li><a href="#Miscellaneous">Miscellaneous</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Graphics::Limits - derive limits for display purposes</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Functions to derive limits for data for display purposes</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  use PDL::Graphics::Limits;</code></pre>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="limits">limits</h2>

<p><b>limits</b> derives global limits for one or more multi-dimensional sets of data for display purposes. It obtains minimum and maximum limits for each dimension based upon one of several algorithms.</p>

<pre><code>  @limits = limits( @datasets );
  @limits = limits( @datasets, \%attr );
  $limits = limits( @datasets );
  $limits = limits( @datasets, \%attr );</code></pre>

<h3 id="Data-Sets">Data Sets</h3>

<p>A data set is represented as a set of one dimensional vectors, one per dimension. All data sets must have the same dimensions. Multi-dimensional data sets are packaged as arrays or hashs; one dimensional data sets need not be. The different representations may be mixed, as long as the dimensions are presented in the same order. Vectors may be either scalars or ndarrays.</p>

<dl>

<dt id="One-dimensional-data-sets">One dimensional data sets</dt>
<dd>

<p>One dimensional data sets may be passed directly, with no additional packaging:</p>

<pre><code>  limits( $scalar, $ndarray );</code></pre>

</dd>
<dt id="Data-sets-as-arrays">Data sets as arrays</dt>
<dd>

<p>If the data sets are represented by arrays, each vectors in each array must have the same order:</p>

<pre><code>  @ds1 = ( $x1_pdl, $y1_pdl );
  @ds2 = ( $x2_pdl, $y2_pdl );</code></pre>

<p>They are passed by reference:</p>

<pre><code>  limits( \@ds1, \@ds2 );</code></pre>

</dd>
<dt id="Data-sets-as-hashes">Data sets as hashes</dt>
<dd>

<p>Hashes are passed by reference as well, but <i>must</i> be further embedded in arrays (also passed by reference), in order that the last one is not confused with the optional trailing attribute hash. For example:</p>

<pre><code>  limits( [ \%ds4, \%ds5 ], \%attr );</code></pre>

<p>If each hash uses the same keys to identify the data, the keys should be passed as an ordered array via the <code>VecKeys</code> attribute:</p>

<pre><code>  limits( [ \%h1, \%h2 ], { VecKeys =&gt; [ &#39;x&#39;, &#39;y&#39; ] } );</code></pre>

<p>If the hashes use different keys, each hash must be accompanied by an ordered listing of the keys, embedded in their own anonymous array:</p>

<pre><code>  [ \%h1 =&gt; ( &#39;x&#39;, &#39;y&#39; ) ], [ \%h2 =&gt; ( &#39;u&#39;, &#39;v&#39; ) ]</code></pre>

<p>Keys which are not explicitly identified are ignored.</p>

</dd>
</dl>

<h3 id="Errors">Errors</h3>

<p>Error bars must be taken into account when determining limits; care is especially needed if the data are to be transformed before plotting (for logarithmic plots, for example). Errors may be symmetric (a single value indicates the negative and positive going errors for a data point) or asymmetric (two values are required to specify the errors).</p>

<p>If the data set is specified as an array of vectors, vectors with errors should be embedded in an array. For symmetric errors, the error is given as a single vector (ndarray or scalar); for asymmetric errors, there should be two values (one of which may be <code>undef</code> to indicate a one-sided error bar):</p>

<pre><code>  @ds1 = ( $x,                  # no errors
           [ $y, $yerr ],       # symmetric errors
           [ $z, $zn, $zp ],    # asymmetric errors
           [ $u, undef, $up ],  # one-sided error bar
           [ $v, $vn, undef ],  # one-sided error bar
         );</code></pre>

<p>If the data set is specified as a hash of vectors, the names of the error bar keys are appended to the names of the data keys in the <code>VecKeys</code> designations. The error bar key names are always prefixed with a character indicating what kind of error they represent:</p>

<pre><code>        &lt; negative going errors
        &gt; positive going errors
        = symmetric errors</code></pre>

<p>(Column names may be separated by commas or white space.)</p>

<p>For example,</p>

<pre><code>  %ds1 = ( x =&gt; $x, xerr =&gt; $xerr, y =&gt; $y, yerr =&gt; $yerr );
  limits( [ \%ds1 ], { VecKeys =&gt; [ &#39;x =xerr&#39;, &#39;y =yerr&#39; ] } );</code></pre>

<p>To specify asymmetric errors, specify both the negative and positive going errors:</p>

<pre><code>  %ds1 = ( x =&gt; $x, xnerr =&gt; $xn, xperr =&gt; $xp,
           y =&gt; $y );
  limits( [ \%ds1 ], { VecKeys =&gt; [ &#39;x &lt;xnerr &gt;xperr&#39;, &#39;y&#39; ] } );</code></pre>

<p>For one-sided error bars, specify a column just for the side to be plotted:</p>

<pre><code>  %ds1 = ( x =&gt; $x, xnerr =&gt; $xn,
           y =&gt; $y, yperr =&gt; $yp );
  limits( [ \%ds1 ], { VecKeys =&gt; [ &#39;x &lt;xnerr&#39;, &#39;y &gt;yperr&#39; ] } );</code></pre>

<p>Data in hashes with different keys follow the same paradigm:</p>

<pre><code>  [ \%h1 =&gt; ( &#39;x =xerr&#39;, &#39;y =yerr&#39; ) ], [ \%h2 =&gt; ( &#39;u =uerr&#39;, &#39;v =verr&#39; ) ]</code></pre>

<p>In this case, the column names specific to a single data set override those specified via the <code>VecKeys</code> option.</p>

<pre><code>  limits( [ \%h1 =&gt; &#39;x =xerr&#39; ], { VecKeys =&gt; [ &#39;x &lt;xn &gt;xp&#39; ] } )</code></pre>

<p>In the case of a multi-dimensional data set, one must specify all of the keys:</p>

<pre><code>  limits( [ \%h1 =&gt; ( &#39;x =xerr&#39;, &#39;y =yerr&#39; ) ],
                  { VecKeys =&gt; [ &#39;x &lt;xn &gt;xp&#39;, &#39;y &lt;yp &gt;yp&#39; ] } )</code></pre>

<p>One can override only parts of the specifications:</p>

<pre><code>  limits( [ \%h1 =&gt; ( &#39;=xerr&#39;, &#39;=yerr&#39; ) ],
                  { VecKeys =&gt; [ &#39;x &lt;xn &gt;xp&#39;, &#39;y &lt;yp &gt;yp&#39; ] } )</code></pre>

<p>Use <code>undef</code> as a placeholder for those keys for which nothing need by overridden:</p>

<pre><code>  limits( [ \%h1 =&gt; undef, &#39;y =yerr&#39; ],
                  { VecKeys =&gt; [ &#39;x &lt;xn &gt;xp&#39;, &#39;y &lt;yp &gt;yp&#39; ] } )</code></pre>

<h3 id="Data-Transformation">Data Transformation</h3>

<p>Normally the data passed to <b>limits</b> should be in their final, transformed, form. For example, if the data will be displayed on a logarithmic scale, the logarithm of the data should be passed to <b>limits</b>. However, if error bars are also to be displayed, the <i>untransformed</i> data must be passed, as</p>

<pre><code>  log(data) + log(error) != log(data + error)</code></pre>

<p>Since the ranges must be calculated for the transformed values, <b>range</b> must be given the transformation function.</p>

<p>If all of the data sets will undergo the same transformation, this may be done with the <b>Trans</b> attribute, which is given a list of subroutine references, one for each element of a data set. An <code>undef</code> value may be used to indicate no transformation is to be performed. For example,</p>

<pre><code>  @ds1 = ( $x, $y );

  # take log of $x
  limits( \@ds1, { trans =&gt; [ \&amp;log10 ] } );

  # take log of $y
  limits( \@ds1, { trans =&gt; [ undef, \&amp;log10 ] } );</code></pre>

<p>If each data set has a different transformation, things are a bit more complicated. If the data sets are specified as arrays of vectors, vectors with transformations should be embedded in an array, with the <i>last</i> element the subroutine reference:</p>

<pre><code>  @ds1 = ( [ $x, \&amp;log10 ], $y );</code></pre>

<p>With error bars, this looks like this:</p>

<pre><code>  @ds1 = ( [ $x, $xerr, \&amp;log10 ], $y );
  @ds1 = ( [ $x, $xn, $xp, \&amp;log10 ], $y );</code></pre>

<p>If the <code>Trans</code> attribute is used in conjunction with individual data set transformations, the latter will override it. To explicitly indicate that a specific data set element has no transformation (normally only needed if <code>Trans</code> is used to specify a default) set the transformation subroutine reference to <code>undef</code>. In this case, the entire quad of data element, negative error, positive error, and transformation subroutine must be specified to avoid confusion:</p>

<pre><code>  [ $x, $xn, $xp, undef ]</code></pre>

<p>Note that $xn and $xp may be undef. For symmetric errors, simply set both <code>$xn</code> and <code>$xp</code> to the same value.</p>

<p>For data sets passed as hashes, the subroutine reference is an element in the hashes; the name of the corresponding key is added to the list of keys, preceded by the <code>&amp;</code> character:</p>

<pre><code>  %ds1 = ( x =&gt; $x, xerr =&gt; $xerr, xtrans =&gt; \&amp;log10,
           y =&gt; $y, yerr =&gt; $yerr );

  limits( [ \%ds1, \%ds2 ],
         { VecKeys =&gt; [ &#39;x =xerr &amp;xtrans&#39;,  &#39;y =yerr&#39; ] });
  limits( [ \%ds1 =&gt; &#39;x =xerr &amp;xtrans&#39;, &#39;y =yerr&#39; ] );</code></pre>

<p>If the <code>Trans</code> attribute is specified, and a key name is also specified via the <code>VecKeys</code> attribute or individually for a data set element, the latter will take precedence. For example,</p>

<pre><code>  $ds1{trans1} = \&amp;log10;
  $ds1{trans2} = \&amp;sqrt;

  # resolves to exp
  limits( [ \%ds1 ], { Trans =&gt; [ \&amp;exp ] });

  # resolves to sqrt
  limits( [ \%ds1 ], { Trans =&gt; [ \&amp;exp ],
                      VecKeys =&gt; [ &#39;x =xerr &amp;trans2&#39; ] });

  # resolves to log10
  limits( [ \%ds1 =&gt; &#39;&amp;trans1&#39; ], { Trans =&gt; [ \&amp;exp ],
                                   VecKeys =&gt; [ &#39;x =xerr &amp;trans2&#39; ] });</code></pre>

<p>To indicate that a particular vector should have no transformation, use a blank key:</p>

<pre><code>  limits( [ \%ds1 =&gt; ( &#39;x =xerr &amp;&#39;, &#39;y =yerr&#39; ) ], [\%ds2],
           { Trans =&gt; [ \&amp;log10 ] } );</code></pre>

<p>or set the hash element to <code>undef</code>:</p>

<pre><code>  $ds1{xtrans} = undef;</code></pre>

<h3 id="Range-Algorithms">Range Algorithms</h3>

<p>Sometimes all you want is to find the minimum and maximum values. However, for display purposes, it&#39;s often nice to have &quot;clean&quot; range bounds. To that end, <b>limits</b> produces a range in two steps. First it determines the bounds, then it cleans them up.</p>

<p>To specify the bounding algorithm, set the value of the <code>Bounds</code> key in the <code>%attr</code> hash to one of the following values:</p>

<dl>

<dt id="MinMax">MinMax</dt>
<dd>

<p>This indicates the raw minima and maxima should be used. This is the default.</p>

</dd>
<dt id="Zscale">Zscale</dt>
<dd>

<p>This is valid for two dimensional data only. The <code>Y</code> values are sorted, then fit to a line. The minimum and maximum values of the evaluated line are used for the <code>Y</code> bounds; the raw minimum and maximum values of the <code>X</code> data are used for the <code>X</code> bounds. This method is good in situations where there are &quot;spurious&quot; spikes in the <code>Y</code> data which would generate too large a dynamic range in the bounds. (Note that the <code>Zscale</code> algorithm is found in IRAF and DS9; its true origin is unknown to the author).</p>

</dd>
</dl>

<p>To specify the cleaning algorithm, set the value of the <code>Clean</code> key in the <code>%attr</code> hash to one of the following values:</p>

<dl>

<dt id="None">None</dt>
<dd>

<p>Perform no cleaning of the bounds.</p>

</dd>
<dt id="RangeFrac">RangeFrac</dt>
<dd>

<p>This is based upon the <code>PGPLOT</code> <b>pgrnge</b> function. It symmetrically expands the bounds (determined above) by a fractional amount:</p>

<pre><code>    $expand = $frac * ( $axis-&gt;{max} - $axis-&gt;{min} );
    $min = $axis-&gt;{min} - $expand;
    $max = $axis-&gt;{max} + $expand;</code></pre>

<p>The fraction may be specified in the <code>%attr</code> hash with the <code>RangeFrac</code> key. It defaults to <code>0.05</code>.</p>

<p>Because this is a symmetric expansion, a limit of <code>0.0</code> may be transformed into a negative number, which may be inappropriate. If the <code>ZeroFix</code> key is set to a non-zero value in the <code>%attr</code> hash, the cleaned boundary is set to <code>0.0</code> if it is on the other side of <code>0.0</code> from the above determined bounds. For example, If the minimum boundary value is <code>0.1</code>, and the cleaned boundary value is <code>-0.1</code>, the cleaned value will be set to <code>0.0</code>. Similarly, if the maximum value is <code>-0.1</code> and the cleaned value is <code>0.1</code>, it will be set to <code>0.0</code>.</p>

<p>This is the default clean algorithm.</p>

</dd>
<dt id="RoundPow">RoundPow</dt>
<dd>

<p>This is based upon the <code>PGPLOT</code> <b>pgrnd</b> routine. It determines a &quot;nice&quot; value, where &quot;nice&quot; is the closest round number to the boundary value, where a round number is 1, 2, or 5 times a power of 10.</p>

</dd>
</dl>

<h3 id="User-Specified-Limits">User Specified Limits</h3>

<p>To fully or partially override the automatically determined limits, use the <b>Limits</b> attribute. These values are used as input to the range algorithms.</p>

<p>The <b>Limits</b> attribute value may be either an array of arrayrefs, or a hash.</p>

<dl>

<dt id="Arrays">Arrays</dt>
<dd>

<p>The <b>Limits</b> value may be a reference to an array of arrayrefs, one per dimension, which contain the requested limits.</p>

<p>The dimensions should be ordered in the same way as the datasets. Each arrayref should contain two ordered values, the minimum and maximum limits for that dimension. The limits may have the undefined value if that limit is to be automatically determined. The limits should be transformed (or not) in the same fashion as the data.</p>

<p>For example, to specify that the second dimension&#39;s maximum limit should be fixed at a specified value:</p>

<pre><code>  Limits =&gt; [ [ undef, undef ], [ undef, $max ] ]</code></pre>

<p>Note that placeholder values are required for leading dimensions which are to be handled automatically. For convenience, if limits for a dimension are to be fully automatically determined, the placeholder arrayref may be empty. Also, trailing undefined limits may be omitted. The above example may be rewritten as:</p>

<pre><code>  Limits =&gt; [ [], [ undef, $max ] ]</code></pre>

<p>If the minimum value was specified instead of the maximum, the following would be acceptable:</p>

<pre><code>  Limits =&gt; [ [], [ $min ] ]</code></pre>

<p>If the data has but a single dimension, nested arrayrefs are not required:</p>

<pre><code>  Limits =&gt; [ $min, $max ]</code></pre>

</dd>
<dt id="Hashes">Hashes</dt>
<dd>

<p>Th <b>Limits</b> attribute value may be a hash; this can only be used in conjunction with the <b>VecKeys</b> attribute. If the data sets are represented by hashes which do not have common keys, then the user defined limits should be specified with arrays. The keys in the <b>Limits</b> hash should be the names of the data vectors in the <b>VecKeys</b>. Their values should be hashes with keys <code>min</code> and <code>max</code>, representing the minimum and maximum limits. Limits which have the value <code>undef</code> or which are not specified will be determined from the data. For example,</p>

<pre><code>  Limits =&gt; { x =&gt; { min =&gt; 30 }, y =&gt; { max =&gt; 22 } }</code></pre>

</dd>
</dl>

<h3 id="Return-Values">Return Values</h3>

<p>When called in a list context, it returns the minimum and maximum bounds for each axis:</p>

<pre><code>  @limits = ( $min_1, $max_1, $min_2, $max_2, ... );</code></pre>

<p>which makes life easier when using the <b>env</b> method:</p>

<pre><code>  $window-&gt;env( @limits );</code></pre>

<p>When called in a scalar context, it returns a hashref with the keys</p>

<pre><code>  axis1, ... axisN</code></pre>

<p>where <code>axisN</code> is the name of the Nth axis. If axis names have not been specified via the <code>VecKeys</code> element of <code>%attr</code>, names are concocted as <code>q1</code>, <code>q2</code>, etc. The values are hashes with keys <code>min</code> and <code>max</code>. For example:</p>

<pre><code>  { q1 =&gt; { min =&gt; 1, max =&gt; 2},
    q2 =&gt; { min =&gt; -33, max =&gt; 33 } }</code></pre>

<h3 id="Miscellaneous">Miscellaneous</h3>

<p>Normally <b>limits</b> complains if hash data sets don&#39;t contain specific keys for error bars or transformation functions. If, however, you&#39;d like to specify default values using the <code>%attr</code> argument, but there are data sets which don&#39;t have the data and you&#39;d rather not have to explicitly indicate that, set the <code>KeyCroak</code> attribute to zero. For example,</p>

<pre><code>  limits( [ { x =&gt; $x }, { x =&gt; $x1, xerr =&gt; $xerr } ],
         { VecKeys =&gt; [ &#39;x =xerr&#39; ] } );</code></pre>

<p>will generate an error because the first data set does not have an <code>xerr</code> key. Resetting <code>KeyCroak</code> will fix this:</p>

<pre><code>  limits( [ { x =&gt; $x }, { x =&gt; $x1, xerr =&gt; $xerr } ],
         { VecKeys =&gt; [ &#39;x =xerr&#39; ], KeyCroak =&gt; 0 } );</code></pre>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Diab Jerius, &lt;djerius@cpan.org&gt;</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (C) 2004 by the Smithsonian Astrophysical Observatory</p>

<p>This software is released under the GNU General Public License. You may find a copy at <a href="http://www.fsf.org/copyleft/gpl.html">http://www.fsf.org/copyleft/gpl.html</a>.</p>


</body>

</html>


