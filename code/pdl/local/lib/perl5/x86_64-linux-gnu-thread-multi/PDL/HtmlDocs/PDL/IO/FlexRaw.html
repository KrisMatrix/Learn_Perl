<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::IO::FlexRaw -- A flexible binary I/O format for PerlDL</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#glueflex">glueflex</a></li>
      <li><a href="#readflex">readflex</a></li>
      <li><a href="#mapflex">mapflex</a></li>
      <li><a href="#writeflex">writeflex</a></li>
      <li><a href="#writeflexhdr">writeflexhdr</a></li>
    </ul>
  </li>
  <li><a href="#BAD-VALUE-SUPPORT">BAD VALUE SUPPORT</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::IO::FlexRaw -- A flexible binary I/O format for PerlDL</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use PDL;
    use PDL::IO::FlexRaw;

    # To obtain the header for reading (if multiple files use the
    # same header, for example):
    #
    $hdr = PDL::IO::FlexRaw::_read_flexhdr(&quot;filename.hdr&quot;)

    ($x,$y,...) = readflex(&quot;filename&quot; [, $hdr])
    ($x,$y,...) = mapflex(&quot;filename&quot; [, $hdr] [, $opts])

    $hdr = writeflex($file, $pdl1, $pdl2,...)
    writeflexhdr($file, $hdr)

    # if $PDL::IO::FlexRaw::writeflexhdr is true and
    #    $file is a filename, writeflexhdr() is called automatically
    #
    $hdr = writeflex($file, $pdl1, $pdl2,...)  # need $hdr for something
    writeflex($file, $pdl1, $pdl2,...)         # ..if $hdr not needed</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>FlexRaw is a generic method for the input and output of `raw&#39; data arrays. In particular, it is designed to read output from FORTRAN 77 UNFORMATTED files and the low-level C write function, even if the files are compressed or gzipped. As in FastRaw, the data file is supplemented by a header file (although this can be replaced by the optional <code>$hdr</code> argument). More information can be included in the header file than for FastRaw -- the description can be extended to several data objects within a single input file.</p>

<p>For example, to read the output of a FORTRAN program</p>

<pre><code>    real*4 a(4,600,600)
    open (8,file=&#39;banana&#39;,status=&#39;new&#39;,form=&#39;unformatted&#39;)
    write (8) a
    close (8)</code></pre>

<p>the header file (`banana.hdr&#39;) could look like</p>

<pre><code>    # FlexRaw file header
    # Header word for F77 form=unformatted
    Byte 1 4
    # Data
    Float 3            # this is ignored
             4 600 600
    Byte 1 4           As is this, as we&#39;ve got all dims</code></pre>

<p>The data can then be input using</p>

<pre><code>    $x = (readflex(&#39;banana&#39;))[1];</code></pre>

<p>The format of the hdr file is an extension of that used by FastRaw. Comment lines (starting with #) are allowed, as are descriptive names (as elsewhere: byte, short, ushort, long, float, double) for the data types -- note that case is ignored by FlexRaw. After the type, one integer specifies the number of dimensions of the data `chunk&#39;, and subsequent integers the size of each dimension. So the specifier above (`Float 3 4 600 600&#39;) describes our FORTRAN array. A scalar can be described as `float 0&#39; (or `float 1 1&#39;, or `float 2 1 1&#39;, etc.).</p>

<p>When all the dimensions are read -- or a # appears after whitespace -- the rest of the current input line is ignored, <i>unless</i> badvalues are being read or written. In that case, the next token will be the string <code>badvalue</code> followed by the bad value used, if needed.</p>

<p>What about the extra 4 bytes at the head and tail, which we just threw away? These are added by FORTRAN (at least on Suns, Alphas and Linux), and specify the number of bytes written by each WRITE -- the same number is put at the start and the end of each chunk of data. You <i>may</i> need to know all this in some cases. In general, FlexRaw tries to handle it itself, if you simply add a line saying `f77&#39; to the header file, <i>before</i> any data specifiers:</p>

<pre><code>    # FlexRaw file header for F77 form=unformatted
    F77
    # Data
    Float 3
    4 600 600</code></pre>

<p>-- the redundancy in FORTRAN data files even allows FlexRaw to automatically deal with files written on other machines which use back-to-front byte ordering. This won&#39;t always work -- it&#39;s a 1 in 4 billion chance it won&#39;t, even if you regularly read 4Gb files! Also, it currently doesn&#39;t work for compressed files, so you can say `swap&#39; (again before any data specifiers) to make certain the byte order is swapped.</p>

<p>The optional <code>$hdr</code> argument allows the use of an anonymous array to give header information, rather than using a .hdr file. For example,</p>

<pre><code>    $header = [
        {Type =&gt; &#39;f77&#39;},
        {Type =&gt; &#39;float&#39;, NDims =&gt; 3, Dims =&gt; [ 4,600,600 ] }
    ];
    @a = readflex(&#39;banana&#39;,$header);</code></pre>

<p>reads our example file again. As a special case, when NDims is 1, Dims may be given as a scalar.</p>

<p>The highest dimension can be given as <code>undef</code>, which will read as many frames as possible of the given size (but only if only one hash-ref is given):</p>

<pre><code>  $video = readflex(&#39;frames.raw&#39;, [
    { Type=&gt;&#39;byte&#39;, NDims=&gt;4, Dims=&gt;[4,640,480,undef] },
  ]);</code></pre>

<p>Within PDL, readflex and writeflex can be used to write several pdls to a single file -- e.g.</p>

<pre><code>    use PDL;
    use PDL::IO::FlexRaw;

    @pdls = ($pdl1, $pdl2, ...);
    $hdr = writeflex(&quot;fname&quot;,@pdls);
    @pdl2 = readflex(&quot;fname&quot;,$hdr);

    writeflexhdr(&quot;fname&quot;,$hdr);  # not needed if $PDL::IO::FlexRaw::writeflexhdr is set
    @pdl3 = readflex(&quot;fname&quot;);</code></pre>

<p>-- <code>writeflex</code> produces the data file and returns the file header as an anonymous hash, which can be written to a .hdr file using <code>writeflexhdr</code>.</p>

<p>If the package variable <code>$PDL::IO::FlexRaw::writeflexhdr</code> is true, and the <code>writeflex</code> call was with a <i>filename</i> and not a handle, <code>writeflexhdr</code> will be called automatically (as done by <code>writefraw</code>.</p>

<p>The reading of compressed data is switched on automatically if the filename requested ends in .gz or .Z, or if the originally specified filename does not exist, but one of these compressed forms does.</p>

<p>If <code>writeflex</code> and <code>readflex</code> are given a reference to a file handle as a first parameter instead of a filename, then the data is read or written to the open filehandle. This gives an easy way to read an arbitrary slice in a big data volume, as in the following example:</p>

<pre><code>    use PDL;
    use PDL::IO::FastRaw;

    open(DATA, &quot;raw3d.dat&quot;);
    binmode(DATA);

    # assume we know the data size from an external source
    ($width, $height, $data_size) = (256,256, 4);

    my $slice_num = 64;   # slice to look at
    # Seek to slice
    seek(DATA, $width*$height*$data_size * $slice_num, 0);
    $pdl = readflex \*DATA, [{Dims=&gt;[$width, $height], Type=&gt;&#39;long&#39;}];</code></pre>

<p>WARNING: In later versions of perl (5.8 and up) you must be sure that your file is in &quot;raw&quot; mode (see the perlfunc man page entry for &quot;binmode&quot;, for details). Both readflex and writeflex automagically switch the file to raw mode for you -- but in code like the snipped above, you could end up seeking the wrong byte if you forget to make the binmode() call.</p>

<p><code>mapflex</code> memory maps, rather than reads, the data files. Its interface is similar to <code>readflex</code>. Extra options specify if the data is to be loaded `ReadOnly&#39;, if the data file is to be `Creat&#39;-ed anew on the basis of the header information or `Trunc&#39;-ated to the length of the data read. The extra speed of access brings with it some limitations: <code>mapflex</code> won&#39;t read compressed data, auto-detect f77 files, or read f77 files written by more than a single unformatted write statement. More seriously, data alignment constraints mean that <code>mapflex</code> cannot read some files, depending on the requirements of the host OS (it may also vary depending on the setting of the `uac&#39; flag on any given machine). You may have run into similar problems with common blocks in FORTRAN.</p>

<p>For instance, floating point numbers may have to align on 4 byte boundaries -- if the data file consists of 3 bytes then a float, it cannot be read. <code>mapflex</code> will warn about this problem when it occurs, and return the PDLs mapped before the problem arose. This can be dealt with either by reorganizing the data file (large types first helps, as a rule-of-thumb), or more simply by using <code>readflex</code>.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="glueflex">glueflex</h2>

<p>Append a single data item to an existing binary file written by <a href="#writeflex">&quot;writeflex&quot;</a>. Must be to the last data item in that file. Error if dims not compatible with existing data.</p>

<pre><code>    $hdr = glueflex($file, $pdl[, $hdr]); # or
    $hdr = glueflex(FILEHANDLE, $pdl[, $hdr]);
    # now you must call writeflexhdr()
    writeflexhdr($file, $hdr);</code></pre>

<p>or</p>

<pre><code>    $PDL::IO::FlexRaw::writeflexhdr = 1; # set so we don&#39;t have to call writeflexhdr
    $hdr = glueflex($file, $pdl[, $hdr])  # remember, $file must be filename
    glueflex($file, $pdl[, $hdr])         # remember, $file must be filename</code></pre>

<h2 id="readflex">readflex</h2>

<p>Read a binary file with flexible format specification</p>

<pre><code>    Usage:

    ($x,$y,...) = readflex(&quot;filename&quot; [, $hdr])
    ($x,$y,...) = readflex(FILEHANDLE [, $hdr])</code></pre>

<h2 id="mapflex">mapflex</h2>

<p>Memory map a binary file with flexible format specification</p>

<pre><code>    Usage:

    ($x,$y,...) = mapflex(&quot;filename&quot; [, $hdr] [, $opts])</code></pre>

<pre><code>    All of these options default to false unless set true:

    ReadOnly - Data should be readonly
    Creat    - Create file if it doesn&#39;t exist
    Trunc    - File should be truncated to a length that conforms
               with the header</code></pre>

<h2 id="writeflex">writeflex</h2>

<p>Write a binary file with flexible format specification</p>

<pre><code>    Usage:

    $hdr = writeflex($file, $pdl1, $pdl2,...) # or
    $hdr = writeflex(FILEHANDLE, $pdl1, $pdl2,...)
    # now you must call writeflexhdr()
    writeflexhdr($file, $hdr)</code></pre>

<p>or</p>

<pre><code>    $PDL::IO::FlexRaw::writeflexhdr = 1;  # set so we don&#39;t have to call writeflexhdr

    $hdr = writeflex($file, $pdl1, $pdl2,...)  # remember, $file must be filename
    writeflex($file, $pdl1, $pdl2,...)         # remember, $file must be filename</code></pre>

<h2 id="writeflexhdr">writeflexhdr</h2>

<p>Write the header file corresponding to a previous writeflex call</p>

<pre><code>    Usage:

    writeflexhdr($file, $hdr)

    $file or &quot;filename&quot; is the filename used in a previous writeflex
    If $file is actually a &quot;filename&quot; then writeflexhdr() will be
    called automatically if $PDL::IO::FlexRaw::writeflexhdr is true.
    If writeflex() was to a FILEHANDLE, you will need to call
    writeflexhdr() yourself since the filename cannot be determined
    (at least easily).</code></pre>

<h1 id="BAD-VALUE-SUPPORT">BAD VALUE SUPPORT</h1>

<p>As of PDL-2.4.8, <a href="./FlexRaw.html">PDL::IO::FlexRaw</a> has support for reading and writing pdls with <a href="../Bad.html">bad</a> values in them.</p>

<p>On <code>writeflex</code>, an ndarray argument with <code>$pdl-&gt;badflag == 1</code> will have the keyword/token &quot;badvalue&quot; added to the header file after the dimension list and an additional token with the bad value for that pdl if <code>$pdl-&gt;badvalue != $pdl-&gt;orig_badvalue</code>.</p>

<p>On <code>readflex</code>, a pdl with the &quot;badvalue&quot; token in the header will automatically have its <a href="../Bad.html#badflag">badflag</a> set and its <a href="../Bad.html#badvalue">badvalue</a> as well if it is not the standard default for that type.</p>

<p>The new badvalue support required some additions to the header structure. However, the interface is still being finalized. For reference the current <code>$hdr</code> looks like this:</p>

<pre><code>    $hdr = {
             Type =&gt; &#39;byte&#39;,    # data type
             NDims =&gt; 2,        # number of dimensions
             Dims =&gt; [640,480], # dims
             BadFlag =&gt; 1,      # is set/set badflag
             BadValue =&gt; undef, # undef==default
           };

    $badpdl = readflex(&#39;badpdl&#39;, [$hdr]);</code></pre>

<p>If you use bad values and try the new <a href="./FlexRaw.html">PDL::IO::FlexRaw</a> bad value support, please let us know via the perldl mailing list. Suggestions and feedback are also welcome.</p>

<h1 id="BUGS">BUGS</h1>

<p>The test on two dimensional byte arrays fail using g77 2.7.2, but not Sun f77. I hope this isn&#39;t my problem!</p>

<p>Assumes gzip is on the PATH.</p>

<p>Can&#39;t auto-swap compressed files, because it can&#39;t seek on them.</p>

<p>The header format may not agree with that used elsewhere.</p>

<p>Should it handle handles?</p>

<p>Mapflex should warn and fallback to reading on SEGV? Would have to make sure that the data was written back after it was `destroyed&#39;.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) Robin Williams &lt;rjrw@ast.leeds.ac.uk&gt; 1997. All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>

<p>Documentation contributions copyright (C) David Mertens, 2010.</p>


</body>

</html>


