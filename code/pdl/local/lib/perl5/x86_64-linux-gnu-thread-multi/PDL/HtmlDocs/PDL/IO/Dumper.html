<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::IO::Dumper -- data dumping for structs with PDLs</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#Bugs">Bugs</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#sdump">sdump</a></li>
      <li><a href="#fdump">fdump</a></li>
      <li><a href="#frestore">frestore</a></li>
      <li><a href="#deep_copy">deep_copy</a></li>
      <li><a href="#PDL::IO::Dumper::big_PDL">PDL::IO::Dumper::big_PDL</a></li>
      <li><a href="#PDL::IO::Dumper::stringify_PDL">PDL::IO::Dumper::stringify_PDL</a></li>
      <li><a href="#PDL::IO::Dumper::uudecode_PDL">PDL::IO::Dumper::uudecode_PDL</a></li>
      <li><a href="#PDL::IO::Dumper::dump_PDL">PDL::IO::Dumper::dump_PDL</a></li>
      <li><a href="#PDL::IO::Dumper::find_PDLs">PDL::IO::Dumper::find_PDLs</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::IO::Dumper -- data dumping for structs with PDLs</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This package allows you cleanly to save and restore complex data structures which include PDLs, as ASCII strings and/or transportable ASCII files. It exports four functions into your namespace: sdump, fdump, frestore, and deep_copy.</p>

<p>PDL::IO::Dumper traverses the same types of structure that Data::Dumper knows about, because it uses a call to Data::Dumper. Unlike Data::Dumper it doesn&#39;t crash when accessing PDLs.</p>

<p>The PDL::IO::Dumper routines have a slightly different syntax than Data::Dumper does: you may only dump a single scalar perl expression rather than an arbitrary one. Of course, the scalar may be a ref to whatever humongous pile of spaghetti you want, so that&#39;s no big loss.</p>

<p>The output string is intended to be about as readable as Dumper&#39;s output is for non-PDL expressions. To that end, small PDLs (up to 8 elements) are stored as inline perl expressions, midsized PDLs (up to 200 elements) are stored as perl expressions above the main data structure, and large PDLs are stored as FITS files that are uuencoded and included in the dump string.</p>

<p>No attempt is made to shrink the output string -- for example, inlined PDL expressions all include explicit reshape() and typecast commands, and uuencoding expands stuff by a factor of about 1.5. So your data structures will grow when you dump them.</p>

<h1 id="Bugs">Bugs</h1>

<p>It&#39;s still possible to break this code and cause it to dump core, for the same reason that Data::Dumper crashes. In particular, other external-hook variables aren&#39;t recognized (for that a more universal Dumper would be needed) and will still exercise the Data::Dumper crash. This is by choice: (A) it&#39;s difficult to recognize which objects are actually external, and (B) most everyday objects are quite safe.</p>

<p>Another shortfall of Data::Dumper is that it doesn&#39;t recognize tied objects. This might be a Good Thing or a Bad Thing depending on your point of view, but it means that PDL::IO::Dumper includes a kludge to handle the tied Astro::FITS::Header objects associated with FITS headers (see the rfits documentation in PDL::IO::Misc for details).</p>

<p>There&#39;s currently no reference recursion detection, so a non-treelike reference topology will cause Dumper to buzz forever. That will likely be fixed in a future version. Meanwhile a warning message finds likely cases.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="sdump">sdump</h2>

<p>Dump a data structure to a string.</p>

<pre><code>  use PDL::IO::Dumper;
  $s = sdump(&lt;VAR&gt;);
  ...
  &lt;VAR&gt; = eval $s;</code></pre>

<p>sdump dumps a single complex data structure into a string. You restore the data structure by eval-ing the string. Since eval is a builtin, no convenience routine exists to use it.</p>

<h2 id="fdump">fdump</h2>

<p>Dump a data structure to a file</p>

<pre><code>  use PDL::IO::Dumper;
  fdump(&lt;VAR&gt;,$filename);
  ...
  &lt;VAR&gt; = frestore($filename);</code></pre>

<p>fdump dumps a single complex data structure to a file. You restore the data structure by eval-ing the perl code put in the file. A convenience routine (frestore) exists to do it for you.</p>

<p>I suggest using the extension &#39;.pld&#39; or (for non-broken OS&#39;s) &#39;.pdld&#39; to distinguish Dumper files. That way they are reminiscent of .pl files for perl, while still looking a little different so you can pick them out. You can certainly feed a dump file straight into perl (for syntax checking) but it will not do much for you, just build your data structure and exit.</p>

<h2 id="frestore">frestore</h2>

<p>Restore a dumped file</p>

<pre><code>  use PDL::IO::Dumper;
  fdump(&lt;VAR&gt;,$filename);
  ...
  &lt;VAR&gt; = frestore($filename);</code></pre>

<p>frestore() is a convenience function that just reads in the named file and executes it in an eval. It&#39;s paired with fdump().</p>

<h2 id="deep_copy">deep_copy</h2>

<p>Convenience function copies a complete perl data structure by the brute force method of &quot;eval sdump&quot;.</p>

<h2 id="PDL::IO::Dumper::big_PDL">PDL::IO::Dumper::big_PDL</h2>

<p>Identify whether a PDL is ``big&#39;&#39; [Internal routine]</p>

<p>Internal routine takes a PDL and returns a boolean indicating whether it&#39;s small enough for direct insertion into the dump string. If 0, it can be inserted. Larger numbers yield larger scopes of PDL. 1 implies that it should be broken out but can be handled with a couple of perl commands; 2 implies full uudecode treatment.</p>

<p>PDLs with Astro::FITS::Header objects as headers are taken to be FITS files and are always treated as huge, regardless of size.</p>

<h2 id="PDL::IO::Dumper::stringify_PDL">PDL::IO::Dumper::stringify_PDL</h2>

<p>Turn a PDL into a 1-part perl expr [Internal routine]</p>

<p>Internal routine that takes a PDL and returns a perl string that evals to the PDL. It should be used with care because it doesn&#39;t dump headers and it doesn&#39;t check number of elements. The point here is that numbers are dumped with the correct precision for their storage class. Things we don&#39;t know about get stringified element-by-element by their builtin class, which is probably not a bad guess.</p>

<h2 id="PDL::IO::Dumper::uudecode_PDL">PDL::IO::Dumper::uudecode_PDL</h2>

<p>Recover a PDL from a uuencoded string [Internal routine]</p>

<p>This routine encapsulates uudecoding of the dumped string for large ndarrays.</p>

<h2 id="PDL::IO::Dumper::dump_PDL">PDL::IO::Dumper::dump_PDL</h2>

<p>Generate 1- or 2-part expr for a PDL [Internal routine]</p>

<p>Internal routine that produces commands defining a PDL. You supply (&lt;PDL&gt;, &lt;name&gt;) and get back two strings: a prepended command string and an expr that evaluates to the final PDL. PDL is the PDL you want to dump. &lt;inline&gt; is a flag whether dump_PDL is being called inline or before the inline dump string (0 for before; 1 for in). &lt;name&gt; is the name of the variable to be assigned (for medium and large PDLs, which are defined before the dump string and assigned unique IDs).</p>

<h2 id="PDL::IO::Dumper::find_PDLs">PDL::IO::Dumper::find_PDLs</h2>

<p>Walk a data structure and dump PDLs [Internal routine]</p>

<p>Walks the original data structure and generates appropriate exprs for each PDL. The exprs are inserted into the Data::Dumper output string. You shouldn&#39;t call this unless you know what you&#39;re doing. (see sdump, above).</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright 2002, Craig DeForest.</p>

<p>This code may be distributed under the same terms as Perl itself (license available at <a href="http://www.perl.org">http://www.perl.org</a>). Copying, reverse engineering, distribution, and modification are explicitly allowed so long as this notice is preserved intact and modified versions are clearly marked as such.</p>

<p>This package comes with NO WARRANTY.</p>


</body>

</html>


