<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::IO::Pnm -- pnm format I/O for PDL</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#pnminraw">pnminraw</a></li>
      <li><a href="#pnminascii">pnminascii</a></li>
      <li><a href="#pnmout">pnmout</a></li>
      <li><a href="#rpnm">rpnm</a></li>
      <li><a href="#wpnm">wpnm</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::IO::Pnm -- pnm format I/O for PDL</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>  use PDL::IO::Pnm;
  $im = wpnm $pdl, $file, $format[, $raw];
  rpnm $stack-&gt;slice(&#39;:,:,:,(0)&#39;),&quot;PDL.ppm&quot;;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>pnm I/O for PDL.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="pnminraw">pnminraw</h2>

<pre><code>  Signature: (type(); byte+ [o] im(m,n); int ms =&gt; m; int ns =&gt; n;
                        int isbin; PerlIO *fp)</code></pre>

<p>Read in a raw pnm file.</p>

<p>read a raw pnm file. The <code>type</code> argument is only there to determine the type of the operation when creating <code>im</code> or trigger the appropriate type conversion (maybe we want a byte+ here so that <code>im</code> follows <i>strictly</i> the type of <code>type</code>).</p>

<p>pnminraw does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="pnminascii">pnminascii</h2>

<pre><code>  Signature: (type(); byte+ [o] im(m,n); int ms =&gt; m; int ns =&gt; n;
                        int format; PerlIO *fp)</code></pre>

<p>Read in an ascii pnm file.</p>

<p>pnminascii does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="pnmout">pnmout</h2>

<pre><code>  Signature: (a(m); int israw; int isbin; PerlIO *fp)</code></pre>

<p>Write a line of pnm data.</p>

<p>This function is implemented this way so that broadcasting works naturally.</p>

<p>pnmout does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rpnm">rpnm</h2>

<p>Read a pnm (portable bitmap/pixmap, pbm/ppm) file into an ndarray.</p>

<pre><code>  Usage:  $im = rpnm $file;</code></pre>

<p>Reads a file (or open file-handle) in pnm format (ascii or raw) into a pdl (magic numbers P1-P6). Based on the input format it returns pdls with arrays of size (width,height) if binary or grey value data (pbm and pgm) or (3,width,height) if rgb data (ppm). This also means for a palette image that the distinction between an image and its lookup table is lost which can be a problem in cases (but can hardly be avoided when using netpbm/pbmplus). Datatype is dependent on the maximum grey/color-component value (for raw and binary formats always PDL_B). rpnm tries to read chopped files by zero padding the missing data (well it currently doesn&#39;t, it barfs; I&#39;ll probably fix it when it becomes a problem for me ;). You can also read directly into an existing pdl that has to have the right size(!). This can come in handy when you want to read a sequence of images into a datacube.</p>

<p>For details about the formats see appropriate manpages that come with the netpbm/pbmplus packages.</p>

<pre><code>  $stack = zeroes(byte,3,500,300,4);
  rpnm $stack-&gt;slice(&#39;:,:,:,(0)&#39;),&quot;PDL.ppm&quot;;</code></pre>

<p>reads an rgb image (that had better be of size (500,300)) into the first plane of a 3D RGB datacube (=4D pdl datacube). You can also do inplace transpose/inversion that way.</p>

<h2 id="wpnm">wpnm</h2>

<p>Write a pnm (portable bitmap/pixmap, pbm/ppm) file into a file or open file-handle.</p>

<pre><code>  Usage:  $im = wpnm $pdl, $file, $format[, $raw];</code></pre>

<p>Writes data in a pdl into pnm format (ascii or raw) (magic numbers P1-P6). The $format is required (normally produced by <b>wpic</b>) and routine just checks if data is compatible with that format. All conversions should already have been done. If possible, usage of <b>wpic</b> is preferred. Currently RAW format is chosen if compliant with range of input data. Explicit control of ASCII/RAW is possible through the optional $raw argument. If RAW is set to zero it will enforce ASCII mode. Enforcing RAW is somewhat meaningless as the routine will always try to write RAW format if the data range allows (but maybe it should reduce to a RAW supported type when RAW == &#39;RAW&#39;?). For details about the formats consult appropriate manpages that come with the netpbm/pbmplus packages.</p>

<h1 id="BUGS">BUGS</h1>

<p><code>rpnm</code> currently relies on the fact that the header is separated from the image data by a newline. This is not required by the p[bgp]m formats (in fact any whitespace is allowed) but most of the pnm writers seem to comply with that. Truncated files are currently treated ungracefully (<code>rpnm</code> just barfs).</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) 1996,1997 Christian Soeller &lt;c.soeller@auckland.ac.nz&gt; All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


