<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::MATLAB - A guide for MATLAB users.</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#INTRODUCTION">INTRODUCTION</a></li>
  <li><a href="#Perl">Perl</a></li>
  <li><a href="#TERMINOLOGY:-NDARRAY">TERMINOLOGY: NDARRAY</a></li>
  <li><a href="#COMMAND-WINDOW-AND-IDE">COMMAND WINDOW AND IDE</a>
    <ul>
      <li><a href="#PDL-interactive-shell">PDL interactive shell</a></li>
      <li><a href="#Writing-PDL-programs">Writing PDL programs</a></li>
      <li><a href="#New:-Flexible-syntax">New: Flexible syntax</a></li>
    </ul>
  </li>
  <li><a href="#MODULES-FOR-MATLAB-USERS">MODULES FOR MATLAB USERS</a></li>
  <li><a href="#BASIC-FEATURES">BASIC FEATURES</a>
    <ul>
      <li><a href="#General-gotchas">General &quot;gotchas&quot;</a></li>
      <li><a href="#Creating-ndarrays">Creating ndarrays</a></li>
      <li><a href="#Matrix-Operations">Matrix Operations</a></li>
      <li><a href="#Functions-that-aggregate-data">Functions that aggregate data</a></li>
      <li><a href="#Higher-dimensional-data-sets">Higher dimensional data sets</a></li>
      <li><a href="#Loop-Structures">Loop Structures</a></li>
      <li><a href="#ndarrays-vs-Perl-Arrays">ndarrays vs Perl Arrays</a></li>
      <li><a href="#Conditionals">Conditionals</a></li>
      <li><a href="#TIMTOWDI-There-Is-More-Than-One-Way-To-Do-It">TIMTOWDI (There Is More Than One Way To Do It)</a></li>
      <li><a href="#Functions">Functions</a></li>
    </ul>
  </li>
  <li><a href="#ADDITIONAL-FEATURES">ADDITIONAL FEATURES</a>
    <ul>
      <li><a href="#ASCII-File-IO">ASCII File IO</a></li>
      <li><a href="#Data-structures">Data structures</a></li>
      <li><a href="#Performance">Performance</a></li>
      <li><a href="#Plotting">Plotting</a></li>
      <li><a href="#Writing-GUIs">Writing GUIs</a></li>
      <li><a href="#Simulink">Simulink</a></li>
    </ul>
  </li>
  <li><a href="#COMPARISON:-REPEATED-COPY-OF-MATRIX">COMPARISON: REPEATED COPY OF MATRIX</a></li>
  <li><a href="#COMPARISON:-FLOYD-WARSHALL-ALGORITHM">COMPARISON: FLOYD-WARSHALL ALGORITHM</a>
    <ul>
      <li><a href="#PDL-version">PDL version</a></li>
      <li><a href="#MATLAB-version">MATLAB version</a></li>
    </ul>
  </li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::MATLAB - A guide for MATLAB users.</p>

<h1 id="INTRODUCTION">INTRODUCTION</h1>

<p>If you are a MATLAB user, this page is for you. It explains the key differences between MATLAB and PDL to help you get going as quickly as possible.</p>

<p><b>This document is not a tutorial</b>. For that, go to <a>PDL::QuickStart</a>. This document <b>complements</b> the Quick Start guide, as it highlights the key differences between MATLAB and PDL.</p>

<h1 id="Perl">Perl</h1>

<p>The key differences between MATLAB and PDL are broadcasting, and <b>Perl</b>.</p>

<p>Broadcasting means you can get a reference to just a part of your data, and operate on it in a way that makes sense for your application. Those operations will be reflected in the original data.</p>

<p>Perl is a general purpose programming language with thousands of modules freely available on the web. PDL is an extension of Perl. This gives PDL programs access to more features than most numerical tools can dream of. At the same time, most syntax differences between MATLAB and PDL are a result of its Perl foundation.</p>

<p><b>You do not have to learn much Perl to be effective with PDL</b>. But if you wish to learn Perl, there is excellent documentation available on-line (<a href="http://perldoc.perl.org">http://perldoc.perl.org</a>) or through the command <code>perldoc perl</code>. There is also a beginner&#39;s portal (<a href="http://perl-begin.org">http://perl-begin.org</a>).</p>

<p>Perl&#39;s module repository is called CPAN (<a href="http://www.cpan.org">http://www.cpan.org</a>) and it has a vast array of modules. Run <code>perldoc cpan</code> for more information.</p>

<h1 id="TERMINOLOGY:-NDARRAY">TERMINOLOGY: NDARRAY</h1>

<p>MATLAB typically refers to vectors, matrices, and arrays. Perl already has arrays, and the terms &quot;vector&quot; and &quot;matrix&quot; typically refer to one- and two-dimensional collections of data. Having no good term to describe their object, PDL developers coined the term &quot;<i>ndarray</i>&quot; to give a name to their data type.</p>

<p>An <i>ndarray</i> consists of a series of numbers organized as an N-dimensional data set. ndarrays provide efficient storage and fast computation of large N-dimensional matrices. They are highly optimized for numerical work.</p>

<p>For more information, see &quot;<b>ndarrays vs Perl Arrays</b>&quot; later in this document.</p>

<h1 id="COMMAND-WINDOW-AND-IDE">COMMAND WINDOW AND IDE</h1>

<p>Unlike MATLAB, PDL does not come with a dedicated IDE. It does however come with an interactive shell and you can use a Perl IDE to develop PDL programs.</p>

<h2 id="PDL-interactive-shell">PDL interactive shell</h2>

<p>To start the interactive shell, open a terminal and run <code>perldl</code> or <code>pdl2</code>. As in MATLAB, the interactive shell is the best way to learn the language. To exit the shell, type <code>exit</code>, just like MATLAB.</p>

<h2 id="Writing-PDL-programs">Writing PDL programs</h2>

<p>One popular IDE for Perl is called Padre (<a href="http://padre.perlide.org">http://padre.perlide.org</a>). It is cross platform and easy to use.</p>

<p>Whenever you write a stand-alone PDL program (i.e. outside the <code>perldl</code> or <code>pdl2</code> shell) you must start the program with <code>use PDL;</code>. This command imports the PDL module into Perl. Here is a sample PDL program:</p>

<pre><code>  use PDL;             # Import main PDL module.
  use PDL::NiceSlice;  # Import additional PDL module.
  use PDL::AutoLoader; # Import additional PDL module.

  $y = pdl [2,3,4];              # Statements end in semicolon.
  $A = pdl [ [1,2,3],[4,5,6] ];  # 2-dimensional matrix.

  print $A x $y-&gt;transpose;</code></pre>

<p>Save this file as <code>myprogram.pl</code> and run it with:</p>

<pre><code>  perl myprogram.pl</code></pre>

<h2 id="New:-Flexible-syntax">New: Flexible syntax</h2>

<p>In current versions of PDL (version 2.4.7 or later) there is a flexible matrix syntax that can look extremely similar to MATLAB:</p>

<p>1) Use spaces to separate elements:</p>

<pre><code>  $y = pdl q[ 2 3 4 ];</code></pre>

<p>2) Use a &#39;;&#39; to delimit rows:</p>

<pre><code>  $A = pdl q[ 1,2,3 ; 4,5,6 ];</code></pre>

<p>Basically, as long as you put a <code>q</code> in front of the opening bracket, PDL should &quot;do what you mean&quot;. So you can write in a syntax that is more comfortable for you.</p>

<h1 id="MODULES-FOR-MATLAB-USERS">MODULES FOR MATLAB USERS</h1>

<p>There are two modules that MATLAB users will want to use:</p>

<dl>

<dt id="PDL::NiceSlice"><a href="./NiceSlice.html">PDL::NiceSlice</a></dt>
<dd>

<p>Gives PDL a syntax for slices (sub-matrices) that is shorter and more familiar to MATLAB users.</p>

<pre><code>  % MATLAB
  b(1:5)            --&gt;  Selects the first 5 elements from b.

  # PDL without NiceSlice
  $y-&gt;slice(&quot;0:4&quot;)  --&gt;  Selects the first 5 elements from $y.

  # PDL with NiceSlice
  $y(0:4)           --&gt;  Selects the first 5 elements from $y.</code></pre>

</dd>
<dt id="PDL::AutoLoader"><a href="./AutoLoader.html">PDL::AutoLoader</a></dt>
<dd>

<p>Provides a MATLAB-style autoloader for PDL. If an unknown function <code>foo()</code> is called, PDL looks for a file called <code>foo.pdl</code>. If it finds one, it reads it.</p>

</dd>
</dl>

<h1 id="BASIC-FEATURES">BASIC FEATURES</h1>

<p>This section explains how PDL&#39;s syntax differs from MATLAB. Most MATLAB users will want to start here.</p>

<h2 id="General-gotchas">General &quot;gotchas&quot;</h2>

<dl>

<dt id="Indices">Indices</dt>
<dd>

<p>In PDL, indices start at &#39;0&#39; (like C and Java), not 1 (like MATLAB or FORTRAN). For example, if <code>$y</code> is an array with 5 elements, the elements would be numbered from 0 to 4. This is different, but less difficult as soon as you need to do calculations based on offsets.</p>

</dd>
<dt id="Displaying-an-object">Displaying an object</dt>
<dd>

<p>MATLAB normally displays object contents automatically. In the PDL shells you display objects explicitly with the <code>print</code> command or the shortcut <code>p</code>:</p>

<p>MATLAB:</p>

<pre><code> &gt;&gt; a = 12
 a =  12
 &gt;&gt; b = 23;       % Suppress output.
 &gt;&gt;</code></pre>

<p>PDL Shell (perldl or pdl2):</p>

<pre><code> pdl&gt; $x = 12    # No output.
 pdl&gt; print $x   # Print object.
 12
 pdl&gt; p $x       # &quot;p&quot; is a shorthand for &quot;print&quot; in the shell.
 12
 pdl&gt;</code></pre>

<p>In pdl2 there is the <code>do_print</code> command that will toggle the &quot;quiet&quot; mode, which defaults to on. In &quot;print&quot; mode, expressions you enter on the command line will have their values printed.</p>

</dd>
</dl>

<h2 id="Creating-ndarrays">Creating ndarrays</h2>

<dl>

<dt id="Variables-in-PDL">Variables in PDL</dt>
<dd>

<p>Variables always start with the &#39;$&#39; sign.</p>

<pre><code> MATLAB:    value  = 42
 PerlDL:    $value = 42</code></pre>

</dd>
<dt id="Basic-syntax">Basic syntax</dt>
<dd>

<p>Use the &quot;pdl&quot; constructor to create a new <i>ndarray</i>.</p>

<pre><code> MATLAB:    v  = [1,2,3,4]
 PerlDL:    $v = pdl [1,2,3,4]

 MATLAB:    A  =      [ 1,2,3  ;  3,4,5 ]
 PerlDL:    $A = pdl [ [1,2,3] , [3,4,5] ]</code></pre>

</dd>
<dt id="Simple-matrices">Simple matrices</dt>
<dd>

<pre><code>                      MATLAB       PDL
                      ------       ------
  Matrix of ones      ones(5)      ones 5,5
  Matrix of zeros     zeros(5)     zeros 5,5
  Random matrix       rand(5)      random 5,5
  Linear vector       1:5          sequence 5</code></pre>

<p>Notice that in PDL the parenthesis in a function call are often optional. It is important to keep an eye out for possible ambiguities. For example:</p>

<pre><code>  pdl&gt; p zeros 2, 2 + 2</code></pre>

<p>Should this be interpreted as <code>zeros(2,2) + 2</code> or as <code>zeros 2, (2+2)</code>? Both are valid statements:</p>

<pre><code>  pdl&gt; p zeros(2,2) + 2
  [
   [2 2]
   [2 2]
  ]
  pdl&gt; p zeros 2, (2+2)
  [
   [0 0]
   [0 0]
   [0 0]
   [0 0]
  ]</code></pre>

<p>Rather than trying to memorize Perl&#39;s order of precedence, it is best to use parentheses to make your code unambiguous. Remember you may need to come back to your code, and parentheses make your own (as well as others&#39;) comprehension easier.</p>

</dd>
<dt id="Linearly-spaced-sequences">Linearly spaced sequences</dt>
<dd>

<pre><code>  MATLAB:   &gt;&gt; linspace(2,10,5)
            ans = 2 4 6 8 10

  PerlDL:   pdl&gt; p zeroes(5)-&gt;xlinvals(2,10)
            [2 4 6 8 10]</code></pre>

<p><b>Explanation</b>: Start with a 1-dimensional ndarray of 5 elements and give it equally spaced values from 2 to 10.</p>

<p>MATLAB has a single function call for this. On the other hand, PDL&#39;s method is more flexible:</p>

<pre><code>  pdl&gt; p zeros(5,5)-&gt;xlinvals(2,10)
  [
   [ 2  4  6  8 10]
   [ 2  4  6  8 10]
   [ 2  4  6  8 10]
   [ 2  4  6  8 10]
   [ 2  4  6  8 10]
  ]
  pdl&gt; p zeros(5,5)-&gt;ylinvals(2,10)
  [
   [ 2  2  2  2  2]
   [ 4  4  4  4  4]
   [ 6  6  6  6  6]
   [ 8  8  8  8  8]
   [10 10 10 10 10]
  ]
  pdl&gt; p zeros(3,3,3)-&gt;zlinvals(2,6)
  [
   [
    [2 2 2]
    [2 2 2]
    [2 2 2]
   ]
   [
    [4 4 4]
    [4 4 4]
    [4 4 4]
   ]
   [
    [6 6 6]
    [6 6 6]
    [6 6 6]
   ]
  ]</code></pre>

</dd>
<dt id="Slicing-and-indices">Slicing and indices</dt>
<dd>

<p>Extracting a subset from a collection of data is known as <i>slicing</i>. PDL and MATLAB have a similar syntax for slicing, but there are two important differences:</p>

<p>1) PDL indices start at 0, as in C and Java. MATLAB starts indices at 1.</p>

<p>2) In MATLAB you think &quot;rows and columns&quot;. In PDL, think &quot;x and y&quot;.</p>

<pre><code>  MATLAB                         PerlDL
  ------                         ------
  &gt;&gt; A                           pdl&gt; p $A
  A =                            [
       1   2   3                  [1 2 3]
       4   5   6                  [4 5 6]
       7   8   9                  [7 8 9]
                                 ]
  -------------------------------------------------------
  (row = 2, col = 1)             (x = 0, y = 1)
  &gt;&gt; A(2,1)                      pdl&gt; p $A(0,1)
  ans =                          [
         4                        [4]
                                 ]
  -------------------------------------------------------
  (row = 2 to 3, col = 1 to 2)   (x = 0 to 1, y = 1 to 2)
  &gt;&gt; A(2:3,1:2)                  pdl&gt; p $A(0:1,1:2)
  ans =                          [
         4   5                    [4 5]
         7   8                    [7 8]
                                 ]</code></pre>

<dl>

<dt id="Warning"><b>Warning</b></dt>
<dd>

<p>When you write a stand-alone PDL program, if you want the &quot;nice slice&quot; syntax, you have to include the <a href="./NiceSlice.html">PDL::NiceSlice</a> module. See the previous section &quot;<b>MODULES FOR MATLAB USERS</b>&quot; for more information.</p>

<pre><code>  use PDL;             # Import main PDL module.
  use PDL::NiceSlice;  # Nice syntax for slicing.
  use PDL::AutoLoader; # MATLAB-like autoloader.

  $A = random 4,4;
  print $A(0,1);</code></pre>

</dd>
</dl>

</dd>
</dl>

<h2 id="Matrix-Operations">Matrix Operations</h2>

<dl>

<dt id="Matrix-multiplication">Matrix multiplication</dt>
<dd>

<pre><code> MATLAB:    A * B
 PerlDL:    $A x $B</code></pre>

</dd>
<dt id="Element-wise-multiplication">Element-wise multiplication</dt>
<dd>

<pre><code> MATLAB:    A .* B
 PerlDL:    $A * $B</code></pre>

</dd>
<dt id="Transpose">Transpose</dt>
<dd>

<pre><code> MATLAB:    A&#39;
 PerlDL:    $A-&gt;transpose</code></pre>

</dd>
</dl>

<h2 id="Functions-that-aggregate-data">Functions that aggregate data</h2>

<p>Some functions (like <code>sum</code>, <code>max</code> and <code>min</code>) aggregate data for an N-dimensional data set. This is a place where MATLAB and PDL take a different approach:</p>

<dl>

<dt id="In-MATLAB-these-functions-all-work-along-one-dimension">In MATLAB, these functions all work along one dimension.</dt>
<dd>

<pre><code>  &gt;&gt; A = [ 1,5,4  ;  4,2,1 ]
  A = 1  5  4
      4  2  1
  &gt;&gt; max(A)
  ans = 4  5  4
  &gt;&gt; max(A&#39;)
  ans = 5  4</code></pre>

<p>If you want the maximum for the entire data set, you can use the special <code>A(:)</code> notation which basically turns the entire data set into a single 1-dimensional vector.</p>

<pre><code>  &gt;&gt; max(A(:))
  ans =  5
  &gt;&gt; A = ones(2,2,2,2)
  &gt;&gt; max(A(:))
  ans = 1</code></pre>

</dd>
<dt id="PDL-offers-two-functions-for-each-feature">PDL offers two functions for each feature.</dt>
<dd>

<pre><code>  sum   vs   sumover
  avg   vs   average
  max   vs   maximum
  min   vs   minimum</code></pre>

<p>The <b>long name</b> works over a dimension, while the <b>short name</b> works over the entire ndarray.</p>

<pre><code>  pdl&gt; p $A = pdl [ [1,5,4] , [4,2,1] ]
  [
   [1 5 4]
   [4 2 1]
  ]
  pdl&gt; p $A-&gt;maximum
  [5 4]
  pdl&gt; p $A-&gt;transpose-&gt;maximum
  [4 5 4]
  pdl&gt; p $A-&gt;max
  5
  pdl&gt; p ones(2,2,2)-&gt;max
  1
  pdl&gt; p ones(2,2,2,2)-&gt;max
  1</code></pre>

</dd>
</dl>

<dl>

<dt id="Note"><b>Note</b></dt>
<dd>

<p>Notice that PDL aggregates horizontally while MATLAB aggregates vertically. In other words:</p>

<pre><code>  MATLAB              PerlDL
  max(A)       ==     $A-&gt;transpose-&gt;maximum
  max(A&#39;)      ==     $A-&gt;maximum</code></pre>

<p><b>TIP</b>: In MATLAB you think &quot;rows and columns&quot;. In PDL, think &quot;x and y&quot;.</p>

</dd>
</dl>

<h2 id="Higher-dimensional-data-sets">Higher dimensional data sets</h2>

<p>A related issue is how MATLAB and PDL understand data sets of higher dimension. MATLAB was designed for 1D vectors and 2D matrices. Higher dimensional objects (&quot;N-D arrays&quot;) were added on top. In contrast, PDL was designed for N-dimensional ndarrays from the start. This leads to a few surprises in MATLAB that don&#39;t occur in PDL:</p>

<dl>

<dt id="MATLAB-sees-a-vector-as-a-2D-matrix">MATLAB sees a vector as a 2D matrix.</dt>
<dd>

<pre><code>  MATLAB                       PerlDL
  ------                       ------
  &gt;&gt; vector = [1,2,3,4];       pdl&gt; $vector = pdl [1,2,3,4]
  &gt;&gt; size(vector)              pdl&gt; p $vector-&gt;dims
  ans = 1 4                    4</code></pre>

<p>MATLAB sees <code>[1,2,3,4]</code> as a 2D matrix (1x4 matrix). PDL sees it as a 1D vector: A single dimension of size 4.</p>

</dd>
<dt id="But-MATLAB-ignores-the-last-dimension-of-a-4x1x1-matrix">But MATLAB ignores the last dimension of a 4x1x1 matrix.</dt>
<dd>

<pre><code>  MATLAB                       PerlDL
  ------                       ------
  &gt;&gt; A = ones(4,1,1);          pdl&gt; $A = ones 4,1,1
  &gt;&gt; size(A)                   pdl&gt; p $A-&gt;dims
  ans = 4 1                    4 1 1</code></pre>

</dd>
<dt id="And-MATLAB-treats-a-4x1x1-matrix-differently-from-a-1x1x4-matrix">And MATLAB treats a 4x1x1 matrix differently from a 1x1x4 matrix.</dt>
<dd>

<pre><code>  MATLAB                       PerlDL
  ------                       ------
  &gt;&gt; A = ones(1,1,4);          pdl&gt; $A = ones 1,1,4
  &gt;&gt; size(A)                   pdl&gt; p $A-&gt;dims
  ans = 1 1 4                  1 1 4</code></pre>

</dd>
<dt id="MATLAB-has-no-direct-syntax-for-N-D-arrays">MATLAB has no direct syntax for N-D arrays.</dt>
<dd>

<pre><code>  pdl&gt; $A = pdl [ [[1,2,3],[4,5,6]], [[2,3,4],[5,6,7]] ]
  pdl&gt; p $A-&gt;dims
  3 2 2</code></pre>

</dd>
<dt id="Feature-support">Feature support.</dt>
<dd>

<p>In MATLAB, several features such as sparse matrix support are not available for N-D arrays. In PDL, just about any feature supported by 1D and 2D ndarrays, is equally supported by N-dimensional ndarrays. There is usually no distinction.</p>

</dd>
</dl>

<h2 id="Loop-Structures">Loop Structures</h2>

<p>Perl has many loop structures, but we will only show the one that is most familiar to MATLAB users:</p>

<pre><code>  MATLAB              PerlDL
  ------              ------
  for i = 1:10        for $i (1..10) {
      disp(i)             print $i
  endfor              }</code></pre>

<dl>

<dt id="Note1"><b>Note</b></dt>
<dd>

<p>Never use for-loops for numerical work. Perl&#39;s for-loops are faster than MATLAB&#39;s, but they both pale against a &quot;vectorized&quot; operation. PDL has many tools that facilitate writing vectorized programs. These are beyond the scope of this guide. To learn more, see: <a href="./Indexing.html">PDL::Indexing</a>, <a href="./Broadcasting.html">PDL::Broadcasting</a>, and <a href="./PP.html">PDL::PP</a>.</p>

<p>Likewise, never use <code>1..10</code> for numerical work, even outside a for-loop. <code>1..10</code> is a Perl array. Perl arrays are designed for flexibility, not speed. Use <i>ndarrays</i> instead. To learn more, see the next section.</p>

</dd>
</dl>

<h2 id="ndarrays-vs-Perl-Arrays">ndarrays vs Perl Arrays</h2>

<p>It is important to note the difference between an <i>ndarray</i> and a Perl array. Perl has a general-purpose array object that can hold any type of element:</p>

<pre><code>  @perl_array = 1..10;
  @perl_array = ( 12, &quot;Hello&quot; );
  @perl_array = ( 1, 2, 3, \@another_perl_array, sequence(5) );</code></pre>

<p>Perl arrays allow you to create powerful data structures (see <b>Data structures</b> below), <b>but they are not designed for numerical work</b>. For that, use <i>ndarrays</i>:</p>

<pre><code>  $pdl = pdl [ 1, 2, 3, 4 ];
  $pdl = sequence 10_000_000;
  $pdl = ones 600, 600;</code></pre>

<p>For example:</p>

<pre><code>  $points =  pdl  1..10_000_000    # 4.7 seconds
  $points = sequence 10_000_000    # milliseconds</code></pre>

<p><b>TIP</b>: You can use underscores in numbers (<code>10_000_000</code> reads better than <code>10000000</code>).</p>

<h2 id="Conditionals">Conditionals</h2>

<p>Perl has many conditionals, but we will only show the one that is most familiar to MATLAB users:</p>

<pre><code>  MATLAB                          PerlDL
  ------                          ------
  if value &gt; MAX                  if ($value &gt; $MAX) {
      disp(&quot;Too large&quot;)               print &quot;Too large\n&quot;;
  elseif value &lt; MIN              } elsif ($value &lt; $MIN) {
      disp(&quot;Too small&quot;)               print &quot;Too small\n&quot;;
  else                            } else {
      disp(&quot;Perfect!&quot;)                print &quot;Perfect!\n&quot;;
  end                             }</code></pre>

<dl>

<dt id="Note2"><b>Note</b></dt>
<dd>

<p>Here is a &quot;gotcha&quot;:</p>

<pre><code>  MATLAB:  elseif
  PerlDL:  elsif</code></pre>

<p>If your conditional gives a syntax error, check that you wrote your <code>elsif</code>&#39;s correctly.</p>

</dd>
</dl>

<h2 id="TIMTOWDI-There-Is-More-Than-One-Way-To-Do-It">TIMTOWDI (There Is More Than One Way To Do It)</h2>

<p>One of the most interesting differences between PDL and other tools is the expressiveness of the Perl language. TIMTOWDI, or &quot;There Is More Than One Way To Do It&quot;, is Perl&#39;s motto.</p>

<p>Perl was written by a linguist, and one of its defining properties is that statements can be formulated in different ways to give the language a more natural feel. For example, you are unlikely to say to a friend:</p>

<pre><code> &quot;While I am not finished, I will keep working.&quot;</code></pre>

<p>Human language is more flexible than that. Instead, you are more likely to say:</p>

<pre><code> &quot;I will keep working until I am finished.&quot;</code></pre>

<p>Owing to its linguistic roots, Perl is the only programming language with this sort of flexibility. For example, Perl has traditional while-loops and if-statements:</p>

<pre><code>  while ( ! finished() ) {
      keep_working();
  }

  if ( ! wife_angry() ) {
      kiss_wife();
  }</code></pre>

<p>But it also offers the alternative <b>until</b> and <b>unless</b> statements:</p>

<pre><code>  until ( finished() ) {
      keep_working();
  }

  unless ( wife_angry() ) {
      kiss_wife();
  }</code></pre>

<p>And Perl allows you to write loops and conditionals in &quot;postfix&quot; form:</p>

<pre><code>  keep_working() until finished();

  kiss_wife() unless wife_angry();</code></pre>

<p>In this way, Perl often allows you to write more natural, easy to understand code than is possible in more restrictive programming languages.</p>

<h2 id="Functions">Functions</h2>

<p>PDL&#39;s syntax for declaring functions differs significantly from MATLAB&#39;s.</p>

<pre><code>  MATLAB                          PerlDL
  ------                          ------
  function retval = foo(x,y)      sub foo {
      retval = x.**2 + x.*y           my ($x, $y) = @_;
  endfunction                         return $x**2 + $x*$y;
                                  }</code></pre>

<p>Don&#39;t be intimidated by all the new syntax. Here is a quick run through a function declaration in PDL:</p>

<p>1) &quot;<b>sub</b>&quot; stands for &quot;subroutine&quot;.</p>

<p>2) &quot;<b>my</b>&quot; declares variables to be local to the function. This helps you not accidentally use undeclared variables, which is enforced if you <code>use strict</code>. See <a>strict</a> for more.</p>

<p>3) &quot;<b>@_</b>&quot; is a special Perl array that holds all the function parameters. This might seem like a strange way to do functions, but it allows you to make functions that take a variable number of parameters. For example, the following function takes any number of parameters and adds them together:</p>

<pre><code>  sub mysum {
      my ($i, $total) = (0, 0);
      for $i (@_) {
          $total += $i;
      }
      return $total;
  }</code></pre>

<p>In more recent versions of Perl, you can <code>use signatures</code> for a different syntax for declaring function parameters. See <a>signatures</a> for more.</p>

<p>4) You can assign values to several variables at once using the syntax:</p>

<pre><code>  ($x, $y, $z) = (1, 2, 3);</code></pre>

<p>So, in the previous examples:</p>

<pre><code>  # This declares two local variables and initializes them to 0.
  my ($i, $total) = (0, 0);

  # This takes the first two elements of @_ and puts them in $x and $y.
  my ($x, $y) = @_;</code></pre>

<p>5) The &quot;<b>return</b>&quot; statement gives the return value of the function, if any.</p>

<h1 id="ADDITIONAL-FEATURES">ADDITIONAL FEATURES</h1>

<h2 id="ASCII-File-IO">ASCII File IO</h2>

<p>To read data files containing whitespace separated columns of numbers (as would be read using the MATLAB <i>load</i> command) one uses the PDL <i>rcols</i> in <a href="IO/Misc.html">PDL::IO::Misc</a>. For a general review of the IO functionality available in PDL, see the documentation for <a href="./IO.html">PDL::IO</a>, e.g., <code>help PDL::IO</code> in the <i>pdl2</i> shell or <code> pdldoc PDL::IO </code> from the shell command line.</p>

<h2 id="Data-structures">Data structures</h2>

<p>To create complex data structures, MATLAB uses &quot;<i>cell arrays</i>&quot; and &quot;<i>structure arrays</i>&quot;. Perl&#39;s arrays and hashes offer similar functionality but are more powerful and flexible. This section is only a quick overview of what Perl has to offer. To learn more about this, please go to <a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a> or run the command <code>perldoc perldata</code>.</p>

<dl>

<dt id="Arrays">Arrays</dt>
<dd>

<p>Perl arrays are similar to MATLAB&#39;s cell arrays, but more flexible. For example, in MATLAB, a cell array is still fundamentally a matrix. It is made of rows, and rows must have the same length.</p>

<pre><code>  MATLAB
  ------
  array = {1, 12, &#39;hello&#39;; rand(3, 2), ones(3), &#39;junk&#39;}
  =&gt; OK
  array = {1, 12, &#39;hello&#39;; rand(3, 2), ones(3) }
  =&gt; ERROR</code></pre>

<p>A Perl array is a general purpose, sequential data structure. It can contain any data type.</p>

<pre><code>  PerlDL
  ------
  @array = ( [1, 12, &#39;hello&#39;] , [ random(3,2), ones(3,3), &#39;junk&#39; ] )
  =&gt; OK
  @array = ( [1, 12, &#39;hello&#39;] , [ random(3,2), ones(3,3) ] )
  =&gt; OK
  @array = ( 5 , {&#39;name&#39; =&gt; &#39;Mike&#39;} , [1, 12, &#39;hello&#39;] )
  =&gt; OK</code></pre>

<p>Notice that Perl array&#39;s start with the &quot;@&quot; prefix instead of the &quot;$&quot; used by ndarrays.</p>

<p><i>To learn about Perl arrays, please go to <a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a> or run the command <code>perldoc perldata</code>.</i></p>

</dd>
<dt id="Hashes">Hashes</dt>
<dd>

<p>Perl hashes are similar to MATLAB&#39;s structure arrays:</p>

<pre><code>  MATLAB
  ------
  &gt;&gt; drink = struct(&#39;type&#39;, &#39;coke&#39;, &#39;size&#39;, &#39;large&#39;, &#39;myarray&#39;, {1,2,3})
  &gt;&gt; drink.type = &#39;sprite&#39;
  &gt;&gt; drink.price = 12          % Add new field to structure array.

  PerlDL
  ------
  pdl&gt; %drink = ( type =&gt; &#39;coke&#39; , size =&gt; &#39;large&#39;, myndarray =&gt; ones(3,3,3) )
  pdl&gt; $drink{type} = &#39;sprite&#39;
  pdl&gt; $drink{price} = 12   # Add new field to hash.</code></pre>

<p>Notice that Perl hashes start with the &quot;%&quot; prefix instead of the &quot;@&quot; for arrays and &quot;$&quot; used by ndarrays.</p>

<p><i>To learn about Perl hashes, please go to <a href="http://perldoc.perl.org/perldata.html">http://perldoc.perl.org/perldata.html</a> or run the command <code>perldoc perldata</code>.</i></p>

</dd>
</dl>

<h2 id="Performance">Performance</h2>

<p>PDL has powerful performance features, some of which are not normally available in numerical computation tools. The following pages will guide you through these features:</p>

<dl>

<dt id="PDL::Indexing"><a href="./Indexing.html">PDL::Indexing</a></dt>
<dd>

<p><b>Level</b>: Beginner</p>

<p>This beginner tutorial covers the standard &quot;vectorization&quot; feature that you already know from MATLAB. Use this page to learn how to avoid for-loops to make your program more efficient.</p>

</dd>
<dt id="PDL::Broadcasting"><a href="./Broadcasting.html">PDL::Broadcasting</a></dt>
<dd>

<p><b>Level</b>: Intermediate</p>

<p>PDL&#39;s &quot;vectorization&quot; feature goes beyond what most numerical software can do. In this tutorial you&#39;ll learn how to &quot;broadcast&quot; over higher dimensions, allowing you to vectorize your program further than is possible in MATLAB.</p>

</dd>
<dt id="Benchmarks">Benchmarks</dt>
<dd>

<p><b>Level</b>: Intermediate</p>

<p>Perl comes with an easy to use benchmarks module to help you find how long it takes to execute different parts of your code. It is a great tool to help you focus your optimization efforts. You can read about it online (<a href="http://perldoc.perl.org/Benchmark.html">http://perldoc.perl.org/Benchmark.html</a>) or through the command <code>perldoc Benchmark</code>.</p>

</dd>
<dt id="PDL::PP"><a href="./PP.html">PDL::PP</a></dt>
<dd>

<p><b>Level</b>: Advanced</p>

<p>PDL&#39;s Pre-Processor is one of PDL&#39;s most powerful features. You write a function definition in special markup and the pre-processor generates real C code which can be compiled. With PDL:PP you get the full speed of native C code without having to deal with the full complexity of the C language.</p>

</dd>
</dl>

<h2 id="Plotting">Plotting</h2>

<p>PDL has full-featured plotting abilities. Unlike MATLAB, PDL relies more on third-party libraries (pgplot and PLplot) for its 2D plotting features. Its 3D plotting and graphics uses OpenGL for performance and portability. PDL has three main plotting modules:</p>

<dl>

<dt id="PDL::Graphics::PGPLOT"><a href="Graphics/PGPLOT.html">PDL::Graphics::PGPLOT</a></dt>
<dd>

<p><b>Best for</b>: Plotting 2D functions and data sets.</p>

<p>This is an interface to the venerable PGPLOT library. PGPLOT has been widely used in the academic and scientific communities for many years. In part because of its age, PGPLOT has some limitations compared to newer packages such as PLplot (e.g. no RGB graphics). But it has many features that still make it popular in the scientific community.</p>

</dd>
<dt id="PDL::Graphics::PLplot"><a>PDL::Graphics::PLplot</a></dt>
<dd>

<p><b>Best for</b>: Plotting 2D functions as well as 2D and 3D data sets.</p>

<p>This is an interface to the PLplot plotting library. PLplot is a modern, open source library for making scientific plots. It supports plots of both 2D and 3D data sets. PLplot is best supported for unix/linux/macosx platforms. It has an active developers community and support for win32 platforms is improving.</p>

</dd>
<dt id="PDL::Graphics::TriD"><a>PDL::Graphics::TriD</a></dt>
<dd>

<p><b>Best for</b>: Plotting 3D functions.</p>

<p>The native PDL 3D graphics library using OpenGL as a backend for 3D plots and data visualization. With OpenGL, it is easy to manipulate the resulting 3D objects with the mouse in real time.</p>

</dd>
</dl>

<h2 id="Writing-GUIs">Writing GUIs</h2>

<p>Through Perl, PDL has access to all the major toolkits for creating a cross platform graphical user interface. One popular option is wxPerl (<a href="http://wxperl.sourceforge.net">http://wxperl.sourceforge.net</a>). These are the Perl bindings for wxWidgets, a powerful GUI toolkit for writing cross-platform applications.</p>

<p>wxWidgets is designed to make your application look and feel like a native application in every platform. For example, the Perl IDE <b>Padre</b> is written with wxPerl.</p>

<h2 id="Simulink">Simulink</h2>

<p>Simulink is a graphical dynamical system modeler and simulator. It can be purchased separately as an add-on to MATLAB. PDL and Perl do not have a direct equivalent to MATLAB&#39;s Simulink. If this feature is important to you, then take a look at <b>Scilab</b>:</p>

<p><a href="http://www.scilab.org">http://www.scilab.org</a></p>

<p>Scilab is another numerical analysis software. Like PDL, it is free and open source. It doesn&#39;t have PDL&#39;s unique features, but it is very similar to MATLAB. Scilab comes with <b>Xcos</b> (previously Scicos), a graphical system modeler and simulator similar to Simulink.</p>

<h1 id="COMPARISON:-REPEATED-COPY-OF-MATRIX">COMPARISON: REPEATED COPY OF MATRIX</h1>

<p>In MATLAB, the <code>repmat</code> function works like so:</p>

<pre><code>  &gt; A = reshape(0:5, 3, 2)&#39; # similar to PDL::sequence(3, 2)
  ans =
     0   1   2
     3   4   5
  &gt; repmat(A, 2, 3) # double rows, triple columns
  ans =
     0   1   2   0   1   2   0   1   2
     3   4   5   3   4   5   3   4   5
     0   1   2   0   1   2   0   1   2
     3   4   5   3   4   5   3   4   5</code></pre>

<p>This works (at least in Octave) at least up to 3 dimensions.</p>

<p>The PDL analog:</p>

<pre><code>  sub repmat {
    my $f=shift;
    my @n=@_; #number of repetitions along dimension
    my $sl = join &#39;,&#39;, map &quot;:,*$_&quot;, @n; # insert right-size dummy after each real
    my $r = $f-&gt;slice($sl); #result
    $r = $r-&gt;clump($_, $_+1) for 0..$#n;
    $r;
  }
  &gt; p $x = sequence(3,2)
  [
   [0 1 2]
   [3 4 5]
  ]
  &gt; p repmat($x, 3, 2) # triple columns, double rows
  [
   [0 1 2 0 1 2 0 1 2]
   [3 4 5 3 4 5 3 4 5]
   [0 1 2 0 1 2 0 1 2]
   [3 4 5 3 4 5 3 4 5]
  ]</code></pre>

<h1 id="COMPARISON:-FLOYD-WARSHALL-ALGORITHM">COMPARISON: FLOYD-WARSHALL ALGORITHM</h1>

<p>In <a href="https://en.wikipedia.org/wiki/Graph_theory">graph theory</a>, an apparently-simple but difficult problem is the &quot;shortest path&quot; problem, of finding the shortest path between any two nodes. A famous solution to this, albeit expensive (it is <code>O(V^3)</code> where <code>V</code> is the number of vertices) is the Floyd-Warshall algorithm, which iterates through all the possible paths.</p>

<p>Both the MATLAB solution and the PDL solution use vectorisation, so hopefully this is a useful comparison. The MATLAB version started with the code in <a href="https://uk.mathworks.com/matlabcentral/fileexchange/67503-floyd-warshall-vectorized">code by Giorgos Dim</a>, but modified as that code produces an incorrect path matrix.</p>

<p>Sample data (reflected on both the Wikipedia page, and the Rosetta Code website) for the weighted-edges matrix is, in PDL format:</p>

<pre><code>  my $we = pdl q[
   [Inf Inf  -2 Inf]
   [  4 Inf   3 Inf]
   [Inf Inf Inf   2]
   [Inf  -1 Inf Inf]
  ];</code></pre>

<p>and in MATLAB format:</p>

<pre><code>  A = [0 Inf -2 Inf; 4 0 3 Inf; Inf Inf 0 2; Inf -1 Inf 0]</code></pre>

<h2 id="PDL-version">PDL version</h2>

<p>To solve for only distances without capturing the shortest actual paths:</p>

<pre><code>  $we .= $we-&gt;hclip($we-&gt;mslice(&#39;X&#39;, $_) + $we-&gt;mslice($_, &#39;X&#39;))
    for 0..($we-&gt;dim(0)-1);</code></pre>

<p>This loops over each possible intermediate point (<code>k</code> in the other literature), setting it to <code>$_</code> (a Perl idiom). It uses <a href="./Primitive.html#hclip">&quot;hclip&quot; in PDL::Primitive</a> for vectorised calculation of the distance between the intermediate point&#39;s predecessors and successors. Those are the two components of the addition expression, using &quot;slices&quot; alluded to above. The <code>.=</code> is the PDL syntax for updating an ndarray.</p>

<p>To capture the shortest-path &quot;next vertex&quot; matrix as well:</p>

<pre><code>  use PDL::Lite;
  my $d = $we-&gt;copy-&gt;inplace;
  $d-&gt;diagonal(0, 1) .= 0;
  my $suc = $we-&gt;copy-&gt;inplace;
  my $adjacent_coords = PDL::whichND($we-&gt;isfinite);
  $suc-&gt;indexND($adjacent_coords) .= $adjacent_coords-&gt;slice(0)-&gt;flat;
  $suc-&gt;diagonal(0, 1) .= PDL::Basic::sequence($d-&gt;dim(0));
  for (my $k = $d-&gt;dim(0)-1; $k &gt;= 0; $k--) {
    my $d_copy = $d-&gt;copy;
    $d .= $d-&gt;hclip($d-&gt;mslice(&#39;X&#39;, $k) + $d-&gt;mslice($k, &#39;X&#39;));
    my $coords = PDL::whichND($d &lt; $d_copy);
    my $from_coords = $coords-&gt;copy-&gt;inplace;
    $from_coords-&gt;slice(0) .= $k;
    $suc-&gt;indexND($coords) .= $suc-&gt;indexND($from_coords);
  }</code></pre>

<p>The <code>diagonal</code> and <code>slice</code> expressions show how to update data via a query syntax.</p>

<h2 id="MATLAB-version">MATLAB version</h2>

<p>Path-lengths only:</p>

<pre><code>  function D = FloydWarshall(D)
    for k = 1:length(D)
      D = min(D,D(:,k) + D(k,:));
    end
  end</code></pre>

<p>The path vertices-capturing as well:</p>

<pre><code>  function [D,P] = FloydWarshall(D)
    P = D;
    n = length(D);
    coords = find(isfinite(P));
    P(coords) = floor((coords-1) / n)+1; % the col in 1-based
    for v = 1:n; P(v, v) = v; end
    for k = 1:n
      prevD = D;
      D = min(D,D(:,k) + D(k,:));
      coords = find(D&lt;prevD);
      from_coords = n * (k-1) + mod(coords-1, n) + 1; % change col to k in 1-based
      P(coords) = P(from_coords);
    end
  end</code></pre>

<p>By comparison, the lack of &quot;broadcasting&quot; means that to update the diagonal requires a for-loop, which in the sphere of vectorised calculations is a bad thing. The calculations of coordinates are complicated by the 1-based counting.</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright 2010 Daniel Carrera (dcarrera@gmail.com). You can distribute and/or modify this document under the same terms as the current Perl license.</p>

<p>See: <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p>I&#39;d like to thank David Mertens, Chris Marshall and Sigrid Carrera for their immense help reviewing earlier drafts of this guide. Without their hours of work, this document would not be remotely as useful to MATLAB users as it is today.</p>


</body>

</html>


