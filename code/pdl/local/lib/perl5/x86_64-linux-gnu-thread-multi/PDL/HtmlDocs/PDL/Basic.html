<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::Basic -- Basic utility functions for PDL</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#xvals">xvals</a></li>
      <li><a href="#yvals">yvals</a></li>
      <li><a href="#zvals">zvals</a></li>
      <li><a href="#xlinvals">xlinvals</a></li>
      <li><a href="#ylinvals">ylinvals</a></li>
      <li><a href="#zlinvals">zlinvals</a></li>
      <li><a href="#xlogvals">xlogvals</a></li>
      <li><a href="#ylogvals">ylogvals</a></li>
      <li><a href="#zlogvals">zlogvals</a></li>
      <li><a href="#allaxisvals">allaxisvals</a></li>
      <li><a href="#ndcoords">ndcoords</a></li>
      <li><a href="#hist">hist</a></li>
      <li><a href="#whist">whist</a></li>
      <li><a href="#sequence">sequence</a></li>
      <li><a href="#rvals">rvals</a></li>
      <li><a href="#axisvals">axisvals</a></li>
      <li><a href="#transpose">transpose</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Basic -- Basic utility functions for PDL</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module contains basic utility functions for creating and manipulating ndarrays. Most of these functions are simplified interfaces to the more flexible functions in the modules <a href="./Primitive.html">PDL::Primitive</a> and <a href="./Slices.html">PDL::Slices</a>.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use PDL::Basic;</code></pre>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="xvals">xvals</h2>

<p>Fills an ndarray with X index values. Uses similar specifications to <a href="#zeroes">&quot;zeroes&quot;</a> and <a href="#new_from_specification">&quot;new_from_specification&quot;</a>, except that as of 2.064, the returned ndarray will be at least type <code>double</code>.</p>

<p>CAVEAT:</p>

<p>If you use the single argument ndarray form (top row in the usage table) the output will have the same type as the input; this may give surprising results if, e.g., you have a byte array with a dimension of size greater than 256. To force a type, use the third form.</p>

<pre><code> $x = xvals($somearray);
 $x = xvals([OPTIONAL TYPE],$nx,$ny,$nz...);
 $x = xvals([OPTIONAL TYPE], $somarray-&gt;dims);</code></pre>

<p>etc. see <a href="./Core.html#zeroes">zeroes</a>.</p>

<pre><code>  pdl&gt; print xvals zeroes(5,10)
  [
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
   [0 1 2 3 4]
  ]</code></pre>

<h2 id="yvals">yvals</h2>

<p>Fills an ndarray with Y index values. See the CAVEAT for <a href="#xvals">&quot;xvals&quot;</a>.</p>

<pre><code> $x = yvals($somearray); yvals(inplace($somearray));
 $x = yvals([OPTIONAL TYPE],$nx,$ny,$nz...);</code></pre>

<p>etc. see <a href="./Core.html#zeroes">zeroes</a>.</p>

<pre><code> pdl&gt; print yvals zeroes(5,10)
 [
  [0 0 0 0 0]
  [1 1 1 1 1]
  [2 2 2 2 2]
  [3 3 3 3 3]
  [4 4 4 4 4]
  [5 5 5 5 5]
  [6 6 6 6 6]
  [7 7 7 7 7]
  [8 8 8 8 8]
  [9 9 9 9 9]
 ]</code></pre>

<h2 id="zvals">zvals</h2>

<p>Fills an ndarray with Z index values. See the CAVEAT for <a href="#xvals">&quot;xvals&quot;</a>.</p>

<pre><code> $x = zvals($somearray); zvals(inplace($somearray));
 $x = zvals([OPTIONAL TYPE],$nx,$ny,$nz...);</code></pre>

<p>etc. see <a href="./Core.html#zeroes">zeroes</a>.</p>

<pre><code> pdl&gt; print zvals zeroes(3,4,2)
 [
  [
   [0 0 0]
   [0 0 0]
   [0 0 0]
   [0 0 0]
  ]
  [
   [1 1 1]
   [1 1 1]
   [1 1 1]
   [1 1 1]
  ]
 ]</code></pre>

<h2 id="xlinvals">xlinvals</h2>

<p>X axis values between endpoints (see <a href="#xvals">&quot;xvals&quot;</a>).</p>

<pre><code> $w = zeroes(100,100);
 $x = $w-&gt;xlinvals(0.5,1.5);
 $y = $w-&gt;ylinvals(-2,-1);
 # calculate Z for X between 0.5 and 1.5 and
 # Y between -2 and -1.
 $z = f($x,$y);</code></pre>

<p><code>xlinvals</code>, <code>ylinvals</code> and <code>zlinvals</code> return an ndarray with the same shape as their first argument and linearly scaled values between the two other arguments along the given axis.</p>

<h2 id="ylinvals">ylinvals</h2>

<p>Y axis values between endpoints (see <a href="#yvals">&quot;yvals&quot;</a>).</p>

<p>See <a href="#xlinvals">&quot;xlinvals&quot;</a> for more information.</p>

<h2 id="zlinvals">zlinvals</h2>

<p>Z axis values between endpoints (see <a href="#zvals">&quot;zvals&quot;</a>).</p>

<p>See <a href="#xlinvals">&quot;xlinvals&quot;</a> for more information.</p>

<h2 id="xlogvals">xlogvals</h2>

<p>X axis values logarithmically spaced between endpoints (see <a href="#xvals">&quot;xvals&quot;</a>).</p>

<pre><code> $w = zeroes(100,100);
 $x = $w-&gt;xlogvals(1e-6,1e-3);
 $y = $w-&gt;ylinvals(1e-4,1e3);
 # calculate Z for X between 1e-6 and 1e-3 and
 # Y between 1e-4 and 1e3.
 $z = f($x,$y);</code></pre>

<p><code>xlogvals</code>, <code>ylogvals</code> and <code>zlogvals</code> return an ndarray with the same shape as their first argument and logarithmically scaled values between the two other arguments along the given axis.</p>

<h2 id="ylogvals">ylogvals</h2>

<p>Y axis values logarithmically spaced between endpoints (see <a href="#yvals">&quot;yvals&quot;</a>).</p>

<p>See <a href="#xlogvals">&quot;xlogvals&quot;</a> for more information.</p>

<h2 id="zlogvals">zlogvals</h2>

<p>Z axis values logarithmically spaced between endpoints (see <a href="#zvals">&quot;zvals&quot;</a>).</p>

<p>See <a href="#xlogvals">&quot;xlogvals&quot;</a> for more information.</p>

<h2 id="allaxisvals">allaxisvals</h2>

<p>Synonym for <a href="#ndcoords">&quot;ndcoords&quot;</a> - enumerates all coordinates in a PDL or dim list, adding an extra dim on the front to accommodate the vector coordinate index (the form expected by <a href="#indexND">&quot;indexND&quot;</a>, <a href="#range">&quot;range&quot;</a>, and <a href="#interpND">&quot;interpND&quot;</a>). See <a href="#ndcoords">&quot;ndcoords&quot;</a> for more detail.</p>

<pre><code>  $indices = allaxisvals($pdl);
  $indices = allaxisvals(@dimlist);
  $indices = allaxisvals($type,@dimlist);</code></pre>

<h2 id="ndcoords">ndcoords</h2>

<p>Enumerate pixel coordinates for an N-D ndarray</p>

<p>Returns an enumerated list of coordinates suitable for use in <a href="./Slices.html#indexND">indexND</a> or <a href="./Slices.html#range">range</a>: you feed in a dimension list and get out an ndarray whose 0th dimension runs over dimension index and whose 1st through Nth dimensions are the dimensions given in the input. If you feed in an ndarray instead of a perl list, then the dimension list is used, as in <a href="#xvals">&quot;xvals&quot;</a> etc.</p>

<p>Unlike <a href="#xvals">&quot;xvals&quot;</a> etc., if you supply an ndarray input, you get out an ndarray of the default ndarray type: double. This causes less surprises than the previous default of keeping the data type of the input ndarray since that rarely made sense in most usages.</p>

<pre><code>  $indices = ndcoords($pdl);
  $indices = ndcoords(@dimlist);
  $indices = ndcoords($type,@dimlist);</code></pre>

<pre><code>  pdl&gt; print ndcoords(2,3)

  [
   [
    [0 0]
    [1 0]
   ]
   [
    [0 1]
    [1 1]
   ]
   [
    [0 2]
    [1 2]
   ]
  ]

  pdl&gt; $w = zeroes(byte,2,3);        # $w is a 2x3 byte ndarray
  pdl&gt; $y = ndcoords($w);            # $y inherits $w&#39;s type
  pdl&gt; $c = ndcoords(long,$w-&gt;dims); # $c is a long ndarray, same dims as $y
  pdl&gt; help $y;
  This variable is   Byte D [2,2,3]              P            0.01Kb
  pdl&gt; help $c;
  This variable is   Long D [2,2,3]              P            0.05Kb</code></pre>

<h2 id="hist">hist</h2>

<p>Create histogram of an ndarray</p>

<pre><code> $hist = hist($data);
 ($xvals,$hist) = hist($data);</code></pre>

<p>or</p>

<pre><code> $hist = hist($data,$min,$max,$step);
 ($xvals,$hist) = hist($data,[$min,$max,$step]);</code></pre>

<p>If <code>hist</code> is run in list context, <code>$xvals</code> gives the computed bin centres as double values.</p>

<p>A nice idiom (with <a href="Graphics/PGPLOT.html">PDL::Graphics::PGPLOT</a>) is</p>

<pre><code> bin hist $data;  # Plot histogram</code></pre>

<pre><code> pdl&gt; p $y
 [13 10 13 10 9 13 9 12 11 10 10 13 7 6 8 10 11 7 12 9 11 11 12 6 12 7]
 pdl&gt; $h = hist $y,0,20,1; # hist with step 1, min 0 and 20 bins
 pdl&gt; p $h
 [0 0 0 0 0 0 2 3 1 3 5 4 4 4 0 0 0 0 0 0]</code></pre>

<h2 id="whist">whist</h2>

<p>Create a weighted histogram of an ndarray</p>

<pre><code> $hist = whist($data, $wt, [$min,$max,$step]);
 ($xvals,$hist) = whist($data, $wt, [$min,$max,$step]);</code></pre>

<p>If requested, <code>$xvals</code> gives the computed bin centres as type double values. <code>$data</code> and <code>$wt</code> should have the same dimensionality and extents.</p>

<p>A nice idiom (with <a href="Graphics/PGPLOT.html">PDL::Graphics::PGPLOT</a>) is</p>

<pre><code> bin whist $data, $wt;  # Plot histogram</code></pre>

<pre><code> pdl&gt; p $y
 [13 10 13 10 9 13 9 12 11 10 10 13 7 6 8 10 11 7 12 9 11 11 12 6 12 7]
 pdl&gt; $wt = grandom($y-&gt;nelem)
 pdl&gt; $h = whist $y, $wt, 0, 20, 1 # hist with step 1, min 0 and 20 bins
 pdl&gt; p $h
 [0 0 0 0 0 0 -0.49552342  1.7987439 0.39450696  4.0073722 -2.6255299 -2.5084501  2.6458365  4.1671676 0 0 0 0 0 0]</code></pre>

<h2 id="sequence">sequence</h2>

<p>Create array filled with a sequence of values</p>

<pre><code> $w = sequence($y); $w = sequence [OPTIONAL TYPE], @dims;</code></pre>

<p>etc. see <a href="./Core.html#zeroes">zeroes</a>.</p>

<pre><code> pdl&gt; p sequence(10)
 [0 1 2 3 4 5 6 7 8 9]
 pdl&gt; p sequence(3,4)
 [
  [ 0  1  2]
  [ 3  4  5]
  [ 6  7  8]
  [ 9 10 11]
 ]</code></pre>

<h2 id="rvals">rvals</h2>

<p>Fills an ndarray with radial distance values from some centre.</p>

<pre><code> $r = rvals $ndarray,{OPTIONS};
 $r = rvals [OPTIONAL TYPE],$nx,$ny,...{OPTIONS};</code></pre>

<pre><code> Options:

 Centre =&gt; [$x,$y,$z...] # Specify centre
 Center =&gt; [$x,$y.$z...] # synonym.

 Squared =&gt; 1 # return distance squared (i.e., don&#39;t take the square root)</code></pre>

<pre><code> pdl&gt; print rvals long,7,7,{Centre=&gt;[2,2]}
 [
  [2 2 2 2 2 3 4]
  [2 1 1 1 2 3 4]
  [2 1 0 1 2 3 4]
  [2 1 1 1 2 3 4]
  [2 2 2 2 2 3 4]
  [3 3 3 3 3 4 5]
  [4 4 4 4 4 5 5]
 ]</code></pre>

<p>If <code>Center</code> is not specified, the midpoint for a given dimension of size <code>N</code> is given by <code> int(N/2) </code> so that the midpoint always falls on an exact pixel point in the data. For dimensions of even size, that means the midpoint is shifted by 1/2 pixel from the true center of that dimension.</p>

<p>Also note that the calculation for <code>rvals</code> for integer values does not promote the datatype so you will have wraparound when the value calculated for <code> r**2 </code> is greater than the datatype can hold. If you need exact values, be sure to use large integer or floating point datatypes.</p>

<p>For a more general metric, one can define, e.g.,</p>

<pre><code> sub distance {
   my ($w,$centre,$f) = @_;
   my ($r) = $w-&gt;allaxisvals-$centre;
   $f-&gt;($r);
 }
 sub l1 { sumover(abs($_[0])); }
 sub euclid { use PDL::Math &#39;pow&#39;; pow(sumover(pow($_[0],2)),0.5); }
 sub linfty { maximum(abs($_[0])); }</code></pre>

<p>so now</p>

<pre><code> distance($w, $centre, \&amp;euclid);</code></pre>

<p>will emulate rvals, while <code>\&amp;l1</code> and <code>\&amp;linfty</code> will generate other well-known norms.</p>

<h2 id="axisvals">axisvals</h2>

<p>Fills an ndarray with index values on Nth dimension</p>

<pre><code> $z = axisvals ($ndarray, $nth);</code></pre>

<p>This is the routine, for which <a href="#xvals">&quot;xvals&quot;</a>, <a href="#yvals">&quot;yvals&quot;</a> etc are mere shorthands. <code>axisvals</code> can be used to fill along any dimension, using a parameter.</p>

<p>See also <a href="#allaxisvals">&quot;allaxisvals&quot;</a>, which generates all axis values simultaneously in a form useful for <a href="#range">&quot;range&quot;</a>, <a href="#interpND">&quot;interpND&quot;</a>, <a href="#indexND">&quot;indexND&quot;</a>, etc.</p>

<p>Note the &#39;from specification&#39; style (see <a href="./Core.html#zeroes">zeroes</a>) is not available here, for obvious reasons.</p>

<h2 id="transpose">transpose</h2>

<p>transpose rows and columns.</p>

<pre><code> $y = transpose($w);</code></pre>

<pre><code> pdl&gt; $w = sequence(3,2)
 pdl&gt; p $w
 [
  [0 1 2]
  [3 4 5]
 ]
 pdl&gt; p transpose( $w )
 [
  [0 3]
  [1 4]
  [2 5]
 ]</code></pre>


</body>

</html>


