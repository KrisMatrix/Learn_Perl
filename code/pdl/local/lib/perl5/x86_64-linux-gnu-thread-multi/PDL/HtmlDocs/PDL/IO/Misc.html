<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::IO::Misc - misc IO routines for PDL</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#bswap2">bswap2</a></li>
      <li><a href="#bswap4">bswap4</a></li>
      <li><a href="#bswap8">bswap8</a></li>
      <li><a href="#rcols">rcols</a></li>
      <li><a href="#wcols">wcols</a></li>
      <li><a href="#swcols">swcols</a></li>
      <li><a href="#rgrep">rgrep</a></li>
      <li><a href="#isbigendian">isbigendian</a></li>
      <li><a href="#rasc">rasc</a></li>
      <li><a href="#rcube">rcube</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::IO::Misc - misc IO routines for PDL</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Some basic I/O functionality: FITS, tables, byte-swapping</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use PDL::IO::Misc;</code></pre>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="bswap2">bswap2</h2>

<pre><code>  Signature: (x(); )</code></pre>

<p>Swaps pairs of bytes in argument x()</p>

<p>bswap2 does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="bswap4">bswap4</h2>

<pre><code>  Signature: (x(); )</code></pre>

<p>Swaps quads of bytes in argument x()</p>

<p>bswap4 does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="bswap8">bswap8</h2>

<pre><code>  Signature: (x(); )</code></pre>

<p>Swaps octets of bytes in argument x()</p>

<p>bswap8 does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="rcols">rcols</h2>

<p>Read specified ASCII cols from a file into ndarrays and perl arrays (also see <a href="#rgrep">&quot;rgrep&quot;</a>).</p>

<pre><code>  Usage:
    ($x,$y,...) = rcols( *HANDLE|&quot;filename&quot;, { EXCLUDE =&gt; &#39;/^!/&#39; }, $col1, $col2, ... )
             $x = rcols( *HANDLE|&quot;filename&quot;, { EXCLUDE =&gt; &#39;/^!/&#39; }, [] )
    ($x,$y,...) = rcols( *HANDLE|&quot;filename&quot;, $col1, $col2, ..., { EXCLUDE =&gt; &#39;/^!/&#39; } )
    ($x,$y,...) = rcols( *HANDLE|&quot;filename&quot;, &quot;/foo/&quot;, $col1, $col2, ... )</code></pre>

<p>For each column number specified, a 1D output PDL will be generated. Anonymous arrays of column numbers generate 2D output ndarrays with dim0 for the column data and dim1 equal to the number of columns in the anonymous array(s).</p>

<p>An empty anonymous array as column specification will produce a single output data ndarray with dim(1) equal to the number of columns available.</p>

<p>There are two calling conventions - the old version, where a pattern can be specified after the filename/handle, and the new version where options are given as as hash reference. This reference can be given as either the second or last argument.</p>

<p>The default behaviour is to ignore lines beginning with a # character and lines that only consist of whitespace. Options exist to only read from lines that match, or do not match, supplied patterns, and to set the types of the created ndarrays.</p>

<p>Can take file name or *HANDLE, and if no explicit column numbers are specified, all are assumed. For the allowed types, see <a href="../Core.html#Datatype_conversions">&quot;Datatype_conversions&quot; in PDL::Core</a>.</p>

<p>Options (case insensitive):</p>

<pre><code>  EXCLUDE or IGNORE
  - ignore lines matching this pattern (default B&lt;&#39;/^#/&#39;&gt;).
  
  INCLUDE or KEEP
  - only use lines which match this pattern (default B&lt;&#39;&#39;&gt;).
  
  LINES   
  - a string pattern specifying which line numbers to use.
  Line numbers start at 0 and the syntax is &#39;a:b:c&#39; to use
  every c&#39;th matching line between a and b (default B&lt;&#39;&#39;&gt;).
  
  DEFTYPE
  - default data type for stored data (if not specified, use the type 
  stored in C&lt;$PDL::IO::Misc::deftype&gt;, which starts off as B&lt;double&gt;).
  
  TYPES
  - reference to an array of data types, one element for each column 
  to be read in.  Any missing columns use the DEFTYPE value (default B&lt;[]&gt;).
  
  COLSEP
  - splits on this string/pattern/qr{} between columns of data. Defaults to
  $PDL::IO::Misc::defcolsep.
  
  PERLCOLS
  - an array of column numbers which are to be read into perl arrays
  rather than ndarrays.  Any columns not specified in the explicit list
  of columns to read will be returned after the explicit columns.
  (default B&lt;undef&gt;).

  COLIDS
  - if defined to an array reference, it will be assigned the column
  ID values obtained by splitting the first line of the file in the
  identical fashion to the column data.

  CHUNKSIZE
  - the number of input data elements to batch together before appending
  to each output data ndarray (Default value is 100).  If CHUNKSIZE is
  greater than the number of lines of data to read, the entire file is
  slurped in, lines split, and perl lists of column data are generated.
  At the end, effectively pdl(@column_data) produces any result ndarrays.

  VERBOSE
  - be verbose about IO processing (default C&lt;$PDL::vebose&gt;)</code></pre>

<p>For example:</p>

<pre><code>  $x      = PDL-&gt;rcols &#39;file1&#39;;         # file1 has only one column of data
  $x      = PDL-&gt;rcols &#39;file2&#39;, [];     # file2 can have multiple columns, still 1 ndarray output
                                        # (empty array ref spec means all possible data fields)

  ($x,$y) = rcols &#39;table.csv&#39;, { COLSEP =&gt; &#39;,&#39; };  # read CSV data file
  ($x,$y) = rcols *STDOUT;  # default separator for lines like &#39;32 24&#39;

  # read in lines containing the string foo, where the first
  # example also ignores lines that begin with a # character.
  ($x,$y,$z) = rcols &#39;file2&#39;, 0,4,5, { INCLUDE =&gt; &#39;/foo/&#39; };
  ($x,$y,$z) = rcols &#39;file2&#39;, 0,4,5, { INCLUDE =&gt; &#39;/foo/&#39;, EXCLUDE =&gt; &#39;&#39; };

  # ignore the first 27 lines of the file, reading in as ushort&#39;s
  ($x,$y) = rcols &#39;file3&#39;, { LINES =&gt; &#39;27:-1&#39;, DEFTYPE =&gt; ushort };
  ($x,$y) = rcols &#39;file3&#39;, { LINES =&gt; &#39;27:&#39;, TYPES =&gt; [ ushort, ushort ] };

  # read in the first column as a perl array and the next two as ndarrays
  # with the perl column returned after the ndarray outputs
  ($x,$y,$name) = rcols &#39;file4&#39;, 1, 2   , { PERLCOLS =&gt; [ 0 ] };
  printf &quot;Number of names read in = %d\n&quot;, 1 + $#$name;

  # read in the first column as a perl array and the next two as ndarrays
  # with PERLCOLS changing the type of the first returned value to perl list ref
  ($name,$x,$y) = rcols &#39;file4&#39;, 0, 1, 2, { PERLCOLS =&gt; [ 0 ] };

  # read in the first column as a perl array returned first followed by the
  # the next two data columns in the file as a single Nx2 ndarray 
  ($name,$xy) = rcols &#39;file4&#39;, 0, [1, 2], { PERLCOLS =&gt; [ 0 ] };


  NOTES:

  1. Quotes are required on patterns or use the qr{} quote regexp syntax.
  
  2. Columns are separated by whitespace by default, use the COLSEP option
     separator to specify an alternate split pattern or string or specify an
     alternate default separator by setting C&lt;$PDL::IO::Misc::defcolsep&gt; .
  
  3. Legacy support is present to use C&lt;$PDL::IO::Misc::colsep&gt; to set the
     column separator but C&lt;$PDL::IO::Misc::colsep&gt; is not defined by default.
     If you set the variable to a defined value it will get picked up.
  
  4. LINES =&gt; &#39;-1:0:3&#39; may not work as you expect, since lines are skipped
     when read in, then the whole array reversed.

  5. For consistency with wcols and rcols 1D usage, column data is loaded
     into the rows of the pdls (i.e., dim(0) is the elements read per column
     in the file and dim(1) is the number of columns of data read.</code></pre>

<h2 id="wcols">wcols</h2>

<pre><code>  Write ASCII columns into file from 1D or 2D ndarrays and/or 1D listrefs efficiently.</code></pre>

<p>Can take file name or *HANDLE, and if no file/filehandle is given defaults to STDOUT.</p>

<pre><code>  Options (case insensitive):

    HEADER - prints this string before the data. If the string
             is not terminated by a newline, one is added. (default B&lt;&#39;&#39;&gt;).

    COLSEP - prints this string between columns of data. Defaults to
             $PDL::IO::Misc::defcolsep.

    FORMAT - A printf-style format string that is cycled through
             column output for user controlled formatting.</code></pre>

<pre><code> Usage: wcols $data1, $data2, $data3,..., *HANDLE|&quot;outfile&quot;, [\%options];  # or
        wcols $format_string, $data1, $data2, $data3,..., *HANDLE|&quot;outfile&quot;, [\%options];

   where the $dataN args are either 1D ndarrays, 1D perl array refs,
   or 2D ndarrays (as might be returned from rcols() with the [] column
   syntax and/or using the PERLCOLS option).  dim(0) of all ndarrays
   written must be the same size.  The printf-style $format_string,
   if given, overrides any FORMAT key settings in the option hash.</code></pre>

<p>e.g.,</p>

<pre><code>  $x = random(4); $y = ones(4);
  wcols $x, $y+2, &#39;foo.dat&#39;;
  wcols $x, $y+2, *STDERR;
  wcols $x, $y+2, &#39;|wc&#39;;

  $x = sequence(3); $y = zeros(3); $c = random(3);
  wcols $x,$y,$c; # Orthogonal version of &#39;print $x,$y,$c&#39; :-)

  wcols &quot;%10.3f&quot;, $x,$y; # Formatted
  wcols &quot;%10.3f %10.5g&quot;, $x,$y; # Individual column formatting

  $x = sequence(3); $y = zeros(3); $units = [ &#39;m/sec&#39;, &#39;kg&#39;, &#39;MPH&#39; ];
  wcols $x,$y, { HEADER =&gt; &quot;#   x   y&quot; };
  wcols $x,$y, { Header =&gt; &quot;#   x   y&quot;, Colsep =&gt; &#39;, &#39; };  # case insensitive option names!
  wcols &quot; %4.1f  %4.1f  %s&quot;,$x,$y,$units, { header =&gt; &quot;# Day  Time  Units&quot; };

  $a52 = sequence(5,2); $y = ones(5); $c = [ 1, 2, 4 ];
  wcols $a52;         # now can write out 2D pdls (2 columns data in output)
  wcols $y, $a52, $c  # ...and mix and match with 1D listrefs as well

  NOTES:

  1. Columns are separated by whitespace by default, use
     C&lt;$PDL::IO::Misc::defcolsep&gt; to modify the default value or
     the COLSEP option

  2. Support for the C&lt;$PDL::IO::Misc::colsep&gt; global value
     of PDL-2.4.6 and earlier is maintained but the initial value
     of the global is undef until you set it.  The value will be
     then be picked up and used as if defcolsep were specified.

  3. Dim 0 corresponds to the column data dimension for both
     rcols and wcols.  This makes wcols the reverse operation
     of rcols.</code></pre>

<h2 id="swcols">swcols</h2>

<p>generate string list from <code>sprintf</code> format specifier and a list of ndarrays</p>

<p><code>swcols</code> takes an (optional) format specifier of the printf sort and a list of 1D ndarrays as input. It returns a perl array (or array reference if called in scalar context) where each element of the array is the string generated by printing the corresponding element of the ndarray(s) using the format specified. If no format is specified it uses the default print format.</p>

<pre><code> Usage: @str = swcols format, pdl1,pdl2,pdl3,...;
    or  $str = swcols format, pdl1,pdl2,pdl3,...;</code></pre>

<h2 id="rgrep">rgrep</h2>

<pre><code>  Read columns into ndarrays using full regexp pattern matching.
  

  Options:
  
  UNDEFINED: This option determines what will be done for undefined 
  values. For instance when reading a comma-separated file of the type 
  C&lt;1,2,,4&gt; where the C&lt;,,&gt; indicates a missing value. 
  
  The default value is to assign C&lt;$PDL::undefval&gt; to undefined values,
  but if C&lt;UNDEFINED&gt; is set this is used instead. This would normally 
  be set to a number, but if it is set to C&lt;Bad&gt; and PDL is compiled
  with Badvalue support (see L&lt;PDL::Bad/&gt;) then undefined values are set to
  the appropriate badvalue and the column is marked as bad.
  
  DEFTYPE: Sets the default type of the columns - see the documentation for
   L&lt;/rcols()&gt;
  
  TYPES:   A reference to a Perl array with types for each column - see 
  the documentation for L&lt;/rcols()&gt;
  
  BUFFERSIZE: The number of lines to extend the ndarray by. It might speed
  up the reading a little bit by setting this to the number of lines in the
  file, but in general L&lt;/rasc()&gt; is a better choice</code></pre>

<p>Usage</p>

<pre><code> ($x,$y,...) = rgrep(sub, *HANDLE|&quot;filename&quot;)</code></pre>

<p>e.g.</p>

<pre><code> ($x,$y) = rgrep {/Foo (.*) Bar (.*) Mumble/} $file;</code></pre>

<p>i.e. the vectors <code>$x</code> and <code>$y</code> get the progressive values of <code>$1</code>, <code>$2</code> etc.</p>

<h2 id="isbigendian">isbigendian</h2>

<pre><code>  Determine endianness of machine - returns 0 or 1 accordingly</code></pre>

<h2 id="rasc">rasc</h2>

<pre><code>  Simple function to slurp in ASCII numbers quite quickly,
  although error handling is marginal (to nonexistent).</code></pre>

<pre><code>  $pdl-&gt;rasc(&quot;filename&quot;|FILEHANDLE [,$noElements]);

      Where:
        filename is the name of the ASCII file to read or open file handle
        $noElements is the optional number of elements in the file to read.
            (If not present, all of the file will be read to fill up $pdl).
        $pdl can be of type float or double (for more precision).</code></pre>

<pre><code>  #  (test.num is an ascii file with 20 numbers. One number per line.)
  $in = PDL-&gt;null;
  $num = 20;
  $in-&gt;rasc(&#39;test.num&#39;,20);
  $imm = zeroes(float,20,2);
  $imm-&gt;rasc(&#39;test.num&#39;);</code></pre>

<h2 id="rcube">rcube</h2>

<pre><code> Read list of files directly into a large data cube (for efficiency)</code></pre>

<pre><code> $cube = rcube \&amp;reader_function, @files;</code></pre>

<pre><code> $cube = rcube \&amp;rfits, glob(&quot;*.fits&quot;);</code></pre>

<p>This IO function allows direct reading of files into a large data cube, Obviously one could use cat() but this is more memory efficient.</p>

<p>The reading function (e.g. rfits, readfraw) (passed as a reference) and files are the arguments.</p>

<p>The cube is created as the same X,Y dims and datatype as the first image specified. The Z dim is simply the number of images.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) Karl Glazebrook 1997, Craig DeForest 2001, 2003, and Chris Marshall 2010. All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


