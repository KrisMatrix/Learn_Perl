<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>PDL::Ufunc - primitive ufunc operations for pdl</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#prodover">prodover</a></li>
      <li><a href="#cprodover">cprodover</a></li>
      <li><a href="#dprodover">dprodover</a></li>
      <li><a href="#cumuprodover">cumuprodover</a></li>
      <li><a href="#dcumuprodover">dcumuprodover</a></li>
      <li><a href="#sumover">sumover</a></li>
      <li><a href="#csumover">csumover</a></li>
      <li><a href="#dsumover">dsumover</a></li>
      <li><a href="#cumusumover">cumusumover</a></li>
      <li><a href="#dcumusumover">dcumusumover</a></li>
      <li><a href="#andover">andover</a></li>
      <li><a href="#bandover">bandover</a></li>
      <li><a href="#borover">borover</a></li>
      <li><a href="#orover">orover</a></li>
      <li><a href="#zcover">zcover</a></li>
      <li><a href="#intover">intover</a></li>
      <li><a href="#average">average</a></li>
      <li><a href="#avgover">avgover</a></li>
      <li><a href="#caverage">caverage</a></li>
      <li><a href="#cavgover">cavgover</a></li>
      <li><a href="#daverage">daverage</a></li>
      <li><a href="#davgover">davgover</a></li>
      <li><a href="#minimum">minimum</a></li>
      <li><a href="#minover">minover</a></li>
      <li><a href="#minimum_ind">minimum_ind</a></li>
      <li><a href="#minover_ind">minover_ind</a></li>
      <li><a href="#minimum_n_ind">minimum_n_ind</a></li>
      <li><a href="#minover_n_ind">minover_n_ind</a></li>
      <li><a href="#maximum">maximum</a></li>
      <li><a href="#maxover">maxover</a></li>
      <li><a href="#maximum_ind">maximum_ind</a></li>
      <li><a href="#maxover_ind">maxover_ind</a></li>
      <li><a href="#maximum_n_ind">maximum_n_ind</a></li>
      <li><a href="#maxover_n_ind">maxover_n_ind</a></li>
      <li><a href="#minmaximum">minmaximum</a></li>
      <li><a href="#minmaxover">minmaxover</a></li>
      <li><a href="#avg">avg</a></li>
      <li><a href="#sum">sum</a></li>
      <li><a href="#prod">prod</a></li>
      <li><a href="#davg">davg</a></li>
      <li><a href="#dsum">dsum</a></li>
      <li><a href="#dprod">dprod</a></li>
      <li><a href="#zcheck">zcheck</a></li>
      <li><a href="#and">and</a></li>
      <li><a href="#band">band</a></li>
      <li><a href="#or">or</a></li>
      <li><a href="#bor">bor</a></li>
      <li><a href="#min">min</a></li>
      <li><a href="#max">max</a></li>
      <li><a href="#median">median</a></li>
      <li><a href="#mode">mode</a></li>
      <li><a href="#oddmedian">oddmedian</a></li>
      <li><a href="#any">any</a></li>
      <li><a href="#all">all</a></li>
      <li><a href="#minmax">minmax</a></li>
      <li><a href="#medover">medover</a></li>
      <li><a href="#oddmedover">oddmedover</a></li>
      <li><a href="#modeover">modeover</a></li>
      <li><a href="#pctover">pctover</a></li>
      <li><a href="#oddpctover">oddpctover</a></li>
      <li><a href="#pct">pct</a></li>
      <li><a href="#oddpct">oddpct</a></li>
      <li><a href="#qsort">qsort</a></li>
      <li><a href="#qsorti">qsorti</a></li>
      <li><a href="#qsortvec">qsortvec</a></li>
      <li><a href="#qsortveci">qsortveci</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>PDL::Ufunc - primitive ufunc operations for pdl</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides some primitive and useful functions defined using PDL::PP based on functionality of what are sometimes called <i>ufuncs</i> (for example NumPY and Mathematica talk about these). It collects all the functions generally used to <code>reduce</code> or <code>accumulate</code> along a dimension. These all do their job across the first dimension but by using the slicing functions you can do it on any dimension.</p>

<p>The <a href="./Reduce.html">PDL::Reduce</a> module provides an alternative interface to many of the functions in this module.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> use PDL::Ufunc;</code></pre>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="prodover">prodover</h2>

<pre><code>  Signature: (a(n); int+ [o]b())</code></pre>

<p>Project via product to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the product along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = prodover($x);</code></pre>

<pre><code> $spectrum = prodover $image-&gt;transpose</code></pre>

<p>prodover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="cprodover">cprodover</h2>

<pre><code>  Signature: (a(n); cdouble [o]b())</code></pre>

<p>Project via product to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the product along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = cprodover($x);</code></pre>

<pre><code> $spectrum = cprodover $image-&gt;transpose</code></pre>

<p>Unlike <a href="#prodover">&quot;prodover&quot;</a>, the calculations are performed in complex double precision.</p>

<p>cprodover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="dprodover">dprodover</h2>

<pre><code>  Signature: (a(n); double [o]b())</code></pre>

<p>Project via product to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the product along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = dprodover($x);</code></pre>

<pre><code> $spectrum = dprodover $image-&gt;transpose</code></pre>

<p>Unlike <a href="#prodover">&quot;prodover&quot;</a>, the calculations are performed in double precision.</p>

<p>dprodover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="cumuprodover">cumuprodover</h2>

<pre><code>  Signature: (a(n); int+ [o]b(n))</code></pre>

<p>Cumulative product</p>

<p>This function calculates the cumulative product along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<p>The sum is started so that the first element in the cumulative product is the first element of the parameter.</p>

<pre><code> $y = cumuprodover($x);</code></pre>

<pre><code> $spectrum = cumuprodover $image-&gt;transpose</code></pre>

<p>cumuprodover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="dcumuprodover">dcumuprodover</h2>

<pre><code>  Signature: (a(n); double [o]b(n))</code></pre>

<p>Cumulative product</p>

<p>This function calculates the cumulative product along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<p>The sum is started so that the first element in the cumulative product is the first element of the parameter.</p>

<pre><code> $y = dcumuprodover($x);</code></pre>

<pre><code> $spectrum = dcumuprodover $image-&gt;transpose</code></pre>

<p>Unlike <a href="#cumuprodover">&quot;cumuprodover&quot;</a>, the calculations are performed in double precision.</p>

<p>dcumuprodover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="sumover">sumover</h2>

<pre><code>  Signature: (a(n); int+ [o]b())</code></pre>

<p>Project via sum to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the sum along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = sumover($x);</code></pre>

<pre><code> $spectrum = sumover $image-&gt;transpose</code></pre>

<p>sumover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="csumover">csumover</h2>

<pre><code>  Signature: (a(n); cdouble [o]b())</code></pre>

<p>Project via sum to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the sum along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = csumover($x);</code></pre>

<pre><code> $spectrum = csumover $image-&gt;transpose</code></pre>

<p>Unlike <a href="#sumover">&quot;sumover&quot;</a>, the calculations are performed in complex double precision.</p>

<p>csumover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="dsumover">dsumover</h2>

<pre><code>  Signature: (a(n); double [o]b())</code></pre>

<p>Project via sum to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the sum along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = dsumover($x);</code></pre>

<pre><code> $spectrum = dsumover $image-&gt;transpose</code></pre>

<p>Unlike <a href="#sumover">&quot;sumover&quot;</a>, the calculations are performed in double precision.</p>

<p>dsumover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="cumusumover">cumusumover</h2>

<pre><code>  Signature: (a(n); int+ [o]b(n))</code></pre>

<p>Cumulative sum</p>

<p>This function calculates the cumulative sum along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<p>The sum is started so that the first element in the cumulative sum is the first element of the parameter.</p>

<pre><code> $y = cumusumover($x);</code></pre>

<pre><code> $spectrum = cumusumover $image-&gt;transpose</code></pre>

<p>cumusumover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="dcumusumover">dcumusumover</h2>

<pre><code>  Signature: (a(n); double [o]b(n))</code></pre>

<p>Cumulative sum</p>

<p>This function calculates the cumulative sum along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<p>The sum is started so that the first element in the cumulative sum is the first element of the parameter.</p>

<pre><code> $y = dcumusumover($x);</code></pre>

<pre><code> $spectrum = dcumusumover $image-&gt;transpose</code></pre>

<p>Unlike <a href="#cumusumover">&quot;cumusumover&quot;</a>, the calculations are performed in double precision.</p>

<p>dcumusumover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="andover">andover</h2>

<pre><code>  Signature: (a(n); int+ [o]b())</code></pre>

<p>Project via and to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the and along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = andover($x);</code></pre>

<pre><code> $spectrum = andover $image-&gt;transpose</code></pre>

<p>If <code>a()</code> contains only bad data (and its bad flag is set), <code>b()</code> is set bad. Otherwise <code>b()</code> will have its bad flag cleared, as it will not contain any bad values.</p>

<h2 id="bandover">bandover</h2>

<pre><code>  Signature: (a(n);  [o]b())</code></pre>

<p>Project via bitwise and to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the bitwise and along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = bandover($x);</code></pre>

<pre><code> $spectrum = bandover $image-&gt;transpose</code></pre>

<p>If <code>a()</code> contains only bad data (and its bad flag is set), <code>b()</code> is set bad. Otherwise <code>b()</code> will have its bad flag cleared, as it will not contain any bad values.</p>

<h2 id="borover">borover</h2>

<pre><code>  Signature: (a(n);  [o]b())</code></pre>

<p>Project via bitwise or to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the bitwise or along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = borover($x);</code></pre>

<pre><code> $spectrum = borover $image-&gt;transpose</code></pre>

<p>If <code>a()</code> contains only bad data (and its bad flag is set), <code>b()</code> is set bad. Otherwise <code>b()</code> will have its bad flag cleared, as it will not contain any bad values.</p>

<h2 id="orover">orover</h2>

<pre><code>  Signature: (a(n); int+ [o]b())</code></pre>

<p>Project via or to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the or along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = orover($x);</code></pre>

<pre><code> $spectrum = orover $image-&gt;transpose</code></pre>

<p>If <code>a()</code> contains only bad data (and its bad flag is set), <code>b()</code> is set bad. Otherwise <code>b()</code> will have its bad flag cleared, as it will not contain any bad values.</p>

<h2 id="zcover">zcover</h2>

<pre><code>  Signature: (a(n); int+ [o]b())</code></pre>

<p>Project via == 0 to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the == 0 along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = zcover($x);</code></pre>

<pre><code> $spectrum = zcover $image-&gt;transpose</code></pre>

<p>If <code>a()</code> contains only bad data (and its bad flag is set), <code>b()</code> is set bad. Otherwise <code>b()</code> will have its bad flag cleared, as it will not contain any bad values.</p>

<h2 id="intover">intover</h2>

<pre><code>  Signature: (a(n); float+ [o]b())</code></pre>

<p>Project via integral to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the integral along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = intover($x);</code></pre>

<pre><code> $spectrum = intover $image-&gt;transpose</code></pre>

<p>Notes:</p>

<p><code>intover</code> uses a point spacing of one (i.e., delta-h==1). You will need to scale the result to correct for the true point delta).</p>

<p>For <code>n &gt; 3</code>, these are all <code>O(h^4)</code> (like Simpson&#39;s rule), but are integrals between the end points assuming the pdl gives values just at these centres: for such `functions&#39;, sumover is correct to <code>O(h)</code>, but is the natural (and correct) choice for binned data, of course.</p>

<p>intover ignores the bad-value flag of the input ndarrays. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="average">average</h2>

<pre><code>  Signature: (a(n); int+ [o]b())</code></pre>

<p>Project via average to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the average along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = average($x);</code></pre>

<pre><code> $spectrum = average $image-&gt;transpose</code></pre>

<p>average processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="avgover">avgover</h2>

<pre><code>  Synonym for average.</code></pre>

<h2 id="caverage">caverage</h2>

<pre><code>  Signature: (a(n); cdouble [o]b())</code></pre>

<p>Project via average to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the average along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = caverage($x);</code></pre>

<pre><code> $spectrum = caverage $image-&gt;transpose</code></pre>

<p>Unlike <a href="#average">average</a>, the calculation is performed in complex double precision.</p>

<p>caverage processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="cavgover">cavgover</h2>

<pre><code>  Synonym for caverage.</code></pre>

<h2 id="daverage">daverage</h2>

<pre><code>  Signature: (a(n); double [o]b())</code></pre>

<p>Project via average to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the average along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = daverage($x);</code></pre>

<pre><code> $spectrum = daverage $image-&gt;transpose</code></pre>

<p>Unlike <a href="#average">average</a>, the calculation is performed in double precision.</p>

<p>daverage processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="davgover">davgover</h2>

<pre><code>  Synonym for daverage.</code></pre>

<h2 id="minimum">minimum</h2>

<pre><code>  Signature: (a(n); [o]c())</code></pre>

<p>Project via minimum to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the minimum along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = minimum($x);</code></pre>

<pre><code> $spectrum = minimum $image-&gt;transpose</code></pre>

<p>Output is set bad if no elements of the input are non-bad, otherwise the bad flag is cleared for the output ndarray.</p>

<p>Note that <code>NaNs</code> are considered to be valid values and will &quot;win&quot; over non-<code>NaN</code>; see <a href="./Math.html#isfinite">isfinite</a> and <a href="./Bad.html#badmask">badmask</a> for ways of masking NaNs.</p>

<h2 id="minover">minover</h2>

<pre><code>  Synonym for minimum.</code></pre>

<h2 id="minimum_ind">minimum_ind</h2>

<pre><code>  Signature: (a(n); indx [o] c())</code></pre>

<p>Like minimum but returns the index rather than the value</p>

<p>Output is set bad if no elements of the input are non-bad, otherwise the bad flag is cleared for the output ndarray.</p>

<p>Note that <code>NaNs</code> are considered to be valid values and will &quot;win&quot; over non-<code>NaN</code>; see <a href="./Math.html#isfinite">isfinite</a> and <a href="./Bad.html#badmask">badmask</a> for ways of masking NaNs.</p>

<h2 id="minover_ind">minover_ind</h2>

<pre><code>  Synonym for minimum_ind.</code></pre>

<h2 id="minimum_n_ind">minimum_n_ind</h2>

<pre><code>  Signature: (a(n); indx [o]c(m); PDL_Indx m_size =&gt; m)</code></pre>

<p>Returns the index of <code>m_size</code> minimum elements. As of 2.077, you can specify how many by either passing in an ndarray of the given size (DEPRECATED - will be converted to indx if needed and the input arg will be set to that), or just the size, or a null and the size.</p>

<pre><code>  minimum_n_ind($pdl, $out = zeroes(5)); # DEPRECATED
  $out = minimum_n_ind($pdl, 5);
  minimum_n_ind($pdl, $out = null, 5);</code></pre>

<p>Output bad flag is cleared for the output ndarray if sufficient non-bad elements found, else remaining slots in <code>$c()</code> are set bad.</p>

<p>Note that <code>NaNs</code> are considered to be valid values and will &quot;win&quot; over non-<code>NaN</code>; see <a href="./Math.html#isfinite">isfinite</a> and <a href="./Bad.html#badmask">badmask</a> for ways of masking NaNs.</p>

<h2 id="minover_n_ind">minover_n_ind</h2>

<pre><code>  Synonym for minimum_n_ind.</code></pre>

<h2 id="maximum">maximum</h2>

<pre><code>  Signature: (a(n); [o]c())</code></pre>

<p>Project via maximum to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the maximum along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = maximum($x);</code></pre>

<pre><code> $spectrum = maximum $image-&gt;transpose</code></pre>

<p>Output is set bad if no elements of the input are non-bad, otherwise the bad flag is cleared for the output ndarray.</p>

<p>Note that <code>NaNs</code> are considered to be valid values and will &quot;win&quot; over non-<code>NaN</code>; see <a href="./Math.html#isfinite">isfinite</a> and <a href="./Bad.html#badmask">badmask</a> for ways of masking NaNs.</p>

<h2 id="maxover">maxover</h2>

<pre><code>  Synonym for maximum.</code></pre>

<h2 id="maximum_ind">maximum_ind</h2>

<pre><code>  Signature: (a(n); indx [o] c())</code></pre>

<p>Like maximum but returns the index rather than the value</p>

<p>Output is set bad if no elements of the input are non-bad, otherwise the bad flag is cleared for the output ndarray.</p>

<p>Note that <code>NaNs</code> are considered to be valid values and will &quot;win&quot; over non-<code>NaN</code>; see <a href="./Math.html#isfinite">isfinite</a> and <a href="./Bad.html#badmask">badmask</a> for ways of masking NaNs.</p>

<h2 id="maxover_ind">maxover_ind</h2>

<pre><code>  Synonym for maximum_ind.</code></pre>

<h2 id="maximum_n_ind">maximum_n_ind</h2>

<pre><code>  Signature: (a(n); indx [o]c(m); PDL_Indx m_size =&gt; m)</code></pre>

<p>Returns the index of <code>m_size</code> maximum elements. As of 2.077, you can specify how many by either passing in an ndarray of the given size (DEPRECATED - will be converted to indx if needed and the input arg will be set to that), or just the size, or a null and the size.</p>

<pre><code>  maximum_n_ind($pdl, $out = zeroes(5)); # DEPRECATED
  $out = maximum_n_ind($pdl, 5);
  maximum_n_ind($pdl, $out = null, 5);</code></pre>

<p>Output bad flag is cleared for the output ndarray if sufficient non-bad elements found, else remaining slots in <code>$c()</code> are set bad.</p>

<p>Note that <code>NaNs</code> are considered to be valid values and will &quot;win&quot; over non-<code>NaN</code>; see <a href="./Math.html#isfinite">isfinite</a> and <a href="./Bad.html#badmask">badmask</a> for ways of masking NaNs.</p>

<h2 id="maxover_n_ind">maxover_n_ind</h2>

<pre><code>  Synonym for maximum_n_ind.</code></pre>

<h2 id="minmaximum">minmaximum</h2>

<pre><code>  Signature: (a(n); [o]cmin(); [o] cmax(); indx [o]cmin_ind(); indx [o]cmax_ind())</code></pre>

<p>Find minimum and maximum and their indices for a given ndarray;</p>

<pre><code> pdl&gt; $x=pdl [[-2,3,4],[1,0,3]]
 pdl&gt; ($min, $max, $min_ind, $max_ind)=minmaximum($x)
 pdl&gt; p $min, $max, $min_ind, $max_ind
 [-2 0] [4 3] [0 1] [2 2]</code></pre>

<p>See also <a href="#minmax">&quot;minmax&quot;</a>, which clumps the ndarray together.</p>

<p>If <code>a()</code> contains only bad data, then the output ndarrays will be set bad, along with their bad flag. Otherwise they will have their bad flags cleared, since they will not contain any bad values.</p>

<h2 id="minmaxover">minmaxover</h2>

<pre><code>  Synonym for minmaximum.</code></pre>

<h2 id="avg">avg</h2>

<p>Return the average of all elements in an ndarray.</p>

<p>See the documentation for <a href="#average">&quot;average&quot;</a> for more information.</p>

<pre><code> $x = avg($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="sum">sum</h2>

<p>Return the sum of all elements in an ndarray.</p>

<p>See the documentation for <a href="#sumover">&quot;sumover&quot;</a> for more information.</p>

<pre><code> $x = sum($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="prod">prod</h2>

<p>Return the product of all elements in an ndarray.</p>

<p>See the documentation for <a href="#prodover">&quot;prodover&quot;</a> for more information.</p>

<pre><code> $x = prod($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="davg">davg</h2>

<p>Return the average (in double precision) of all elements in an ndarray.</p>

<p>See the documentation for <a href="#daverage">&quot;daverage&quot;</a> for more information.</p>

<pre><code> $x = davg($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="dsum">dsum</h2>

<p>Return the sum (in double precision) of all elements in an ndarray.</p>

<p>See the documentation for <a href="#dsumover">&quot;dsumover&quot;</a> for more information.</p>

<pre><code> $x = dsum($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="dprod">dprod</h2>

<p>Return the product (in double precision) of all elements in an ndarray.</p>

<p>See the documentation for <a href="#dprodover">&quot;dprodover&quot;</a> for more information.</p>

<pre><code> $x = dprod($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="zcheck">zcheck</h2>

<p>Return the check for zero of all elements in an ndarray.</p>

<p>See the documentation for <a href="#zcover">&quot;zcover&quot;</a> for more information.</p>

<pre><code> $x = zcheck($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="and">and</h2>

<p>Return the logical and of all elements in an ndarray.</p>

<p>See the documentation for <a href="#andover">&quot;andover&quot;</a> for more information.</p>

<pre><code> $x = and($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="band">band</h2>

<p>Return the bitwise and of all elements in an ndarray.</p>

<p>See the documentation for <a href="#bandover">&quot;bandover&quot;</a> for more information.</p>

<pre><code> $x = band($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="or">or</h2>

<p>Return the logical or of all elements in an ndarray.</p>

<p>See the documentation for <a href="#orover">&quot;orover&quot;</a> for more information.</p>

<pre><code> $x = or($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="bor">bor</h2>

<p>Return the bitwise or of all elements in an ndarray.</p>

<p>See the documentation for <a href="#borover">&quot;borover&quot;</a> for more information.</p>

<pre><code> $x = bor($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="min">min</h2>

<p>Return the minimum of all elements in an ndarray.</p>

<p>See the documentation for <a href="#minimum">&quot;minimum&quot;</a> for more information.</p>

<pre><code> $x = min($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="max">max</h2>

<p>Return the maximum of all elements in an ndarray.</p>

<p>See the documentation for <a href="#maximum">&quot;maximum&quot;</a> for more information.</p>

<pre><code> $x = max($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="median">median</h2>

<p>Return the median of all elements in an ndarray.</p>

<p>See the documentation for <a href="#medover">&quot;medover&quot;</a> for more information.</p>

<pre><code> $x = median($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="mode">mode</h2>

<p>Return the mode of all elements in an ndarray.</p>

<p>See the documentation for <a href="#modeover">&quot;modeover&quot;</a> for more information.</p>

<pre><code> $x = mode($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="oddmedian">oddmedian</h2>

<p>Return the oddmedian of all elements in an ndarray.</p>

<p>See the documentation for <a href="#oddmedover">&quot;oddmedover&quot;</a> for more information.</p>

<pre><code> $x = oddmedian($data);</code></pre>

<p>This routine handles bad values.</p>

<h2 id="any">any</h2>

<p>Return true if any element in ndarray set</p>

<p>Useful in conditional expressions:</p>

<pre><code> if (any $x&gt;15) { print &quot;some values are greater than 15\n&quot; }</code></pre>

<p>See <a href="#or">&quot;or&quot;</a> for comments on what happens when all elements in the check are bad.</p>

<h2 id="all">all</h2>

<p>Return true if all elements in ndarray set</p>

<p>Useful in conditional expressions:</p>

<pre><code> if (all $x&gt;15) { print &quot;all values are greater than 15\n&quot; }</code></pre>

<p>See <a href="#and">&quot;and&quot;</a> for comments on what happens when all elements in the check are bad.</p>

<h2 id="minmax">minmax</h2>

<p>Returns a list with minimum and maximum values of an ndarray.</p>

<pre><code> ($mn, $mx) = minmax($pdl);</code></pre>

<p>This routine does <i>not</i> broadcast over the dimensions of <code>$pdl</code>; it returns the minimum and maximum values of the whole ndarray. See <a href="#minmaximum">&quot;minmaximum&quot;</a> if this is not what is required. The two values are returned as Perl scalars, and therefore ignore whether the values are bad.</p>

<pre><code> pdl&gt; $x = pdl [1,-2,3,5,0]
 pdl&gt; ($min, $max) = minmax($x);
 pdl&gt; p &quot;$min $max\n&quot;;
 -2 5</code></pre>

<h2 id="medover">medover</h2>

<pre><code>  Signature: (a(n); [o]b(); [t]tmp(n))</code></pre>

<p>Project via median to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the median along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = medover($x);</code></pre>

<pre><code> $spectrum = medover $image-&gt;transpose</code></pre>

<p>medover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="oddmedover">oddmedover</h2>

<pre><code>  Signature: (a(n); [o]b(); [t]tmp(n))</code></pre>

<p>Project via oddmedian to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the oddmedian along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = oddmedover($x);</code></pre>

<pre><code> $spectrum = oddmedover $image-&gt;transpose</code></pre>

<p>The median is sometimes not a good choice as if the array has an even number of elements it lies half-way between the two middle values - thus it does not always correspond to a data value. The lower-odd median is just the lower of these two values and so it ALWAYS sits on an actual data value which is useful in some circumstances.</p>

<p>oddmedover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="modeover">modeover</h2>

<pre><code>  Signature: (data(n); [o]out(); [t]sorted(n))</code></pre>

<p>Project via mode to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the mode along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = modeover($x);</code></pre>

<pre><code> $spectrum = modeover $image-&gt;transpose</code></pre>

<p>The mode is the single element most frequently found in a discrete data set.</p>

<p>It <i>only</i> makes sense for integer data types, since floating-point types are demoted to integer before the mode is calculated.</p>

<p><code>modeover</code> treats BAD the same as any other value: if BAD is the most common element, the returned value is also BAD.</p>

<p>modeover does not process bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="pctover">pctover</h2>

<pre><code>  Signature: (a(n); p(); [o]b(); [t]tmp(n))</code></pre>

<p>Project via specified percentile to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the specified percentile along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = pctover($x);</code></pre>

<pre><code> $spectrum = pctover $image-&gt;transpose</code></pre>

<p>The specified percentile must be between 0.0 and 1.0. When the specified percentile falls between data points, the result is interpolated. Values outside the allowed range are clipped to 0.0 or 1.0 respectively. The algorithm implemented here is based on the interpolation variant described at <a href="http://en.wikipedia.org/wiki/Percentile">http://en.wikipedia.org/wiki/Percentile</a> as used by Microsoft Excel and recommended by NIST.</p>

<p>pctover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="oddpctover">oddpctover</h2>

<pre><code>  Signature: (a(n); p(); [o]b(); [t]tmp(n))</code></pre>

<p>Project via specified percentile to N-1 dimensions</p>

<p>This function reduces the dimensionality of an ndarray by one by taking the specified percentile along the 1st dimension.</p>

<p>By using <a href="./Slices.html#xchg">xchg</a> etc. it is possible to use <i>any</i> dimension.</p>

<pre><code> $y = oddpctover($x);</code></pre>

<pre><code> $spectrum = oddpctover $image-&gt;transpose</code></pre>

<p>The specified percentile must be between 0.0 and 1.0. When the specified percentile falls between two values, the nearest data value is the result. The algorithm implemented is from the textbook version described first at <a href="http://en.wikipedia.org/wiki/Percentile">http://en.wikipedia.org/wiki/Percentile</a>.</p>

<p>oddpctover processes bad values. It will set the bad-value flag of all output ndarrays if the flag is set for any of the input ndarrays.</p>

<h2 id="pct">pct</h2>

<p>Return the specified percentile of all elements in an ndarray. The specified percentile (p) must be between 0.0 and 1.0. When the specified percentile falls between data points, the result is interpolated.</p>

<pre><code> $x = pct($data, $pct);</code></pre>

<h2 id="oddpct">oddpct</h2>

<p>Return the specified percentile of all elements in an ndarray. The specified percentile (p) must be between 0.0 and 1.0. When the specified percentile falls between data points, the nearest data value is the result.</p>

<pre><code> $x = oddpct($data, $pct);</code></pre>

<h2 id="qsort">qsort</h2>

<pre><code>  Signature: (a(n); [o]b(n))</code></pre>

<p>Quicksort a vector into ascending order.</p>

<pre><code> print qsort random(10);</code></pre>

<p>Bad values are moved to the end of the array:</p>

<pre><code> pdl&gt; p $y
 [42 47 98 BAD 22 96 74 41 79 76 96 BAD 32 76 25 59 BAD 96 32 BAD]
 pdl&gt; p qsort($y)
 [22 25 32 32 41 42 47 59 74 76 76 79 96 96 96 98 BAD BAD BAD BAD]</code></pre>

<h2 id="qsorti">qsorti</h2>

<pre><code>  Signature: (a(n); indx [o]indx(n))</code></pre>

<p>Quicksort a vector and return index of elements in ascending order.</p>

<pre><code> $ix = qsorti $x;
 print $x-&gt;index($ix); # Sorted list</code></pre>

<p>Bad elements are moved to the end of the array:</p>

<pre><code> pdl&gt; p $y
 [42 47 98 BAD 22 96 74 41 79 76 96 BAD 32 76 25 59 BAD 96 32 BAD]
 pdl&gt; p $y-&gt;index( qsorti($y) )
 [22 25 32 32 41 42 47 59 74 76 76 79 96 96 96 98 BAD BAD BAD BAD]</code></pre>

<h2 id="qsortvec">qsortvec</h2>

<pre><code>  Signature: (a(n,m); [o]b(n,m))</code></pre>

<p>Sort a list of vectors lexicographically.</p>

<p>The 0th dimension of the source ndarray is dimension in the vector; the 1st dimension is list order. Higher dimensions are broadcasted over.</p>

<pre><code> print qsortvec pdl([[1,2],[0,500],[2,3],[4,2],[3,4],[3,5]]);
 [
  [  0 500]
  [  1   2]
  [  2   3]
  [  3   4]
  [  3   5]
  [  4   2]
 ]
 </code></pre>

<p>Vectors with bad components are moved to the end of the array:</p>

<pre><code>  pdl&gt; p $p = pdl(&quot;[0 0] [-100 0] [BAD 0] [100 0]&quot;)-&gt;qsortvec

  [
   [-100    0]
   [   0    0]
   [ 100    0]
   [ BAD    0]
  ]</code></pre>

<h2 id="qsortveci">qsortveci</h2>

<pre><code>  Signature: (a(n,m); indx [o]indx(m))</code></pre>

<p>Sort a list of vectors lexicographically, returning the indices of the sorted vectors rather than the sorted list itself.</p>

<p>As with <code>qsortvec</code>, the input PDL should be an NxM array containing M separate N-dimensional vectors. The return value is an integer M-PDL containing the M-indices of original array rows, in sorted order.</p>

<p>As with <code>qsortvec</code>, the zeroth element of the vectors runs slowest in the sorted list.</p>

<p>Additional dimensions are broadcasted over: each plane is sorted separately, so qsortveci may be thought of as a collapse operator of sorts (groan).</p>

<p>Vectors with bad components are moved to the end of the array as for <a href="#qsortvec">&quot;qsortvec&quot;</a>.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Copyright (C) Tuomas J. Lukka 1997 (lukka@husc.harvard.edu). Contributions by Christian Soeller (c.soeller@auckland.ac.nz) and Karl Glazebrook (kgb@aaoepp.aao.gov.au). All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>


</body>

</html>


